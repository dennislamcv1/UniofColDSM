#
# ROIstat
# Click the 'Run App' button above
#

# You can also run it in RGui by opening the RGui window and typing (without the #):
# require(shiny)
# runApp("C://path//to//this//file//")

# ROIstat can also be run in the online RStudio Cloud at https://posit.co/products/cloud/cloud/
# by uploading the zip file into the workspace.

# The following packages need to be installed. Refer to the download page at
# https://www.roi-ally.com/index.php/en/hidden-blogs/roistat/download-roistat
# for instructions on how to do that.

require(shiny)
require(datamods)
require(shinyWidgets)
require(emmeans)
require(nlme)
require(DT)
require(tidyverse)
require(propagate)#this is a custom forked version to work with Shiny https://github.com/ProfessorPeregrine/propagate
require(svglite)
require(agop)
require(ggh4x)
require(car)
require(lolcat)

#settings for now
options(dplyr.summarise.inform=FALSE)
ro<-round.object #round object function
R<-4 #rounding digits
options(sci.pen=99,digits = 10)    # Increase digits for precision
options(tibble.print_max=Inf)      # Display more of a data frame
options(show.signif.stars=T)   # Flag for * to indicate significance


#Colors
pal_col<-"R4"#default to a colorblind safe , equal perceptual weight, qualitative palette

color=palette.colors(n = 8,palette = pal_col)

col_mean_line=color[3]
col_plot_line=color[1]
col_point_of_interest_line=color[6]
col_fill_highlight=color[2]
col_fill=color[5]
col_line_control_chart=color[4]

#choices for drop downs needed because unicode in a label doesn't always work for some reason####

#Graph Options
curve_fit_choice<-c(
  "None"=0,
  "Linear: y = A + Bx"=1,
  "Exponential: y = Ae(Bx)"=2,
  "Logarithmic: A + B ln x"=3,
  "Proportional: y = Ax"=4,
  "Power: y = Ax^B"=5,
  "Inverse: y = A + B/x"=6,
  "S: y=e(A + B/x)"=14,
  "Compound: y = AB^x"=7,
  "Growth: y = e(A + Bx)"=8,
  "Loess: Locally Weighted Regression"=9,
  "Quadratic: y = A + Bx + Cx\U00B2"=10,
  "Cubic: y = A + Bx + Cx\U00B2 + Dx\U00B3"=11,
  "4th Order: y = A + Bx + Cx\U00B2 + Dx\U00B3 + Ex^4"=12,
  "5th Order: y = A + Bx + Cx\U00B2 + Dx\U00B3 + Ex^4 + Fx^5"=13
)

choice_sd_alt_1<-c("two.sided","less","greater")
names(choice_sd_alt_1) <-c("\U03C3 of sample is not equal to \U03C3\U2080","\U03C3 of sample is less than \U03C3\U2080","\U03C3 of sample is greater than \U03C3\U2080")

choice_mean_alt_1<-c("two.sided","less","greater")
names(choice_mean_alt_1)<-c("\U03BC of sample is not equal to \U03BC\U2080","\U03BC of sample is less than \U03BC\U2080","\U03BC of sample is greater than \U03BC\U2080")

choice_mean_alt_2<-c("two.sided","less","greater")
names(choice_mean_alt_2)<-c("\U03BC\U2081 is not equal to \U03BC\U2082","\U03BC\U2081 is less than \U03BC\U2082","\U03BC\U2081 is greater than \U03BC\U2082")

choice_mean_alt_3<-c("two.sided","less","greater")
names(choice_mean_alt_3)<-c("\U0394 of sample is not equal to \U0394","\U0394 of sample is less than \U0394","\U0394 of sample is greater than \U0394")

choice_prop_alt_1<-c("two.sided","less","greater")
names(choice_prop_alt_1)<-c("\U03C0 of sample is not equal to \U03C0\U2080","\U03C0 of sample is less than \U03C0\U2080","\U03C0 of sample is greater than \U03C0\U2080")

choice_prop_alt_2<-c("two.sided","less","greater")
names(choice_prop_alt_2)<-c("\U03C0\U2081 is not equal to \U03C0\U2082","\U03C0\U2081 is less than \U03C0\U2082","\U03C0\U2081 is greater than \U03C0\U2082")


choice_poi_alt_1<-c("two.sided","less","greater")
names(choice_poi_alt_1)<-c("\U03BB of sample is not equal to \U03BB\U2080","\U03BB of sample is less than \U03BB\U2080","\U03BB of sample is greater than \U03BB\U2080")

choice_poi_alt_2<-c("two.sided","less","greater")
names(choice_poi_alt_2)<-c("\U03BB\U2081 is not equal to \U03BB\U2082","\U03BB\U2081 is less than \U03BB\U2082","\U03BB\U2081 is greater than \U03BB\U2082")

choice_crit <- c(1, 2, 3, 4)
names(choice_crit) <- c("z","t","\U1D6D8\U00B2","F")

choice_sample_size<-c(seq(1,18))
names(choice_sample_size) <- c(
  "One-sample Mean z",
  "One-sample Mean z - alternate",
  "Two-sample Mean z Independent",
  "Two-sample Mean z Independent - alternate",
  "One-sample Mean t Independent",
  "Two-sample Mean t equal variance Independent",
  "Two-sample Mean t unequal variance Independent",
  "Two-sample Mean t Dependent",
  "One-sample Variance",
  "Two-sample Variance Independent",
  "One-sample Pearson r",
  "One-sample Proportion - Approximate",
  "One-sample Proportion - Exact",
  "Two-sample Proportion - Approximate",
  "ANOVA",
  "One-sample Poisson - Exact",
  "One-sample Poisson - Approximate",
  "Two-Sample Poisson - Approximate"
  )

choice_md_test_selection<-c(seq(1,7))
names(choice_md_test_selection)<-c(
  "One-sample z",
  "One-sample t",
  "One-sample test for variance",
  "Two-sample z - Independent",
  "Two-sample t - Independent",
  "Two-sample z - Dependent",
  "Two-sample t - Dependent"
)

choice_import<-c("env", "file", "copypaste", "googlesheets")
names(choice_import) <- c("R Environment","Local File","Paste Data In","Google Sheets")

#choices for statistics entry correlation tests alternate hyp
choice_corr_alt_text<-c(
  "\U1D70C of sample is not equal to \U1D70C\U2080","\U1D70C of sample is less than \U1D70C\U2080","\U1D70C of sample is greater than \U1D70C\U2080",
  "\U1D70C\U209B is not equal to 0","\U1D70C\U209B is less than 0","\U1D70C\U209B is greater than 0",
  "\U1D70F is not equal to 0","\U1D70F is less than 0","\U1D70F is greater than 0",
  "\U1D711 is not equal to 0","","",
  "\U1D70C\U2081\U2082 is not equal to \U1D70C\U2083\U2084","\U1D70C\U2081\U2082 is less than \U1D70C\U2083\U2084","\U1D70C\U2081\U2082 is greater than \U1D70C\U2083\U2084",
  "\U1D6FE\U2081 is not equal to \U1D6FE\U2082","\U1D6FE\U2081 is less than \U1D6FE\U2082","\U1D6FE\U2081 is greater than \U1D6FE\U2082",
  "\U1D73F\U2081 is not equal to \U1D73F\U2082","\U1D73F\U2081 is less than \U1D73F\U2082","\U1D73F\U2081 is greater than \U1D73F\U2082",
  "\U1D70C\U2081\U2083 is not equal to \U1D70C\U2082\U2083","\U1D70C\U2081\U2083 is less than \U1D70C\U2082\U2083","\U1D70C\U2081\U2083 is greater than \U1D70C\U2082\U2083",
  "\U1D73F is not equal to 0","\U1D73F is less than 0","\U1D73F is greater than 0"
)

#choices for statistics entry correlation tests alternate hyp need to add for data
choice_corr_alt_text_data<-c(
  "\U1D70C of sample is not equal to \U1D70C\U2080","\U1D70C of sample is less than \U1D70C\U2080","\U1D70C of sample is greater than \U1D70C\U2080",
  "\U1D70C\U209B is not equal to 0","\U1D70C\U209B is less than 0","\U1D70C\U209B is greater than 0",
  "\U1D70F is not equal to 0","\U1D70F is less than 0","\U1D70F is greater than 0",
  "V is not equal to 0","","",
  "\U1D70C is not equal to 0","\U1D70C is less than 0","\U1D70C is greater than 0",
  "\U1D70C is not equal to 0","\U1D70C is less than 0","\U1D70C is greater than 0",
"True Q is not equal to 0","True Q is less than 0","True Q is greater than 0",
"True G is not equal to \U03B3\U2080","True G is less than \U03B3\U2080","True G is greater than \U03B3\U2080",
"\U1D70C\U209C is not equal to 0","\U1D70C\U209C is less than 0","\U1D70C\U209C is greater than 0",
"\U1D73F is not equal to 0","\U1D73F is less than 0","\U1D73F is greater than 0",
"W' is not equal to 0","W' is less than 0","W' is greater than 0",
"J' is not equal to 0","J' is less than 0","J' is greater than 0",
"\U1D70C\U2081\U2082 is not equal to \U1D70C\U2083\U2084","\U1D70C\U2081\U2082 is less than \U1D70C\U2083\U2084","\U1D70C\U2081\U2082 is greater than \U1D70C\U2083\U2084",
"\U1D6FE\U2081 is not equal to \U1D6FE\U2082","\U1D6FE\U2081 is less than \U1D6FE\U2082","\U1D6FE\U2081 is greater than \U1D6FE\U2082",
"\U1D73F\U2081 is not equal to \U1D73F\U2082","\U1D73F\U2081 is less than \U1D73F\U2082","\U1D73F\U2081 is greater than \U1D73F\U2082",
"J'\U2081 is not equal to J'\U2082","J'\U2081 is less than J'\U2082","J'\U2081 is greater than J'\U2082",
"\U1D70C\U2081\U2083 is not equal to \U1D70C\U2082\U2083","\U1D70C\U2081\U2083 is less than \U1D70C\U2082\U2083","\U1D70C\U2081\U2083 is greater than \U1D70C\U2082\U2083"
  )



#choices for alternative hyp nonparametric
choice_np_alt_text<-c(
  "M of sample is not equal to M\U2080","M of sample is less than M\U2080","M of sample is greater than M\U2080",
  "M of sample is not equal to M\U2080","M of sample is less than M","M of sample is greater than M",
  "M\U2081 is not equal to M\U2082","M\U2081 is less than M\U2082","M\U2081 is greater than M\U2082",
  "M\U2081 is not equal to M\U2082","M\U2081 is less than M\U2082","M\U2081 of sample is greater than M\U2082",
  "x\U2099 - y\U2099 is not equal to 0","x\U2099 - y\U2099 is less than 0","x\U2099 - y\U2099 is greater than 0",
  "x\U2099 - y\U2099 is not equal to 0","x\U2099 - y\U2099 is less than 0","x\U2099 - y\U2099 is greater than 0",
  "Pass\U2081 Fail\U2082 is not equal to Fail\U2081 Pass\U2082","Pass\U2081 Fail\U2082 is less than Fail\U2081 Pass\U2082","Pass\U2081 Fail\U2082 is greater than Fail\U2081 Pass\U2082"
)

#choices for distribution in natural tolerance calculations
choice_nt<-(1:5)
names(choice_nt)<-c("Normal",
             "Exponential",
             "Binomial",
             "Poisson",
             "\U1D6D8\U00B2")

choice_nt_dat<-(1:3)
names(choice_nt_dat)<-c("Normal",
                    "Exponential(Low)",
                    "Exponential(0)")

choice_x_spc<-c("X-bar"=1,"X"=2)
choice_disp_spc<-c("Range"=1,"Standard Deviation"=2,"Variance"=3,"Moving Range"=4)


choice_x_bar_limits<-(1:9)#for spc limit calculations
names(choice_x_bar_limits)<-c(
  "Average Range",
  "Median Range",
  "Average Standard Deviation",
  "Median Standard Deviation",
  "Average Variance",
  "Average Moving Range of X-bars",
  "Median Moving Range of X-Bars",
  "Standard Deviation of X-bars",
  "Known \U03c3"
)

choice_x_bar_limits2<-c(seq(1,9),12)#for generating spc charts - all x charts
names(choice_x_bar_limits2)<-c(
  "Average Range",
  "Median Range",
  "Average Standard Deviation",
  "Median Standard Deviation",
  "Average Variance",
  "Average Moving Range of X-bars",
  "Median Moving Range of X-Bars",
  "Standard Deviation of X-bars",
  "Known \U03c3",
  # "Centerline Only",
  # "None",
  "Custom"
)

choice_x_tilde_limits<-(1:9)
names(choice_x_tilde_limits)<-c(
  "Average Range",
  "Median Range",
  "Average Standard Deviation",
  "Median Standard Deviation",
  "Average Variance",
  "Average Moving Range of Medians",
  "Median Moving Range of Medians",
  "Standard Deviation of Medians",
  "Known \U03c3"
)

choice_x_limits<-(1:4)
names(choice_x_limits)<-c(
  "Average Moving Range",
  "Median Moving Range",
  "Standard Deviation from k samples",
  "Known \U03c3"
)

choice_r_limits<-(1:6)#for limit calculations
names(choice_r_limits)<-c(
  "Average Range",
  "Median Range",
  "Average Standard Deviation",
  "Median Standard Deviation",
  "Average Variance",
  "Known \U03c3"
)

choice_r_limits2<-c(seq(1,9),12)#for spc charts
names(choice_r_limits2)<-c(
  "Average Range",
  "Median Range",
  "Average Standard Deviation",
  "Median Standard Deviation",
  "Average Variance",
  "Average MR of Range",
  "Median MR of Range",
  "Standard Deviation of Range",
  "Known \U03c3",
  # "Centerline Only",
  # "None",
  "Custom"
)

choice_x_centerline<-(1:2)
names(choice_x_centerline)<-c(
  "Mean",
  "Median"
)

choice_att_charts<-(1:4)
names(choice_att_charts)<-c(
  "p-chart",
  "np-chart",
  "c-chart",
  "u-chart"
)

choice_att_p_limits<-c(seq(1,5),8)
names(choice_att_p_limits)<-c(
  "Exact Poisson",
  "Normal Approximation",
  "Average MR",
  "Median MR",
  "Standard Deviation",
  # "Centerline Only",
  # "None",
  "Custom"
)

choice_att_b_limits<-c(seq(1,5),8)
names(choice_att_b_limits)<-c(
  "Exact Binomial",
  "Normal Approximation",
  "Average MR",
  "Median MR",
  "Standard Deviation",
  # "Centerline Only",
  # "None",
  "Custom"
)

####

beta_statement<-"Power to reject the null if the observed difference was real = "

######Save plot modules
downloadButtonUI <- function(id) {
  downloadButton(NS(id, "dl_plot"))
}
downloadSelectUI <- function(id) {
  pickerInput(NS(id, "format"), label = "Format: ", choices = c("eps","ps","tex","pdf","jpeg","tiff","png","bmp","svg","wmf"),selected = "svg",width = "75px")
}
downloadServer <- function(id, plot,height=NULL,width=NULL) {
  moduleServer(id, function(input, output, session) {
    output$dl_plot <- downloadHandler(
      filename = function() {
        file_format <- tolower(input$format)
        paste0(id, ".", file_format)
      },
      content = function(file) {
        ggsave(file, plot = plot(),height = height(), width=width(), units = "px",device = tolower(input$format))
      }
    )
  })
}


# Define UI
ui <- fluidPage(
  
  #css for side by side input####
  #  next two tags$head is for sliderInput
  tags$head(tags$style(HTML("div#inlin label { width: 15%; }
                               div#inlin input { display: inline-block; width: 85%;}"))),
  tags$head(
    tags$style(type="text/css", "#inlin label{ display: table-cell; text-align: left; vertical-align: middle; }
                                   #inlin .form-group { display: table-row;}")
  ),
  
  ### next two lines for class - use class attribute (.inline instead of #inline)
  tags$head(
    tags$style(type="text/css", ".inline label{ display: table-cell; text-align: left !important; vertical-align: middle; }
                                   .inline .form-group { display: table-row;}")
  ),
  ###
  
  #####CSS for tables
  tags$head(tags$style(HTML("
                            th,td {padding: 2px !important;
                                    min-width:60px;
                                    text-align: right} 
                                    th{border-bottom: 1px solid black;}
                            table {border-collapse: separate !important;}
                            
                            "))),#
  
  tags$div(HTML("<script type='text/x-mathjax-config' >
            MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$']]}
            });
            </script >
            ")),
  

      # Application title
    titlePanel(title=div(img(src="roi-stat.svg",width="40px"),"ROIstat v3.0"),windowTitle = "ROIstat"),
    
    #Menu Items
    navbarPage(title = "ROIstat",
               
               #Welcome Page####################################################
               
               tabPanel(title = "Welcome to ROIstat!",
                        
                        tags$img(src="roi-stat.svg",width="200px",style="float:left; margin:10px"),
                        h2("Welcome to ROIstat!"),
                        HTML("<a href='https://www.roi-ally.com'>The ROI Alliance</a> provides this friendly graphic front end to give access to the powerful statistical program R without having to know a line of code and with the assurance that the packages used work correctly. We hope this means that you can spend time learning when and how to use statistics rather than how to script in R. Don't let that stop you from learning R when you are ready!"),
                        br(),
                        br(),
                        HTML("ROIstat author Steve Ouellette has a Master's of Engineering, has been a Certified Management Consultant<sup>\U24C7</sup> and has been consulting since 1996. He has taught basic and advanced statistics and management principles at the University of Colorado Boulder."),br(),br(),
                        
                        HTML("<a href='https://six-sigma-online.com/'>Put your statistics to work with Six Sigma Black Belt training.</a>"),br(),
                        HTML("<a href='https://www.roi-ally.com/index.php/en/contact-us'>Contact us</a> for management or statistical training and consulting."),
                        HTML("<br><br>ROIstat is absolutely free, but if you want to buy us a beverage, <a href='https://www.roi-ally.com/index.php/en/services/how-we-can-help/roistat-software'>click the <b>Donate</b> button on the home page.</a> We appreciate it!"),
                        HTML("<a href='https://www.amazon.com/dp/B0CPNQ566Y'><img src='https://roi-ally.com/images/3d_ddl_cover_s.png' style='float:right'></a>"),
                        HTML("<a href='https://www.amazon.com/dp/B08T48JCZC'><img src='https://roi-ally.com/images/book_cover_perspective.png' style='float:right;height:126px'></a>"),
                        hr(),#style = "border-top: 1px solid #000000;"),
                        h3("ROIstat News"),
                        HTML("<a href='https://www.roi-ally.com/index.php/en/roistat-blog-feed'>Click here to see the current version of ROIstat!</a>"),
                        #HTML("<script language= 'JavaScript ' src= 'https://www.feedroll.com/rssviewer/feed2js.php?src=https%3A%2F%2Fwww.roi-ally.com%2Findex.php%2Fen%2Froistat-blog-feed%3Fformat%3Dfeed%26type%3Drss&num=2&targ=y&utf=y&pc=y&html=a '  charset= 'UTF-8 ' type= 'text/javascript '></script><noscript><a href= 'https://www.feedroll.com/rssviewer/feed2js.php?src=https%3A%2F%2Fwww.roi-ally.com%2Findex.php%2Fen%2Froistat-blog-feed%3Fformat%3Dfeed%26type%3Drss&num=2&targ=y&utf=y&pc=y&html=y '>View RSS feed</a></noscript>"),
                        #HTML("<script src='//rss.bloople.net/?url=https%3A%2F%2Froi-ally.com%2Findex.php%2Fen%2Froistat-blog-feed%3Fformat%3Dfeed%26type%3Drss&limit=1&showtitle=false&type=js'></script>"),
                        hr(),
                        h3("Blog/Podcast"),
                        HTML("<a href='https://www.roi-ally.com/index.php/en/hidden-blogs/blog'>Click here for the most recent blog/podcasts!</a>"),
                        #HTML('<script src="//rss.bloople.net/?url=https%3A%2F%2Froi-ally.com%2Findex.php%2Fen%2Fhidden-blogs%2Fblog%3Fformat%3Dfeed%26type%3Drss&limit=2&showtitle=false&type=js"></script>'),
  #                       tags$script(HTML('
  #   document.addEventListener("DOMContentLoaded", function() {
  #     var script = document.createElement("script");
  #     script.src = "https://rss.bloople.net/?url=https%3A%2F%2Froi-ally.com%2Findex.php%2Fen%2Froistat-blog-feed%3Fformat%3Dfeed%26type%3Drss&limit=1&showtitle=false&type=js";
  #     script.async = true;
  #     document.body.appendChild(script);
  #   });
  # ')),
  #                       tags$script(HTML('
  #   document.addEventListener("DOMContentLoaded", function() {
  #     var script = document.createElement("script");
  #     script.src = "https://rss.bloople.net/?url=https%3A%2F%2Froi-ally.com%2Findex.php%2Fen%2Fhidden-blogs%2Fblog%3Fformat%3Dfeed%26type%3Drss&limit=2&showtitle=false&type=js";
  #     script.async = true;
  #     document.body.appendChild(script);
  #   });
  # ')),
                        #HTML("<script language='JavaScript' src='https://feedroll.com/rssviewer/feed2js.php?src=https%3A%2F%2Fwww.roi-ally.com%2Findex.php%2Fen%2Fhidden-blogs%2Fblog%3Fformat%3Dfeed%26type%3Drss&num=1&utf=y&pc=y&html=a'  charset='UTF-8' type='text/javascript'></script>

# <noscript>
# <a href='https://feedroll.com/rssviewer/feed2js.php?src=https%3A%2F%2Fwww.roi-ally.com%2Findex.php%2Fen%2Fhidden-blogs%2Fblog%3Fformat%3Dfeed%26type%3Drss&num=3&utf=y&html=y'>View RSS feed</a>
# </noscript>
# "),
                        h3("Videos"),
                        HTML("<a href='https://www.roi-ally.com/index.php/en/blog'>Click here for the most recent videos!</a>"),
                        
                       br(),br(),
                        HTML("<a rel= 'license ' href= 'http://creativecommons.org/licenses/by-nd/4.0/ '><img alt= 'Creative Commons License ' style= 'border-width:0 ' src= 'https://i.creativecommons.org/l/by-nd/4.0/88x31.png ' /></a><br /><span xmlns:dct= 'http://purl.org/dc/terms/ ' property= 'dct:title '>ROIstat</span> by <a xmlns:cc= 'http://creativecommons.org/ns# ' href= 'http://roi-ally.com ' property= 'cc:attributionName ' rel= 'cc:attributionURL '>Steven M Ouellette</a> is licensed under a <a rel= 'license ' href= 'http://creativecommons.org/licenses/by-nd/4.0/ '>Creative Commons Attribution-NoDerivatives 4.0 International License</a>."),
                        HTML("</br><a href='https://www.roi-ally.com/index.php/en/hidden-blogs/roistat/roistat-credits'>Credits</a>")
                       ),
               #################################################################
               
    
               #Menu bar########################################################
               
               #File Menu#######################################################
               navbarMenu(title = "File",
                          tabPanel(title = "Import Data",
                                   
                                   h2("Import Data"),
                                   fluidPage(
                                     fluidRow(
                                       column(
                                         width = 4,
                                         checkboxGroupInput(
                                           inputId = "from",
                                           label = "Select where the data file is located then click \"Open Import Window\" below:",
                                           choices = choice_import,
                                           selected = c("file", "copypaste")
                                         ),
                                         actionButton("launch_modal", "Open import window"),p("Your original file is only accessed here. Nothing is changed in the original file.")
                                       ),
                                       column(
                                         width = 8,
                                         tags$b("Imported data:"),
                                         verbatimTextOutput(outputId = "name"),
                                         verbatimTextOutput(outputId = "data")
                                       )
                                     )
                                   )
                                   ),#end loadfile 2
                          # tabPanel(title = "Set Specs",
                          #          h2("Set Specifications"),
                          #          fluidPage(
                          #            column(width = 3,
                          #              #vector names
                          #              tags$div(id = 'names')
                          #            ),
                          #            column(width = 3,
                          #                   #LSLs
                          #                   tags$div(id = 'lsls')
                          #            ),
                          #            column(width = 3,
                          #                     #targets
                          #                   tags$div(id = 'targets')
                          #            ),
                          #            column(width = 3,
                          #                     #USLs
                          #                   tags$div(id = 'usls')
                          #            ),
                          #          )#end fluidpage
                          #          ),#end tabpanel set specs
                          tabPanel(title = "Select, Rename, and Convert Variables",
                                   tags$h3("Select, rename and convert variables"),
                                   fluidRow(
                                     column(
                                       width = 6,
                                       update_variables_ui("vars")
                                     ),
                                     column(
                                       width = 6,
                                       tags$b("Original data:"),
                                       verbatimTextOutput("original"),
                                       verbatimTextOutput("original_str"),
                                       tags$b("Modified data:"),
                                       verbatimTextOutput("modified"),
                                       verbatimTextOutput("modified_str")
                                     )
                                   )),
                          tabPanel(title = "Dynamically Filter Data",
                                   fluidRow(
                                     column(
                                       width = 3,
                                       filter_data_ui("filtering", max_height = "500px")
                                     ),
                                     column(
                                       width = 9,
                                       progressBar(
                                         id = "pbar", value = 100,
                                         total = 100, display_pct = TRUE
                                       ),
                                       DT::dataTableOutput(outputId = "table"),
                                       tags$b("Code dplyr:"),
                                       verbatimTextOutput(outputId = "code_dplyr"),
                                       tags$b("Expression:"),
                                       verbatimTextOutput(outputId = "code"),
                                       tags$b("Filtered data:"),
                                       verbatimTextOutput(outputId = "res_str")
                                     )
                                   )
                          ),
                          tabPanel("Current Working Data",
                                   DT::dataTableOutput(outputId = "w_data")
                          )
                          #tabPanel(title = "Save Working File")#end of save tabpanel
               ),#End of navbarmenu for file
               #################################################################
               
               #Edit Menu#######################################################
                navbarMenu(title = "Edit",
                           tabPanel(title = "Settings",
                                    h3("Settings"),
                                    selectInput(inputId = "color_pal",label = "Select a color palette",
                                                choices = c("R4",
                                                            "ggplot2",
                                                            "Accent",
                                                            "Okabe-Ito",
                                                            "Dark 2",
                                                            "Paired",
                                                            "Pastel 1",
                                                            "Pastel 2",
                                                            "Set 1",
                                                            "Set 2",
                                                            "Set 3",
                                                            "Tableau 10",
                                                            "Classic Tableau",
                                                            "Polychrome 36",
                                                            "Alphabet"),
                                                selected = pal_col
                                    ),
                                    HTML("From <a href='https://developer.r-project.org/Blog/public/2019/11/21/a-new-palette-for-r/'><b>A New palette() for R</b> (2019) by Achim Zeileis, Paul Murrell, Martin Maechler, Deepayan Sarkar:</a>  <ul>
<li><code> 'R4 '</code> is the new default palette (same as <code> 'default '</code>, starting from R version 4.0.0).</li>
<li><code> 'Okabe-Ito '</code> is a well-established palette introduced by
<a href= 'http://jfly.iam.u-tokyo.ac.jp/color/ '>Masataka Okabe &amp; Kei Ito</a> that is well-suited for
color vision deficiencies.</li>
<li><code> 'Accent '</code>, <code> 'Dark 2 '</code>, <code> 'Paired '</code>, <code> 'Pastel 1 '</code>, <code> 'Pastel 2 '</code>,
<code> 'Set 1 '</code>, <code> 'Set 2 '</code>, and <code> 'Set 3 '</code> are all palettes from the
popular <a href= 'http://ColorBrewer2.org/ '>ColorBrewer</a> color sets for cartography
(by Mark A. Harrower &amp; Cynthia A. Brewer).</li>
<li><code> 'ggplot2 '</code> is based on the default (hue-based) color scale introduced by Hadley Wickham
in <a href= 'https://CRAN.R-project.org/package=ggplot2 '>ggplot2</a>.</li>
<li><code> 'Tableau 10 '</code> and <code> 'Classic Tableau '</code> are default palettes (by Maureen Stone &amp; Cristy Miller)
from the popular <a href= 'https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782 '>Tableau</a> visualization software.</li>
<li><code> 'Polychrome 36 '</code> and <code> 'Alphabet '</code> are large sets of distinguishable
colors from the <a href= 'https://CRAN.R-project.org/package=Polychrome '>Polychrome</a> package
(by Kevin R. Coombes &amp; Guy Brock).</li>
</ul>"),
                           plotOutput("swatch")
                           )
                           ),#end of navbarmenu Edit
               #################################################################
               
               #Distributions Menu
               navbarMenu(title = "Distributions",
                          #Binomial#############################################
                          tabPanel(title = "Binomial",
                                   sidebarLayout(
                                       sidebarPanel(
                                           numericInput(
                                               inputId = "pi_bi",
                                               label = "\U03C0",
                                               value = .5,
                                               min = 0,
                                               max = 1,
                                               step =.1,
                                               width = "200px"
                                               ),
                                           numericInput(inputId = "n_bi",
                                                        label = "n",
                                                        value = 10,
                                                        min = 1,
                                                        max = ,
                                                        step = 1,
                                                        width = "100px"
                                                        ),
                                           prettySwitch(inputId = "r_bi",label = "Enter R of Interest?",value = F,status = "success",fill = T),
                                           conditionalPanel(condition = "input.r_bi==1",
                                             radioButtons(inputId = "one_or_two_bi",label = "One or Two Tails?",choices = c("One-Tail"=1,"Two-Tails"=2)),
                                             fluidRow(
                                               column(6,
                                                      uiOutput("ui_bi1")
                                                      ),
                                               column(6,
                                                      uiOutput("ui_bi3")
                                                      )
                                             ),
                                             fluidRow(
                                               column(6,
                                                      uiOutput("ui_bi2")
                                                      ),
                                               column(6,
                                                      uiOutput("ui_bi4")
                                                      )
                                             )
                                             # conditionalPanel(condition = "input.one_or_two_bi==2",
                                             #                  radioButtons(inputId = "in_or_out_bi",label = "Inside or Outside?",choices = c("Inside"=1,"Outside"=2))
                                             #                  )
                                           ),
                                           numericInput(inputId = "decimal_bi",
                                                        label = "Decimals",
                                                        value = 5,
                                                        min = 0,
                                                        max = 9,
                                                        step = 1,
                                                        width = "75px"
                                                        ),
                                           prettySwitch(inputId = "r_bi_table",label = "Show Table?",value = F,status = "success",fill = T)
                                           ),#end inputs
                                       #Show binomial outputs here
                                       mainPanel(
                                           plotOutput(outputId = "biplot",height = "300px"),
                                           fluidRow(
                                             column(3,
                                                    downloadButtonUI('biplot')),
                                             column(6,
                                                    tags$div(id='inline1', class='inline',downloadSelectUI('biplot')
                                                    )
                                             )
                                           ),
                                           htmlOutput("bi_tails"),
                                           dataTableOutput(outputId = "bi_table")
                                       )#end binomial output main panel
                                   )#end sidebar layout
                          ),#end binomial tabpanel
                          ######################################################
                          
                          #Hypergeometric#############################################
                          tabPanel(title = "Hypergeometric",
                                   sidebarLayout(
                                     sidebarPanel(
                                       numericInput(
                                         inputId = "pi_hype",
                                         label = "\U03C0",
                                         value = .05,
                                         min = 0,
                                         max = 1,
                                         step =.1,
                                         width = "200px"
                                       ),
                                       numericInput(inputId = "k_hype",
                                                    label = "Sample Size (k)",
                                                    value = 30,
                                                    min = 1,
                                                    max = ,
                                                    step = 1,
                                                    width = "100px"
                                       ),
                                       numericInput(inputId = "N_hype",
                                                    label = "Total population (N)",
                                                    value = 200,
                                                    min = 1,
                                                    max = ,
                                                    step = 1,
                                                    width = "100px"
                                       ),
                                       prettySwitch(inputId = "x_hype",label = "Enter X of Interest?",value = F,status = "success",fill = T),
                                       conditionalPanel(condition = "input.x_hype==1",
                                                        radioButtons(inputId = "one_or_two_hype",label = "One or Two Tails?",choices = c("One-Tail"=1,"Two-Tails"=2)),
                                                        fluidRow(
                                                          column(6,
                                                                 uiOutput("ui_hype1")
                                                          ),
                                                          column(6,
                                                                 uiOutput("ui_hype3")
                                                          )
                                                        ),
                                                        fluidRow(
                                                          column(6,
                                                                 uiOutput("ui_hype2")
                                                          ),
                                                          column(6,
                                                                 uiOutput("ui_hype4")
                                                          )
                                                        )
                                       ),
                                       numericInput(inputId = "decimal_hype",
                                                    label = "Decimals",
                                                    value = 5,
                                                    min = 0,
                                                    max = 9,
                                                    step = 1,
                                                    width = "75px"
                                       ),
                                       prettySwitch(inputId = "hype_table_show",label = "Show Table?",value = F,status = "success",fill = T)
                                     ),#end inputs
                                     #Show binomial outputs here
                                     mainPanel(
                                       plotOutput(outputId = "hypeplot",height = "300px"),
                                       fluidRow(
                                         column(3,
                                                downloadButtonUI('hypeplot')),
                                         column(6,
                                                tags$div(id='inline1', class='inline',downloadSelectUI('hypeplot')
                                                )
                                         )
                                       ),
                                       htmlOutput("hype_tails"),
                                       dataTableOutput(outputId = "hype_table")
                                     )#end binomial output main panel
                                   )#end sidebar layout
                          ),#end hyper tabpanel
                          ######################################################
                          
                          #Geometric#############################################
                          tabPanel(title = "Geometric",
                                   sidebarLayout(
                                     sidebarPanel(
                                       numericInput(
                                         inputId = "pi_geom",
                                         label = "\U03C0",
                                         value = .05,
                                         min = 0,
                                         max = 1,
                                         step =.1,
                                         width = "200px"
                                       ),
                                       
                                       numericInput(inputId = "xmax_geom",
                                                    label = "Max X to display",
                                                    value = 20,
                                                    min = 1,
                                                    max = ,
                                                    step = 1,
                                                    width = "100px"
                                       ),
                                       uiOutput("ui_geom3"),
                                       prettySwitch(inputId = "x_geom",label = "Enter X of Interest?",value = F,status = "success",fill = T),
                                       conditionalPanel(condition = "input.x_geom==1",
                                                        #radioButtons(inputId = "one_or_two_geom",label = "One or Two Tails?",choices = c("One-Tail"=1,"Two-Tails"=2)),
                                                        fluidRow(
                                                                 uiOutput("ui_geom1")
                                                        ),
                                                        # fluidRow(
                                                        #   column(6,
                                                        #          uiOutput("ui_geom2")
                                                        #   ),
                                                        #   column(6,
                                                        #          uiOutput("ui_geom4")
                                                        #   )
                                                        # )
                                       ),
                                       numericInput(inputId = "decimal_geom",
                                                    label = "Decimals",
                                                    value = 5,
                                                    min = 0,
                                                    max = 9,
                                                    step = 1,
                                                    width = "75px"
                                       ),
                                       prettySwitch(inputId = "geom_table_show",label = "Show Table?",value = F,status = "success",fill = T)
                                     ),#end inputs
                                     #Show binomial outputs here
                                     mainPanel(
                                       plotOutput(outputId = "geomplot",height = "300px"),
                                       fluidRow(
                                         column(3,
                                                downloadButtonUI('geomplot')),
                                         column(6,
                                                tags$div(id='inline1', class='inline',downloadSelectUI('geomplot')
                                                )
                                         )
                                       ),
                                       htmlOutput("geom_tails"),
                                       dataTableOutput(outputId = "geom_table")
                                     )#end binomial output main panel
                                   )#end sidebar layout
                          ),#end geom tabpanel
                          ######################################################
                          
                          #Poisson##############################################
                          tabPanel(title = "Poisson",
                                   sidebarLayout(
                                       sidebarPanel(
                                           numericInput(
                                               inputId = "lambda_po",
                                               label = "\U03BB",
                                               value = 5,
                                               min = 0,
                                               max = ,
                                               step =1,
                                               width = "200px"
                                               ),
                                           prettySwitch(inputId = "r_po",label = "Enter X of Interest?",value = F,status = "success",fill = T),
                                           conditionalPanel(condition = "input.r_po==1",
                                                            radioButtons(inputId = "one_or_two_po",label = "One or Two Tails?",choices = c("One-Tail"=1,"Two-Tails"=2)),
                                                            fluidRow(
                                                              column(6,
                                                                     uiOutput("ui_po1")
                                                                     ),
                                                              column(6,
                                                                     uiOutput("ui_po3")
                                                                     )
                                                            ),
                                                            fluidRow(
                                                              column(6,
                                                                     uiOutput("ui_po2")
                                                              ),
                                                              column(6,
                                                                     uiOutput("ui_po4")
                                                              )
                                                            )
                                           ),
                                           numericInput(inputId = "decimal_po",
                                                        label = "Decimals",
                                                        value = 5,
                                                        min = 0,
                                                        max = 9,
                                                        step = 1,
                                                        width = "75px"
                                           ),
                                           prettySwitch(inputId = "r_po_table",label = "Show Table?",value = F,status = "success",fill = T)
                                           ),#end inputs
                                       #Show binomial outputs here
                                       mainPanel(
                                           plotOutput("poisplot",height = "300px"),
                                           fluidRow(
                                             column(3,
                                                    downloadButtonUI('poisplot')),
                                             column(6,
                                                    tags$div(id='inline1', class='inline',downloadSelectUI('poisplot')
                                                    )
                                             )
                                           ),
                                           htmlOutput("po_tails"),
                                           dataTableOutput(outputId = "pois_table")
                                           )#end Poisson output main panel
                                       )#end Poisson sidebarlayout
                                   ),#end Poisson tabpanel
                          ######################################################
                          
                          #Normal###############################################
                          tabPanel(title = "Normal",
                                   sidebarLayout(
                                       sidebarPanel(
                                           numericInput(inputId = "mu_norm",label = "\U1D707",
                                                        value = 10,
                                                        width = "100px"),
                                           numericInput(inputId = "sigma_norm",
                                                        label = "\U03C3",
                                                        value = 1,
                                                        width = "100px"),
                                           radioButtons(inputId = "tails_norm",
                                                        label = "One or Two Tails?",
                                                        choices = c("One-Tail"=1,"Two-Tails"=2)),
                                           uiOutput("lowertail_norm"),
                                           uiOutput("uppertail_norm"),
                                           uiOutput("inorout_norm"),
                                           checkboxInput(inputId = "data_label_norm",
                                                         label = "Label Graph?",
                                                         value = T),
                                           numericInput(inputId = "decimal_norm",
                                                        label = "Decimals",
                                                        value = 4,
                                                        min = 0,
                                                        max = 9,
                                                        step = 1,
                                                        width = "75px"
                                                        )
                                           ),#end Normal tabpanel
                                       #Show normal outputs here
                                       mainPanel(
                                           plotOutput("normplot",height = "300px"),
                                           fluidRow(
                                             column(3, downloadButtonUI("normplot")),
                                             column(3,
                                                    tags$div(id="inline1", class="inline",
                                                             downloadSelectUI("normplot")
                                                    )
                                             )
                                           ),
                                           div(DT::dataTableOutput(outputId = "norm_table"),style="margin:auto; width: 50%")
                                           )#end main panel
                                       )#end sidebarlayout for normal
                                   ),#end Normal panel
                          ######################################################
                          
                          #Exponential##########################################
                          tabPanel(title = "Exponential",
                                   sidebarLayout(
                                       sidebarPanel(
                                           numericInput(inputId = "mu_exp",label = "\U1D707",
                                                        value = 100,
                                                        width = "100px"),
                                           numericInput(inputId = "X_min_exp",
                                                        label = "Xmin",
                                                        value = 0,
                                                        width = "100px"),
                                           # numericInput(inputId = "tail_exp",
                                           #              label = "Point of Interest",
                                           #              value = 10,
                                           #              width = "100px"),
                                           radioButtons(inputId = "tails_exp",
                                                        label = "One or Two Tails?",
                                                        choices = c("One-Tail"=1,"Two-Tails"=2)),
                                           uiOutput("ui_exp1"),
                                           uiOutput("ui_exp2"),
                                           uiOutput("ui_exp3"),
                                           numericInput(inputId = "decimal_exp",
                                                        label = "Decimals",
                                                        value = 4,
                                                        min = 0,
                                                        max = 9,
                                                        step = 1,
                                                        width = "75px")
                                       ),#end sidebarpanel
                                       mainPanel(
                                           plotOutput(outputId = "expplot",height = "300px"),
                                           fluidRow(
                                             column(3,
                                                    downloadButtonUI('expplot')),
                                             column(6,
                                                    tags$div(id='inline1', class='inline',downloadSelectUI('expplot')
                                                    )
                                             )
                                           ),
                                           div(dataTableOutput(outputId = "exp_table"),style="margin:auto; width: 50%")
                                       )
                                   )#end layout
                          ),#end exponential tabpanel
                          ######################################################
                          
                          #F-distribution######################################
                          tabPanel(title = "F distribution",
                                   sidebarLayout(
                                       sidebarPanel(
                                           numericInput(inputId = "df1_f",label = "df1",
                                                        value = 5,
                                                        width = "100px"),
                                           numericInput(inputId = "df2_f",
                                                        label = "df2",
                                                        value = 10,
                                                        width = "100px"),
                                           radioButtons(inputId = "tails_f",
                                                        label = "One or Two Tails?",
                                                        choices = c("One-Tail"=1,"Two-Tails"=2)),
                                           # conditionalPanel(condition = "input.tails_f==1",
                                           #                  numericInput(inputId = "tail_f",
                                           #                               label = "Point of Interest",
                                           #                               value = 2,
                                           #                               width = "100px")
                                           # ),#end conditional
                                           # conditionalPanel(condition = "input.tails_f==2",
                                           #                  numericInput(inputId = "tail1_f",
                                           #                               label = "Lower Tail",
                                           #                               value = .5,
                                           #                               width = "100px"),
                                           #                  numericInput(inputId = "tail2_f",
                                           #                               label = "Upper Tail",
                                           #                               value = 4,
                                           #                               width = "100px")
                                           # ),#end conditional
                                           uiOutput("lowertail_f"),
                                           uiOutput("uppertail_f"),
                                           uiOutput("inorout_f"),
                                           checkboxInput(inputId = "data_label_f",
                                                         label = "Label Graph?",
                                                         value = T),
                                           numericInput(inputId = "decimal_f",
                                                        label = "Decimals",
                                                        value = 4,
                                                        min = 0,
                                                        max = 9,
                                                        step = 1,
                                                        width = "75px"
                                           )),#end F tabpanel
                                       #Show F outputs here
                                       mainPanel(
                                           plotOutput("fplot",height = "300px"),
                                           fluidRow(
                                             column(3, downloadButtonUI("fplot")),
                                             column(3,
                                                    tags$div(id="inline1", class="inline",
                                                             downloadSelectUI("fplot")
                                                    )
                                             )
                                           ),
                                           div(dataTableOutput(outputId = "f_table"),style="margin:auto; width: 50%")
                                           )#end F main panel
                                       )
                                   ),#end F tabpanel
                          ######################################################
               
                          #Critical Values######################################
                          tabPanel(title = "Critical Values",
                                     fluidPage(
                                       uiOutput("crit_label"),
                                       sidebarLayout(
                                         sidebarPanel(
                                           radioButtons(inputId = "crit_select",label = "Select the statistic:",choices = choice_crit),
                                           radioButtons(inputId = "stat_or_val",label = "Want",choices = c("p-value"=1,"Score"=2)),
                                           radioButtons(inputId = "tails_crit",label = "Tails",choices = c("Two"=1,"Lower"=2,"Upper"=3)),
                                           numericInput(inputId = "crit_value",label = "Enter Value",value = 2,width = "150px"),
                                           conditionalPanel(condition = "input.crit_select>1",
                                                            numericInput(inputId = "df1_crit",label = "df1",value = 5,width = "150px",min = 0)
                                                            ),
                                           conditionalPanel(condition = "input.crit_select==4",
                                                            numericInput(inputId = "df2_crit",label = "df2",value = 10,width = "150px",min = 0)
                                           ),
                                           numericInput(inputId = "decimals_crit",label = "Decimals",value = 5,min = 0,step = 1,width = "75px")
                                           ),
                                       
                                       mainPanel(
                                         plotOutput(outputId = "critplot",height = "300px"),
                                         fluidRow(
                                           column(3, downloadButtonUI("critplot")),
                                           column(3,
                                                  tags$div(id="inline1", class="inline",
                                                           downloadSelectUI("critplot")
                                                  )
                                           )
                                         ),
                                         
                                         textOutput(outputId = "crit_text")
                                         )
                                       )
                                     )
                                     ),#end critical values
                          ######################################################
                          
                          #Distribution testing#################################
                          tabPanel("Testing",
                                   fluidPage(
                                     sidebarLayout(
                                       sidebarPanel(
                                         radioButtons(inputId = "dist_test_type",label = "Test Distribution",choices = c("Poisson"=1,"Normal"=2,"Exponential"=3)),
                                         uiOutput(outputId = "dist_test_subtypes"),
                                         conditionalPanel(condition = "input.dist_test_type_result==8",
                                           checkboxInput(inputId = "dist_test_zero",label = "Set origin to Xmin?")
                                         ),
                                         radioButtons(inputId = "dist_test_data_type",label = "Select Data Type",choices = c("Analyze Columns"=1,"Analyze by Factors"=2)),
                                         uiOutput("dist_test_UI1"),
                                         uiOutput("dist_test_UI2"),
                                         fluidRow(
                                           column(6,
                                                  numericInput(inputId = "dist_test_conf",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px")
                                                  ),
                                           column(6,
                                                  numericInput(inputId = "dist_test_decimals",label = "Decimals",value = 3,min = 1,max = 9,step = 1,width = "75px")
                                           )
                                         ),
                                         checkboxInput(inputId = "dist_test_info",label = "Information on selected test?")
                                       ),#end sidebarpanel
                                       mainPanel(
                                         conditionalPanel(condition = "input.dist_test_type_result==6 || input.dist_test_type_result==7",
                                                          fluidRow(
                                                            column(3),
                                                            column(6,
                                                                   actionBttn(inputId = "dist_test_mvp_go",label = "Start Simulation",icon = icon("traffic-light"),style = "material-flat",color = "success")
                                                                   ),
                                                            column(3,
                                                                   #actionBttn(inputId = "dist_test_mvp_stop",label = "Stop",icon = icon("traffic-light-stop"),style = "material-flat",color = "danger")
                                                            )
                                                          ),
                                                          progressBar(id = "mvp_exp_prog",value = 0,display_pct = TRUE,striped = TRUE,title = "Simulation Progress")
                                                          ),
                                         uiOutput("dist_test_plot_select_b"),
                                         plotOutput("disttestplotout",height='400px'),
                                         fluidRow(
                                           column(3,
                                                  downloadButtonUI('disttestplotout')
                                                  ),
                                                  column(6,
                                                         tags$div(id='inline1', class='inline',downloadSelectUI('disttestplotout')
                                                                  )
                                                         )
                                         ),
                                         htmlOutput("dist_test_out")
                                       )#end main
                                     )#end sidebarlayout
                                   )#end page
                                   )#end testing tab panel
               
               ),#end distributions menu
               #################################################################
               
               
               #Sample Size##################################
               tabPanel(title = "Sample Size/Power",
                        
                                 sidebarLayout(
                                   sidebarPanel(
                                     radioButtons(inputId = "sample_size_type",label = "Calculate the sample size or power for:",choices = c("Means"=1,"Variances"=2,"Proportions (binomial)"=3,"Rates (Poisson)"=4,"ANOVA"=5,"Correlations"=6)),
                                     uiOutput("s_size_tests")
                                   ),#end sidebarpanel
                                   mainPanel(
                                    fluidRow(
                                      conditionalPanel(condition = "input.sample_size_type!=5",
                                                       selectInput(inputId = "one_or_two_size",label = "Alternative is:",choices = c("Equal to the null"="two.sided","Less Than the null"="less", "Greater Than the null"="greater"),width = "150px",selected = 2)
                                                       ),
                                      checkboxInput(inputId = "power_s",label = "Power",value = F)
                                      ),
                                     tags$div(id="inline1", class="inline",
                                              fluidRow(column(3,numericInput(inputId = "s_size_alpha",label = withMathJax("$$\\alpha:{ }$$"),value = .05,min = 0,max = 1,step = .05,width = "150px"))),
                                              fluidRow(column(3,
                                                              conditionalPanel(condition = "input.power_s==0",
                                                                               numericInput(inputId = "s_size_beta",label = withMathJax("$$\\beta:{ }$$"),value = .1,min = 0,max = 1,step = .05,width = "150px")),
                                                              conditionalPanel(condition = "input.power_s==1",
                                                                                 numericInput(inputId = "s_size_n",label = withMathJax("$$n:{ }$$"),value = 10,min = 0,step = 1,width = "150px")
                                                                               )
                                                              ),
                                                              column(3,uiOutput("s_sizeUI3"))
                                                       ),
                                              fluidRow(column(3,uiOutput("s_sizeUI1")),column(3,uiOutput("s_sizeUI4"))),
                                              fluidRow(column(3,uiOutput("s_sizeUI2")))
                                              
                                              ),
                                    #verbatimTextOutput("s_size_output"),
                                    htmlOutput("pretty_ssize")
                                   )
                                 )#end sidebarLayout
                                 ),#end sample size
                        
               
               #################################################################
               
               #Exploratory Data Analysis#######################################
               tabPanel(title = "EDA",
                        tabsetPanel(id = "eda_panel",
                            tabPanel(title = "Data Setup", value = "eda_data_setup",
                                     sidebarLayout(
                                         sidebarPanel(
                                             radioButtons(inputId = "eda_data_type",
                                                          label = "Select Data Type",
                                                          choices = c("Analyze columns"=1,
                                                                      "Analyze by factors"=2)),
                                             uiOutput("eda_UI1"),#choice_column
                                             uiOutput("eda_UI2")
                                             
                                             ),
                                         mainPanel(
                                           #show selected data
                                           h2("Sample of Selected Data"),
                                           dataTableOutput(outputId = "eda_selected_data")
                                             
                                         )#end mainpanel for CD
                                     )#end of sidebar layout
                            ),#end of tabPanel for CD
                            
                            tabPanel("Descriptives",
                                     h3("Descriptive Statistics"),
                                     sidebarPanel(
                                       numericInput(inputId = "decimals_desc2",label = "Decimals",value = 5,min = 0,step = 1,width = "75px"),
                                       uiOutput("desc_data_list"),
                                       pickerInput(inputId = "desc_stats",label = "Select Statistics",
                                                   choices = list(
                                         File_Info = c(
                                           "Total Sample Size"="stat.total.n=T",
                                           "Missing"="stat.miss=T",
                                           "Sum"="stat.sum=T",
                                           "Distinct Values, no NA"="stat.distinct=T",
                                           "Distinct Values with NA"="stat.distinct.withna=T"),
                                         
                                         Measures_of_Location = c(
                                           "Mean"="stat.mean=T",
                                           "Median"="stat.median=T",
                                           "True Mode"="stat.true.mode=T"),
                                         
                                         Measures_of_Spread =c(
                                           "Variance"="stat.var=T",
                                           "Standard Deviation"="stat.sd=T",
                                           "Range"="stat.range=T",
                                           "Coefficient of Variation"="stat.coefvar=T",
                                           "Mean ADA"="stat.mean.ADA=T",
                                           "Mean ADM"="stat.mean.ADM=T",
                                           "Mean ADM(n-1)"="stat.mean.ADMn1=T",
                                           "Inter-Quartile Range"="stat.iqr=T",
                                           "Semi-Interquartile Range"="stat.sir=T",
                                           "Pseudo Standard Deviation"="stat.psd=T"),
                                         
                                         Measure_of_Shape =c("Skewness"="stat.skew.test=T",
                                                             "Kurtosis"="stat.kurt.test=T"),
                                         
                                         Measures_of_Position =c(
                                           "Minimum"="stat.min=T",
                                           "First Quartile"="stat.q1=T",
                                           "Second Quartile"="stat.quantile=.5",
                                           "Third Quartile"="stat.q3=T",
                                           "Maximum"="stat.max=T")
                                       ),
                                       multiple = T,
                                       options=list('actions-box'=T),selected = c("stat.mean=T","stat.sd=T","stat.min=T","stat.max=T","stat.range=T"))),
                                                     
                                       mainPanel(
                                         DTOutput("desc_out"),
                                         HTML("<br><br>Quantiles are calculated using Type 6 <a href='https://www.rdocumentation.org/packages/stats/versions/3.4.3/topics/quantile'>Learn more here.</a>")
                                       )
                                     #)#end sidebarpanel
                                     ),#end tab panel for descriptives
                            tabPanel("Normality Tests",
                                     
                                     h3("Normality Tests"),
                                     sidebarLayout(
                                       sidebarPanel(
                                         numericInput(inputId = "conf_eda",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px"),
                                         numericInput(inputId = "decimals_desc",label = "Decimals",value = 5,min = 0,step = 1,width = "75px"),
                                         prettySwitch(inputId = "auto_norm",label = "Auto Select Normality Test?",value = T,status = "success",fill = T),
                                         conditionalPanel(condition = "input.auto_norm == 0",
                                                          checkboxGroupButtons(inputId = "norm_test",label = "Select Tests",choices = c(
                                                            "Anderson-Darling (n < 25)"="stat.ad.test=2",
                                                            "Shapiro-Wilk (n < 25)"="stat.sw.test=2",
                                                            "Skewness and Kurtosis (n > 25)"="stat.skew.test=2, stat.kurt.test=2"
                                                          ),justified = T,direction = "vertical"
                                                          )
                                                          ),
                                         uiOutput("eda_data_list")
                                       ),
                                       mainPanel(
                                         fluidRow(
                                           conditionalPanel(condition = "input.eda_data_type==2",
                                                            uiOutput("sel_data_name")),
                                           DTOutput("eda_desc_out")
                                         )
                                       )
                                     )
                            ),
                            tabPanel("Boxplots",
                                     h3("Boxplots"),
                                     sidebarLayout(
                                       sidebarPanel(
                                         checkboxInput(inputId = "box_violin",label = "Violin Plot?",value = FALSE),
                                         conditionalPanel(condition = "input.box_violin == 0",
                                                          checkboxInput(inputId = "notch_box",label = "Use notch?",value = F)
                                                          ),
                                         uiOutput("box_data_list")
                                         ),
                                     mainPanel(
                                       #plotOutput(outputId = "eda.box"),
                                       tags$div(id="inline1", class="inline",noUiSliderInput(inputId = "box_width",label = "Width",min = 200,max = 1600,inline = TRUE,width = "300px",value = 400,step = 100,format=wNumbFormat(decimals=0,suffix="px"))),
                                       fluidRow(
                                         column(1,
                                                noUiSliderInput(inputId = "box_height",label = "Height",min = 200,max = 1600,value = 400,step = 100,orientation = "vertical",width="100px",height="300px",format=wNumbFormat(decimals=0,suffix="px"))
                                                ),
                                         column(11,
                                                plotOutput("box_plot",width="auto",height="auto")
                                                )
                                       ),
                                       fluidRow(
                                         column(3,
                                                dropdown(
                                                  tags$h4("Chart Options"),
                                                  textInput(inputId = "box_title",label = "Chart Title",value = NA),
                                                  textInput(inputId = "box_x_lab",label = "X-axis Label",value = NA),
                                                  textInput(inputId = "box_y_lab",label = "Y-axis Label",value = NA),
                                                  checkboxInput(inputId = "box_big",label="Larger font?",value = FALSE),
                                                  circle=TRUE,
                                                  status = "success",
                                                  icon = icon("gear"),
                                                  width = "300px",
                                                  tooltip = tooltipOptions(title="Click to modify chart")
                                                ),#end of dropdown
                                                ),
                                         column(3, downloadButtonUI("boxplot")),
                                         column(3,
                                                tags$div(id="inline1", class="inline",
                                                         downloadSelectUI("boxplot")
                                                )
                                         )
                                       ),
                                       )
                                     )
                                     ),
                            tabPanel("Histograms",
                                     h4("Histograms"),
                                     sidebarLayout(
                                       sidebarPanel(
                                         h4("Histogram Options"),
                                         uiOutput("hist_data_list"),#make conditional? no this is OK, but for reference type will need radio buttons                 
                                         uiOutput("hist_indep_list"),#list out the combinations of the independent variables for factor data type
                                         # conditionalPanel(condition = "input.eda_data_type==1", #column type data
                                         uiOutput('mult_data'),#if there are multiple data sets, should we put them on same axis
                                         # ),
                                         radioButtons(inputId = "hist_type",label = "Plot Style:",choices = c("Histogram"=1,"Frequency Polygon"=2,"Kernel Density (bw='sj')"=3)),
                                         tags$hr(style="border-color: black;"),
                                         tags$p(style="font-weight:700;","Chart Modifications:"),
                                         #checkboxInput(inputId = "hist_axis",label = "Common Axis?",value = F), ###|| input.eda_data_type == 2",
                                         checkboxInput(inputId = "norm_curve",label = "Normal Curve?",value = F),
                                         checkboxInput(inputId = "hist_specs",label = "Draw specs?",value = F),
                                         conditionalPanel(condition = "input.hist_specs==1",
                                                          tags$div(id="inline1", class="inline",numericInput(inputId = "hist_LSL",label = "LSL",value = NA,width = "75px")),
                                                          tags$div(id="inline1", class="inline",numericInput(inputId = "hist_target",label = "Target",value = NA,width = "75px")),
                                                          tags$div(id="inline1", class="inline",numericInput(inputId = "hist_USL",label = "USL",value = NA,width = "75px"))
                                                          ),
                                         conditionalPanel(condition = "input.hist_type != 3",# && input.norm_curve !=1
                                                          fluidRow(
                                                            column(5,
                                                                   numericInput(inputId = "hist_bin_w",label = "Bin Width",min = 1,value = NULL,width="75px")
                                                                   ),
                                                            column(2,
                                                                   br(),
                                                                   p(style="text-align: center; font-weight: bold;","OR")
                                                                   ),
                                                            column (5,
                                                                    numericInput(inputId = "hist_bins",label = "# of Bins",min = 1,value = NULL,width="75px")
                                                                    )
                                                          ),
                                                          conditionalPanel(condition = "input.hist_bin_w > 0 & input.hist_bins > 0",
                                                                           p(style="text-align: center; color: red;","Bin width overrides selecting the number of bins.")
                                                                           ),
                                                          numericInput(inputId = "hist_center",label = "Center of a Bin",min = 0,value = NULL,width = "150px")
                                         ),
                                         conditionalPanel(condition="input.hist_type==3",
                                                          checkboxInput(inputId="hist_extend_d",label="Extend Density?",value=FALSE),
                                                          checkboxInput(inputId = "hist_rug",label = "Add Rug Plot?",value = TRUE)
                                                          )
                                       ),
                                       mainPanel(
                                         tags$div(id="inline1", class="inline",noUiSliderInput(inputId = "hist_width",label = "Width",min = 200,max = 1600,inline = TRUE,width = "300px",value = 400,step = 100,format=wNumbFormat(decimals=0,suffix="px"))),
                                         fluidRow(
                                           column(1,
                                                  noUiSliderInput(inputId = "hist_height",label = "Height",min = 200,max = 1600,value = 400,step = 100,orientation = "vertical",width="100px",height="300px",format=wNumbFormat(decimals=0,suffix="px"))
                                                  ),
                                           column(11,
                                                  plotOutput("histo_plot",width="auto",height="auto")
                                                  )
                                           
                                         ),
                                         fluidRow(
                                           column(3,
                                                  dropdown(
                                                    tags$h4("Chart Options"),
                                                    textInput(inputId = "hist_title",label = "Chart Title",value = NA),
                                                    textInput(inputId = "hist_x_lab",label = "X-axis Label",value = NA),
                                                    #textInput(inputId = "hist_y_lab",label = "Y-axis Label",value = NA),
                                                    checkboxInput(inputId = "hist_big",label="Larger font?",value = FALSE),
                                                    circle=TRUE,
                                                    status = "success",
                                                    icon = icon("gear"),
                                                    width = "300px",
                                                    tooltip = tooltipOptions(title="Click to modify chart")
                                                  )),#end of dropdown
                                           column(3, downloadButtonUI("histoplot")),
                                           column(3,
                                                  tags$div(id="inline1", class="inline",
                                                           downloadSelectUI("histoplot")
                                                  )
                                           )
                                         ),
                                         fluidRow(
                                         ),
                                         br(),
                                         conditionalPanel(condition = "input.hist_type != 3",
                                           materialSwitch(inputId = "hist_freq_dist",label = "Show frequency distribution?",value = FALSE,status = "success")
                                         ),
                                         
                                         # conditionalPanel(condition = "input.mult_data_choice==1",
                                         #                  p("WARNING: Displaying multiple distributions on the same axis can lead to strange results if the distributions are quite different from each other.",style="color:red")
                                         #                  ),
                                         conditionalPanel(condition = "input.hist_freq_dist == 1",
                                                          numericInput(inputId = "freq_dist_dec",label = "Decimals",value = 5,min = 0,max = 9,step = 1,width = "75px"),
                                                          uiOutput("hist_panel_select"),
                                                          DTOutput("freq_dist")
                                                          )
                                         
                                         )#end mainpanel
                                     )#end sidebarlayout
                                     ),#end histograms
                            tabPanel("Quantiles",
                                     h4("Quantiles"),
                                     sidebarLayout(
                                       sidebarPanel(
                                         numericInput(inputId = "decimals_quant",label = "Decimals",value = 5,min = 0,step = 1,width = "75px"),
                                         uiOutput("quant_data_list")
                                         
                                       ),#end sideparpanel
                                       mainPanel(
                                         radioGroupButtons(inputId = "quant_sel",label = "Select quantile",choices = c(
                                           "4 - Quartiles"=4,
                                           "10 - Deciles"=10,
                                           "20 - Ventiles"=20,
                                           "100 - Percentiles"=100,
                                           "Custom"=1)
                                           ),
                                         conditionalPanel(condition = "input.quant_sel==1",
                                                          numericInput(inputId = "quant_cust",label = "Enter the number of divisions",value = 4,min = 0,max = 1,step = 1)),
                                         DTOutput("quant_out"),
                                         HTML("<br><br>Quantiles are calculated using Type 6 <a href='https://www.rdocumentation.org/packages/stats/versions/3.4.3/topics/quantile'>Learn more here.</a>")
                                       )#end main panel
                                     )#end sidebarlayout
                                     ),#end quantiles
                            tabPanel("Conf. Int.",
                                     
                                                h4("Confidence Intervals"),
                                                   sidebarLayout(
                                                     sidebarPanel(
                                                       numericInput(inputId = "conf_ci",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px"),
                                                       numericInput(inputId = "decimals_ci",label = "Decimals",value = 5,min = 0,step = 1,width = "75px"),
                                                       uiOutput("ci_data_list")
                                                       ),#end sidebarpanel
                                                     mainPanel(
                                                       h4("Confidence Intervals (assuming normality, based on t)"),
                                                       DTOutput("ci_out")
                                                       )#end mainpanel
                                                     )#end sidebarlayout
                                                   
                                     ),#end confidence interval UI tabpanel
                            tabPanel("Nat. Tol.",
                                     h4("Natural Tolerance"),
                                     tabsetPanel(
                                       tabPanel("Use Data",
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    #numericInput(inputId = "conf_nt_data",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px"),
                                                    numericInput(inputId = "decimals_nt_data",label = "Decimals",value = 4,min = 0,step = 1,width = "75px"),
                                                    pickerInput(inputId = "dist_nt_data",label = "Select a Distribution",choices = choice_nt_dat),
                                                    uiOutput("nt_UI1_data"),
                                                    uiOutput("nt_UI2_data"),
                                                    uiOutput("nt_data_list")
                                                  ),#end sideparpanel
                                                  mainPanel(
                                                    h4("Natural Tolerance"),
                                                    DTOutput("nt_out_data")
                                                  )#end main panel
                                                  
                                                )#end sidebarlayout
                                                ),
                                       tabPanel("Enter Statistics",
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    #numericInput(inputId = "conf_nt",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px"),
                                                    numericInput(inputId = "decimals_nt",label = "Decimals",value = 4,min = 0,step = 1,width = "75px"),
                                                    pickerInput(inputId = "dist_nt",label = "Select a Distribution",choices = choice_nt),
                                                    uiOutput("nt_UI1"),
                                                    uiOutput("nt_UI2")
                                                  ),#end sideparpanel
                                                  mainPanel(
                                                    DTOutput("nt_out_simple")
                                                  )#end main panel
                                                  
                                                )#end sidebarlayout
                                       )#end tabpanel
                                     )#end tabset panel
                                     )#end nat tol tab panel
                            
                            # tabPanel("Distribution Tests and Capability",
                            #          sidebarLayout(
                            #            sidebarPanel(
                            #              uiOutput("eda_UI3"),#move this to dist tab
                            #            ),
                            #            mainPanel()
                            #          )
                            #          )
                        )#end of tabset EDA
               ),#Exploratory Data Analysis
               #################################################################
               
               #One- and Two-Sample tests#######################################
               navbarMenu(title = "One- and Two-Sample Tests",
                          tabPanel(title = "Test Reference",#raw HTML reference for selecting tests########
                                   HTML("<style>th, td{padding:10px;}</style><table>
<tbody>
<tr>
<td>&nbsp;</td>
<td colspan= '2 ' rowspan= '2 ' style= 'text-align: center; '><strong>One-Sample Statistics</strong></td>
<td colspan= '4 ' style= 'text-align: center; '><strong>&nbsp;Two-Sample Statistics&nbsp;&nbsp;&nbsp;</strong></td>
</tr>
<tr>
<td><strong>&nbsp;</strong></td>
<td colspan= '2 ' style= 'text-align: center; '><strong>Independent</strong></td>
<td colspan= '2 ' style= 'text-align: center; '><strong>Dependent</strong></td>
</tr>
<tr style= 'border: 1px solid #000000; '>
<td style= 'border: 1px solid #000000; '><strong>Data Type&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; '><strong>Center&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; '><strong>Spread&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; text-align: center; '><strong>Center&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; text-align: center; '><strong>Spread&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; text-align: center; '><strong>Center&nbsp;</strong></td>
<td style= 'border: 1px solid #000000; text-align: center; '><strong>Spread&nbsp;</strong></td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; '><strong>Interval or Ratio</strong></td>
<td style= 'border: 1px solid #000000; '>
<p>Z<sub>X-bar</sub> for &mu;</p>
<p>t for&nbsp;&mu;</p>
</td>
<td style= 'border: 1px solid #000000; '>&nbsp;&chi;<sup>2</sup> for&nbsp;&sigma;<sup>2</sup></td>
<td style= 'border: 1px solid #000000; '>
<p>&nbsp;Z<sub>X-bar1 - X-bar 2</sub> for&nbsp;&mu;<sub>1</sub> -&nbsp;&mu;<sub>2</sub> = 0</p>
<p>t for&nbsp;&mu;<sub>1</sub> -&nbsp;&mu;<sub>2</sub> = 0 (equal &sigma;)</p>
<p>t for&nbsp;&mu;<sub>1</sub> -&nbsp;&mu;<sub>2</sub> = 0 (unequal &sigma;)</p>
</td>
<td style= 'border: 1px solid #000000; '>
<p>F for &sigma;<sub>1</sub><sup>2</sup> =&nbsp;&sigma;<sub>2</sub><sup>2</sup></p>
<p>Levene t or F</p>
<p>t on ADM<sub>(n-1)</sub></p>
</td>
<td style= 'border: 1px solid #000000; '>t for&nbsp;&nbsp;&nbsp;&mu;<sub>1</sub> -&nbsp;&mu;<sub>2</sub> = 0</td>
<td style= 'border: 1px solid #000000; '>t for&nbsp;&nbsp;&sigma;<sub>1</sub><sup>2</sup> =&nbsp;&sigma;<sub>2</sub><sup>2</sup>&nbsp;</td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; '><strong>Nominal</strong></td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '><p>Exact binomial test for proportions</p></td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Two-sample proportion test</p>
<p>&chi;<sup>2</sup> test (2x2 tables)</p>
&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Binomial sign test</p>
<p>McNemar's dependent proportion test&nbsp;</p>
&nbsp;</td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; '><strong>&nbsp;Ordinal</strong></td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Sign test for location (Median test)</p>
<p>Wilcoxon Signed-Ranks test&nbsp;</p>
&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Median test</p>
<p>Wilcoxon-Mann-Whitney U test</p>
<p>Kologorov-Smirnov test</p>
&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Wilcoxon signed-ranks test</p>
<p>Binomial sign test&nbsp;</p>
&nbsp;</td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; '>
<p><strong>Count</strong></p>
<p style= 'text-align: right; '><strong>Poisson&nbsp; &nbsp;</strong></p>
</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>One-sample Poisson exact test&nbsp;&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Two-sample Poisson&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>
<p>Dependent group t-test</p>
<p>Wilcoxon signed-ranks test&nbsp;</p>
&nbsp;</td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; text-align: right; '><strong>Absolute</strong>&nbsp;&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Proper parametric tests&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Proper independent groups test for means and variance&nbsp;&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Dependent group t-test&nbsp;&nbsp;</td>
</tr>
<tr>
<td style= 'border: 1px solid #000000; text-align: right; '><strong>Other Counts&nbsp;&nbsp;&nbsp;</strong></td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Proper nominal data techniques&nbsp;&nbsp;</td>
<td style= 'border: 1px solid #000000; '>Proper independent groups nominal data techniques&nbsp;</td>
<td style= 'border: 1px solid #000000; '>&nbsp;</td>
<td colspan= '2 ' style= 'border: 1px solid #000000; '>Dependent groups nominal data techniques&nbsp;&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>")),
                          #####
                          
                          #Means and dispersion UI##############################
                          tabPanel(title = "Means and Dispersion",
                                   tabsetPanel(
                                       tabPanel("Enter Statistics",
                                                h3("Mean and Dispersion Testing - Enter Statistics"),
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    radioButtons(inputId = "one_or_two",
                                                                        label = "One or Two Sample?",
                                                                        choices = c("One Sample"=1,"Two Sample"=2)
                                                                        ),
                                                           uiOutput("md_sig_known"),
                                                           # radioButtons(inputId = "sigma_known",
                                                           #              label = "Is \U03C3 definitively known?",
                                                           #              choices = c("No, use t"=1,"Yes, use z"=2)
                                                           # ),
                                                    uiOutput("md_t_dep_stat"),
                                                    uiOutput("md_t_type_stat"),
                                                    # conditionalPanel(condition = "input.sigma_known == 1 && input.one_or_two == 2 && input.md_t_dep_stat !=1",
                                                    #                  radioButtons(inputId = "t_type",label = "Select:",choices = c(
                                                    #                    "Welch (recommended)"="no",
                                                    #                    "Student (unknown but equal variance)"="yes",
                                                    #                    "Choose based on variance test (not recommended)"="auto"
                                                    #                  ))
                                                    #                  ),
                                                           numericInput(inputId = "conf",
                                                                        label = "Confidence",
                                                                        value = .95,
                                                                        min = 0,
                                                                        max = 1,
                                                                        step = .01,
                                                                        width = "75px"
                                                           ),
                                                           numericInput(inputId = "decimal",
                                                                        label = "Decimals",
                                                                        value = 4,
                                                                        min = 0,
                                                                        max = 9,
                                                                        step = 1,
                                                                        width = "75px"
                                                                        )
                                                           #end radio stats or data
                                                    ),
                                                mainPanel(
                                                    fluidRow(column(6,
                                                                uiOutput("alt_md")),
                                                           column(6,
                                                                  uiOutput("onesample_md"),
                                                                uiOutput(("md_dep_or_indep"))
                                                                )
                                                           ),#end sigma known or unknown
                                                hr(),

                                                h3("Enter Statistics and Parameters"),
                                                fluidRow(
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI1"))
                                                         ),
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI2"))
                                                         )
                                                  ),
                                                fluidRow(
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI3"))
                                                  ),
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI4"))
                                                  )
                                                ),
                                                fluidRow(
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI5"))
                                                  ),
                                                  column(3,
                                                         tags$div(id="inline1", class="inline",uiOutput("mdUI6"))
                                                  )
                                                ),
                                                
                                                
                                                br(),#end enter statistics for M&D
                                       
                                         h4("Results"),
                                         #div(style="width:1250px",verbatimTextOutput("mean_table")),
                                         htmlOutput("pretty_md")
                                         )
                                       )
                                       ),#end M&D stats main panel and tabpanel
                                       
                                       #One and two sample with data
                                       tabPanel("Use data",
                                                h3("Mean and Dispersion Testing - Data"),
                                                #conditionalPanel(condition = "working_data()==NULL",#error not working
                                                #                 h2("No data loaded"),
                                                #                 ),
                                                
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    radioButtons(inputId = "data_type_md",label = "How is the data configured?",choices = c("Data in Columns"=1,"Use Reference Column"=2)),
                                                    
                                                  conditionalPanel(condition = "input.data_type_md == 1",
                                                                   uiOutput("data_choice_column")
                                                                   ),
                                                  conditionalPanel(condition = "input.data_type_md == 2",
                                                                   uiOutput("data_choice_ref"),
                                                                   uiOutput("data_choice_data"),
                                                                   uiOutput("data_choice_g1"),
                                                                   uiOutput("data_choice_g2")
                                                  ),
                                                  uiOutput("md_data_test_selection"),
                                                  # conditionalPanel(condition = "input.dep_or_indep_data==1",
                                                  #                  radioButtons(inputId = "sigma_known_data",
                                                  #                               label = "Is \U03C3 definitively known?",
                                                  #                               choices = c("No, use t"=1,"Yes, use z"=2)
                                                  # )
                                                  # ),
                                                  uiOutput("md_t_dep"),
                                                  uiOutput("md_t_type"),
                                                  numericInput(inputId = "conf_m_d_data",
                                                               label = "Confidence",
                                                               value = .95,
                                                               min = 0,
                                                               max = 1,
                                                               step = .01,
                                                               width = "75px"
                                                  ),
                                                  numericInput(inputId = "decimal_m_d_d",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                  ),
                                                  mainPanel(
                                                    fluidRow(
                                                      column(6,
                                                             uiOutput("alt_mean_data")
                                                             ),
                                                             column(6,
                                                                    uiOutput("md_data_indep"),
                                                                    uiOutput("md_data_one_samp_var")
                                                                    )
                                                      ),
                                                    
                                                    
                                                    #uiOutput("md_tails"),
                                                    #uiOutput("md_data_one_samp_var"),
                                                    fluidRow(
                                                      column (6,
                                                              tags$div(id="inline1", class="inline",uiOutput("md_data_UI1"))
                                                              ),
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",uiOutput("md_data_UI2"))
                                                             )
                                                      ),
                                                      fluidRow(
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",uiOutput("md_data_UI3"))
                                                             ),
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",uiOutput("md_data_UI4"))
                                                      )
                                                    ),
                                                    fluidRow(
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",uiOutput("md_data_UI5"))
                                                      ),
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",uiOutput("md_data_UI6"))
                                                      )
                                                    ),
                                                    # fluidRow(
                                                    #   column(6,NULL),
                                                    #   column(6,
                                                    #          tags$div(id="inline1", class="inline",uiOutput("md_data_UI7"))
                                                    #   ),
                                                    #   
                                                    # ),
                                                    
                                                   
                                                    #verbatimTextOutput("m_d_data"),
                                                    br(),
                                                    h4("Results"),
                                                    uiOutput("pretty_md_data")
                                                    )
                                                  )
                                                )
                                       )#end means and dispersion panels
                                   ),#end means and dispersion
                          ######################################################
                          
                          #Proportion UI########################################
                          tabPanel(title = "Proportion",
                                   tabsetPanel(
                                     tabPanel(title = "Enter Statistics",
                                              h3("Proportion Testing - Enter Statistics"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "one_or_two_p",
                                                                        label = "One or Two Sample?",
                                                                        choices = c("One Sample"=1,"Two Sample"=2)
                                                           ),
                                                  numericInput(inputId = "conf_p",
                                                                        label = "Confidence",
                                                                        value = .95,
                                                                        min = 0,
                                                                        max = 1,
                                                                        step = .01,
                                                                        width = "75px"
                                                           ),
                                                  numericInput(inputId = "decimal_p",
                                                               label = "Decimals",
                                                               value = 4,
                                                               min = 0,
                                                               max = 9,
                                                               step = 1,
                                                               width = "75px"
                                                               )
                                                  
                                                ),
                                                mainPanel(
                                                  fluidRow(
                                                    conditionalPanel(condition = "input.one_or_two_p==1",
                                                                     column(width = 6,
                                                                            selectInput(inputId = "alt_p",
                                                                                        label = "Alternative hypothesis for proportions",
                                                                                        choices = choice_prop_alt_1
                                                                            )
                                                                     )
                                                    ),
                                                    
                                                    conditionalPanel(condition = "input.one_or_two_p==2",
                                                                     column(width = 6,
                                                                            selectInput(inputId = "alt_p2",
                                                                                        label = "Alternative hypothesis for proportions",
                                                                                        choices = choice_prop_alt_2
                                                                            )
                                                                     )#end column
                                                    )
                                                  ),
                                                  
                                                  hr(),
                                                  h3("Enter Statistics and Parameters"),
                                                  fluidRow(
                                                    column(3,
                                                           tags$div(id="inline1", class="inline",numericInput(inputId = "p_samp",
                                                                                                              label = withMathJax("$$p_{1}$$"),
                                                                                                              value = .1,
                                                                                                              min = 0,
                                                                                                              max = 1,
                                                                                                              width = "150px")
                                                           ),
                                                           tags$div(id="inline1", class="inline",numericInput(inputId = "n_samp_p",
                                                                                                              label = withMathJax("$$n_{1}$$"),
                                                                                                              value = 10,
                                                                                                              min = 1,
                                                                                                              step = 1,
                                                                                                              width = "150px")
                                                           )
                                                    ),#end first column
                                                    column(width = 3,
                                                           conditionalPanel(condition = "input.one_or_two_p==1",
                                                                            tags$div(id="inline1", class="inline",numericInput(inputId = "p0",
                                                                                                                               label = withMathJax("$$\\pi_{0}:{ }$$"),
                                                                                                                               value = .5,
                                                                                                                               min = 0,
                                                                                                                               max = 1,
                                                                                                                               width = "150px")
                                                                            )
                                                           ),#end one samp conditional
                                                           conditionalPanel(condition = "input.one_or_two_p==2",
                                                                            tags$div(id="inline1", class="inline",numericInput(inputId = "p2",
                                                                                                                               label = withMathJax("$$p_{2}:{ }$$"),
                                                                                                                               value = .5,
                                                                                                                               min = 0,
                                                                                                                               max = 1,
                                                                                                                               width = "150px")),
                                                                            tags$div(id="inline1", class="inline",numericInput(inputId = "n_samp_p_2",
                                                                                                                               label = withMathJax("$$n_{2}:{ }$$"),
                                                                                                                               value = 10,
                                                                                                                               min = 0,
                                                                                                                               step = 1,
                                                                                                                               width = "150px"))
                                                           )
                                                    )#end second column
                                                  ),#end fluid row
                                                  #,
                                                  br(),
                                                  h4("Results"),
                                                  uiOutput("pretty_prop_stat")
                                                )#end mainpanel
                                              )#end sidebar layout
                                              
                                              ),#end enter stats tab panel
                                     
                                     tabPanel(title = "Use Data",
                                              h3("Proportion Testing - Use Data"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "data_type_bi",label = "How is the data configured?",choices = c("Data in Columns"=1,"Use Reference Column"=2)),
                                                  
                                                  conditionalPanel(condition = "input.data_type_bi == 1",
                                                                   uiOutput("data_choice_column_bi")
                                                  ),
                                                  conditionalPanel(condition = "input.data_type_bi == 2",
                                                                   uiOutput("data_choice_ref_bi"),
                                                                   uiOutput("data_choice_data_bi"),
                                                                   uiOutput("data_choice_g1_bi"),
                                                                   uiOutput("data_choice_g2_bi")
                                                  ),
                                                  uiOutput("data_bi_success1"),
                                                  uiOutput("data_bi_success2"),
                                                  
                                                  #uiOutput("md_t_type"),
                                                  numericInput(inputId = "conf_bi_data",
                                                               label = "Confidence",
                                                               value = .95,
                                                               min = 0,
                                                               max = 1,
                                                               step = .01,
                                                               width = "75px"
                                                  ),
                                                  numericInput(inputId = "decimal_bi_d",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                              
                                                ),#end sidebar panel
                                                mainPanel(
                                                  fluidRow(
                                                    column(6,
                                                           uiOutput("alt_bi_data")
                                                           )
                                                  ),
                                                  
                                                  hr(),
                                                  h3("Statistics from Data"),
                                                  fluidRow(
                                                    column(3,
                                                           uiOutput("bi_test_data_ui1")
                                                           ),
                                                    column(3,
                                                           uiOutput("bi_test_data_ui2")
                                                           )
                                                    
                                                  ),
                                                  fluidRow(
                                                    column(3,
                                                           uiOutput("bi_test_data_ui3")
                                                           ),
                                                    column(3,
                                                           uiOutput("bi_test_data_ui4")
                                                    )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("pretty_prop_stat_data")
                                                )#end mainpanel proportion data
                                              )#end sidebarlayout
                                              ) #end tabpanel for proportion with data
                                     ),#end tabset to enter data for proportions
                                   ),#end tab panel for proportion
                          ######################################################
                          
                          #Poisson UI###########################################
                          tabPanel(title = "Poisson",
                                   tabsetPanel(
                                     tabPanel(title = "Enter Statistics",
                                              h3("Poisson Rate Testing - Enter Statistics"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "one_or_two_poi",
                                                                    label = "One or Two Sample?",
                                                                    choices = c("One Sample"=1,"Two Sample"=2)
                                                       ),
                                                  numericInput(inputId = "conf_poi",
                                                                    label = "Confidence",
                                                                    value = .95,
                                                                    min = 0,
                                                                    max = 1,
                                                                    step = .01,
                                                                    width = "75px"
                                                       ),
                                                  numericInput(inputId = "decimal_poi",
                                                               label = "Decimals",
                                                               value = 4,
                                                               min = 0,
                                                               max = 9,
                                                               step = 1,
                                                               width = "75px"
                                                               )
                                                  ),#end sidebarpanel
                                                mainPanel(
                                                  fluidRow(
                                                    conditionalPanel(condition = "input.one_or_two_poi==1",
                                                                     column(width = 6,
                                                                            selectInput(inputId = "alt_poi",
                                                                                        label = "Alternative hypothesis for rates",
                                                                                        choices = choice_poi_alt_1
                                                                                        )
                                                                            )
                                                                     ),
                                                    conditionalPanel(condition = "input.one_or_two_poi==2",
                                                                     column(width = 6,
                                                                            selectInput(inputId = "alt_poi_2",
                                                                                        label = "Alternative hypothesis for rates",
                                                                                        choices = choice_poi_alt_2
                                                                                        )
                                                                            )#end column
                                                                     )#end conditionapanel
                                                    ),#end first fluid row
                                                  hr(),
                                                  h3("Enter Statistics and Parameters"),
                                              fluidRow(
                                                column(3,
                                                       tags$div(id="inline1", class="inline",numericInput(inputId = "poi_samp",
                                                                                                          label = withMathJax("$$c_{1}:{ }$$"),
                                                                                                          value = 1,
                                                                                                          min = 0,
                                                                                                          step = 1,
                                                                                                          width = "150px")
                                                       ),
                                                       tags$div(id="inline1", class="inline",numericInput(inputId = "n_samp_poi",
                                                                                                          label = withMathJax("$$n_{1}:{ }$$"),
                                                                                                          value = 10,
                                                                                                          min = 1,
                                                                                                          step = 1,
                                                                                                          width = "150px")
                                                       )
                                                ),#end first column
                                                column(width = 3,
                                                       conditionalPanel(condition = "input.one_or_two_poi==1",
                                                                        tags$div(id="inline1", class="inline",numericInput(inputId = "poi0",
                                                                                                                           label = withMathJax("$$\\lambda_{0}:{ }$$"),
                                                                                                                           value = 2.5,
                                                                                                                           min = 0,
                                                                                                                           width = "150px")
                                                                        )
                                                       ),#end one samp conditional
                                                       conditionalPanel(condition = "input.one_or_two_poi==2",
                                                                        tags$div(id="inline1", class="inline",numericInput(inputId = "poi2",
                                                                                                                           label = withMathJax("$$c_{2}:{ }$$"),
                                                                                                                           value = 3,
                                                                                                                           min = 0,
                                                                                                                           step = 1,
                                                                                                                           width = "150px")),
                                                                        tags$div(id="inline1", class="inline",numericInput(inputId = "n_samp_poi_2",
                                                                                                                           label = withMathJax("$$n_{2}:{ }$$"),
                                                                                                                           value = 10,
                                                                                                                           min = 0,
                                                                                                                           step = 1,
                                                                                                                           width = "150px"))
                                                       )
                                                )#end second column
                                              ),#end fluid row
                                              
                                              br(),
                                              
                                                #verbatimTextOutput("poi_table"),
                                                h4("Results"),
                                                uiOutput("pretty_poi_stat")
                                              
                                                )#end mainpanel
                                              ),#end sidebarlayout
                                              
                                     ),#end enter stats tab panel
                                     #add data panel here
                                     tabPanel(title = "Use Data",
                                              h3("Poisson Rate Testing - Use Data"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "data_type_poi",label = "How is the data configured?",choices = c("Data in Columns"=1,"Use Reference Column"=2)),
                                                  
                                                  conditionalPanel(condition = "input.data_type_poi == 1",
                                                                   uiOutput("data_choice_column_poi")
                                                  ),
                                                  conditionalPanel(condition = "input.data_type_poi == 2",
                                                                   uiOutput("data_choice_ref_poi"),
                                                                   uiOutput("data_choice_data_poi"),
                                                                   uiOutput("data_choice_g1_poi"),
                                                                   uiOutput("data_choice_g2_poi")
                                                  ),
                                                  #uiOutput("data_bi_success1"),
                                                  #uiOutput("data_bi_success2"),
                                                  
                                                  #uiOutput("md_t_type"),
                                                  numericInput(inputId = "conf_poi_data",
                                                               label = "Confidence",
                                                               value = .95,
                                                               min = 0,
                                                               max = 1,
                                                               step = .01,
                                                               width = "75px"
                                                  ),
                                                  numericInput(inputId = "decimal_poi_d",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                ),#end sidebar panel
                                                mainPanel(
                                                  fluidRow(
                                                    column(6,
                                                           uiOutput("alt_poi_data")
                                                           )
                                                  ),
                                                           
                                                           hr(),
                                                           h3("Statistics from Data"),
                                                           fluidRow(
                                                             column(3,
                                                                    uiOutput("poi_test_data_ui1")
                                                             ),
                                                             column(3,
                                                                    uiOutput("poi_test_data_ui2")
                                                             )
                                                             
                                                           ),
                                                           fluidRow(
                                                             column(3,
                                                                    uiOutput("poi_test_data_ui3")
                                                             ),
                                                             column(3,
                                                                    uiOutput("poi_test_data_ui4")
                                                             )
                                                           ),
                                                           br(),
                                                           h4("Results"),
                                                           htmlOutput("pretty_poi_stat_data")
                                                    #)
                                                  #)#end fluid row
                                                )#end mainpanel
                                                )#end sidebarlayout
                                              )#end tabpanel for Poisson with data
                                     )#end tabsetpanel for Poisson
                                   ),#end Poisson
                          
                          #One & Two Sample tests, nonparametric###########
                          tabPanel(title = "Nonparametric",
                                   h3("Nonparametric Tests"),
                                   br(),
                                   tabsetPanel(
                                   tabPanel(title = "Enter Statistics",
                                            sidebarLayout(
                                              sidebarPanel(
                                                numericInput(inputId = "conf_np",
                                                             label = "Confidence",
                                                             value = .95,
                                                             min = 0,
                                                             max = 1,
                                                             step = .01,
                                                             width = "75px"
                                                ),
                                                selectInput(inputId = "one_or_two_np",label = "One Sample or Two?",choices = c("One-Sample"=1,"Two Sample Independent"=2,"Two-Sample Dependent"=3)),
                                                uiOutput("np_tests"),
                                                numericInput(inputId = "np_decimals",label = "Decimals",value = 4,min = 0,step = 1,width = "75px"),
                                                checkboxInput(inputId = "np_more_info",label = "More information about selected test",value = F),
                                                #uiOutput("np_more_info_text")
                                              ),
                                              mainPanel(
                                                br(),
                                                fluidRow(
                                                  column(5,
                                                         uiOutput("np_alt")
                                                  )
                                                  
                                                ),
                                                fluidRow(
                                                  column(6,
                                                         tags$div(id="inline1", class="inline",
                                                                  uiOutput("npUI1"),HTML("</br>"),
                                                                  uiOutput("npUI3"),HTML("</br>"),
                                                                  uiOutput("npUI5")
                                                                  
                                                         )
                                                         
                                                  ),
                                                  column(6,
                                                         tags$div(id="inline1", class="inline",
                                                                  uiOutput("npUI2"),HTML("</br>"),
                                                                  uiOutput("npUI4"),HTML("</br>"),
                                                                  uiOutput("npUI6"),HTML("</br>")
                                                         )
                                                  )
                                                  
                                                  
                                                ),#end fluidrow
                                                #output
                                                br(),
                                                h4("Results"),
                                                #verbatimTextOutput("np_text_stat"),
                                                uiOutput("pretty_nonparametric")
                                                )#end main panel
                                                
                                            )#end sidebar layout
                                            ),#end enter statistics for nonparemetric
                                   tabPanel(title = "Use Data",
                                   sidebarLayout(
                                     sidebarPanel(
                                       numericInput(inputId = "conf_np_data",
                                                    label = "Confidence",
                                                    value = .95,
                                                    min = 0,
                                                    max = 1,
                                                    step = .01,
                                                    width = "75px"
                                       ),
                                       
                                       radioButtons(inputId = "data_type_np",label = "How is the data configured?",choices = c("Data in Columns"=1,"Use Reference Column"=2)),
                                       
                                       conditionalPanel(condition = "input.data_type_np == 1",
                                                        uiOutput("data_choice_column_np")
                                       ),
                                       conditionalPanel(condition = "input.data_type_np == 2",
                                                        uiOutput("data_choice_ref_np"),
                                                        uiOutput("data_choice_data_np"),
                                                        uiOutput("data_choice_g1_np"),
                                                        uiOutput("data_choice_g2_np")
                                       ),
                                       
                                       uiOutput(outputId = "ind_or_dep_np_data"),

                                       uiOutput("np_tests_data"),
                                       uiOutput("np_mc_pass"),
                                         
                                       numericInput(inputId = "decimal_np_data",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                       checkboxInput(inputId = "np_more_info_data",label = "More information about selected test",value = F),
                                       #uiOutput("np_more_info_text_data")
                                     
                                     ),#end sidebarpanel
                                   
                                     mainPanel(
                                       br(),
                                       fluidRow(
                                         column(5,
                                                uiOutput("np_alt_data")
                                         ),
                                         column(5,
                                                conditionalPanel(condition = "input.np_tests_data==3",
                                                                 p("This calculation can take a long time with large sample sizes"),
                                                                 actionBttn(inputId="np_data_u_go",label="Start Calculation",icon=icon("traffic-light"),style = "material-flat",color = "success")
                                                                 )
                                                )
                                         ),
                                       br(),
                                       fluidRow(
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("npUI1_data"),HTML("</br>"),
                                                         uiOutput("npUI3_data"),HTML("</br>"),
                                                         uiOutput("npUI5_data")
                                                         
                                                )
                                                
                                         ),
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("npUI2_data"),HTML("</br>"),
                                                         uiOutput("npUI4_data"),HTML("</br>"),
                                                         uiOutput("npUI6_data"),HTML("</br>")
                                                )
                                         )
                                         
                                         
                                       ),#end fluidrow
                                       #output
                                       br(),
                                       h4("Results"),
                                       #verbatimTextOutput("np_text_data"),
                                       uiOutput("pretty_nonparametric_data")
                                     
                                     )#end main panel for data nonparametrics
                                   
                                   )#end sidebarlayout
                                   )#end use data tabpanel
                                   )#end tabset for entering stats or data
                                   )#end nonparametric tabpanel
                          
                          ),#end nonparametric
                          
               #################################################################
               
               #Correlation and association#####################################
               tabPanel(title = "Correlation and Association",
                        tabsetPanel(
                          tabPanel(title = "Enter Statistics",
                                   h3("Correlation and Association"),
                                   br(),
                                   sidebarLayout(
                                     sidebarPanel(
                                            numericInput(inputId = "conf_corr",
                                                         label = "Confidence",
                                                         value = .95,
                                                         min = 0,
                                                         max = 1,
                                                         step = .01,
                                                         width = "75px"
                                            ),
                                            
                                            selectInput(inputId = "one_or_two_corr",label = "One Sample or Two?",choices = c("One-Sample"=1,"Two Sample Independent"=2,"Two-Sample Dependent"=3)),
                                            
                                            uiOutput("corr_tests"),
                                            numericInput(inputId = "decimal_corr",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                            checkboxInput(inputId = "corr_more_info",label = "More information about selected test",value = F),
                                            #uiOutput("corr_more_info_text")
                                     ),#end sidebarpanel
                                     
                                     mainPanel(
                                       fluidRow(
                                         column(5,
                                                uiOutput("corr_alt")
                                                )
                                         
                                       ),
                                       fluidRow(
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("corrUI1"),HTML("</br>"),
                                                         uiOutput("corrUI3"),HTML("</br>"),
                                                         uiOutput("corrUI5")
                                                           
                                                         )
                                         
                                         ),
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("corrUI2"),HTML("</br>"),
                                                         uiOutput("corrUI4"),HTML("</br>"),
                                                         uiOutput("corrUI6"),HTML("</br>")
                                                )
                                                )

                                         
                                       ),
                                       #verbatimTextOutput("corr_text"),
                                       h4("Results"),
                                       uiOutput("pretty_corr")
                                     )
                                   )#end sidebarlayout
                          ),#end tab panel
                          tabPanel(title = "Use Data",
                                   h3("Correlation and Association"),
                                   br(),
                                   sidebarLayout(
                                     sidebarPanel(
                                       numericInput(inputId = "conf_corr_data",
                                                    label = "Confidence",
                                                    value = .95,
                                                    min = 0,
                                                    max = 1,
                                                    step = .01,
                                                    width = "75px"
                                       ),
                                       selectInput(inputId = "one_or_two_corr_data",label = "One Sample or Two?",choices = c("One-Sample"=1,"Two Sample Independent"=2,"Two-Sample Dependent"=3)),
                                       uiOutput("corr_tests_data"),
                                       numericInput(inputId = "decimal_corr_data",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                       checkboxInput(inputId = "corr_more_info_data",label = "More information about selected test",value = F),
                                       #uiOutput("corr_more_info_text_data"),
                                       checkboxInput(inputId = "corr_data_info",label = "Data Structure Requirements",value = F),
                                       uiOutput("corr_data_info_text")
                                     ),#end sidebarpanel
                                     
                                     mainPanel(
                                       
                                       fluidRow(
                                         column(5,
                                                uiOutput("data_config")
                                                )
                                       ),
                                       fluidRow(
                                         column(3,
                                                uiOutput("data_choice_column_corr_1")),
                                         column(3,
                                                uiOutput("data_choice_column_corr_2")),
                                         column(3,
                                                uiOutput("data_choice_column_corr_3")),
                                         column(3,
                                                uiOutput("data_choice_column_corr_4"))
                                       ),
                                   fluidRow(
                                     conditionalPanel(condition = "input.corr_tests_data==4 ||
                                                      input.corr_tests_data==7 ||
                                                      input.corr_tests_data==8 ||
                                                      input.corr_tests_data==9 ||
                                                      input.corr_tests_data==10 ||
                                                      input.corr_tests_data==11 ||
                                                      input.corr_tests_data==12
                                                      ",
                                                      verbatimTextOutput("corr_xtab")
                                     #for 1, 2, 3 add a scatterplot, 4 a stacked bar, scatter with two x for 5 and 6, 
                                   )
                                   ),
                                       fluidRow(
                                     column(5,
                                            uiOutput("corr_alt_data")
                                   )),
                                       fluidRow(
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("corrUI1_data"),HTML("</br>"),
                                                         uiOutput("corrUI3_data"),HTML("</br>"),
                                                         uiOutput("corrUI5_data")
                                                         
                                                )
                                                
                                         ),
                                         column(6,
                                                tags$div(id="inline1", class="inline",
                                                         uiOutput("corrUI2_data"),HTML("</br>"),
                                                         uiOutput("corrUI4_data"),HTML("</br>")
                                                )
                                         )
                                         
                                       ),
                                       h4("Results"),
                                   #verbatimTextOutput("corr_text_data"),
                                       
                                       uiOutput("pretty_corr_data")
                                     )
                                   )#end sidebarlayout
                          
                                   ),#end corr with data
                        tabPanel("Scatterplot",
                                 h3("Scatterplot"),
                                 br(),
                                 sidebarLayout(
                                   sidebarPanel(
                                     numericInput(inputId = "conf_scatter",
                                                 label = "Confidence",
                                                 value = .95,
                                                 min = 0,
                                                 max = 1,
                                                 step = .01,
                                                 width = "75px"
                                     ),
                                     numericInput(inputId = "decimal_scat",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                     uiOutput("scat_x"),
                                     uiOutput("scat_y"),
                                     pickerInput(inputId = "curve_fit",label = "Fit Model",choices = curve_fit_choice,options = list(title="None Selected")),
                                     uiOutput("model_ci"),
                                     uiOutput("point_ci"),
                                     prettySwitch(inputId = "y_x_line",label = "y = x Line?",value = F,status="success",fill=T)
                                     
                                   ),#end sidebarpanel
                                   mainPanel(
                                     #plotOutput("scatter_plot"),
                                     div(style = "position:relative",plotOutput("scatterplot",hover = hoverOpts("scat_hover", delay = 100, delayType = "debounce")),
                                         uiOutput("hover_info_scat", style = "pointer-events: none")),#placeholder for hover
                                     HTML("<p style='text-align:right;'><small>Mouse over for point information</small></p>"),
                                     fluidRow(
                                       column(3,
                                              downloadButtonUI('scatterplot')),
                                       column(3,
                                              tags$div(id='inline1', class='inline',downloadSelectUI('scatterplot')
                                                       )
                                              ),
                                       column(6,
                                              tags$div(id="inline1", class="inline",numericInput(inputId = "scat_font_size",label = "Base Font Size",value = 11,min = 1,step=1,width = "75px"))
                                       )
                                       ),
                                     tags$hr(style='border-color: black;'),
                                     uiOutput("scatter_plot_stats")
                                   )#end mainpanel
                                 )#end sidebarlayout
                                 )#end scatterplot
                        )#end tabset panel
                        ),#end correlation and association
               #################################################################
               
               #ANOVA###########################################################
               navbarMenu(title = "ANOVA",#ANOVA including post-hocs
                          #tabsetPanel(
                            tabPanel(title = "Oneway",
                                     navlistPanel(widths = c(2,10),
                                       tabPanel("ANOVA",
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    numericInput(inputId = "conf_ow",
                                                                 label = "Confidence",
                                                                 value = .95,
                                                                 min = 0,
                                                                 max = 1,
                                                                 step = .01,
                                                                 width = "75px"
                                                    ),
                                                    numericInput(inputId = "decimal_ow",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                                    uiOutput("factor_ow"),
                                                    uiOutput("data_ow"),
                                                    radioGroupButtons(inputId = "type_ow",label = "Factor and Test Type",choices = c("Fixed - Welch"=4,"Fixed - Fisher"=1,"Random"=2,"Kruskal-Wallis"=3)),
                                                    conditionalPanel(condition = "input.type_ow != 3",
                                                                     prettySwitch(inputId = "disp_ow",label = "Show Dispersion Tests?",status = "success",fill=TRUE,value = TRUE)
                                                    )
                                                  ),
                                                  mainPanel(
                                                    h4("Oneway ANOVA"),
                                                    htmlOutput("ow_table"),
                                                    conditionalPanel(condition = "input.type_ow == 3",
                                                                     DTOutput("KW_out")
                                                    ),
                                                    conditionalPanel(condition = "input.disp_ow==1",
                                                                     htmlOutput("ow_disp")
                                                    )
                                                  )
                                                )
                                                ),
                                       tabPanel("Post-hoc",
                                                sidebarLayout(
                                                  sidebarPanel(
                                                    numericInput(inputId = "decimal_ow_ph",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px"),
                                                    conditionalPanel(condition = "input.type_ow != 2",
                                                                     prettySwitch(inputId = "lines_ow_ph",label = "Add Lines?",value = T,status = "success",fill=T)
                                                    ),
                                                    uiOutput("ow_ph_plot_type"),
                                                    uiOutput("ow_ph_type"),
                                                    conditionalPanel(condition = "input.type_ow!=2",
                                                                     checkboxInput(inputId = "ow_ph_details",label = "Post-hoc Details?",value = F)
                                                    )
                                                  ),#end sidebar panel
                                                  mainPanel(
                                                    h4("Oneway ANOVA Post-hoc"),
                                                    h5("Confidence set on Oneway ANOVA tab"),
                                                    plotOutput("plotow"),
                                                    fluidRow(
                                                      column(3,
                                                             downloadButtonUI('plotow')),
                                                      column(3,
                                                             tags$div(id='inline1', class='inline',downloadSelectUI('plotow')
                                                             )

                                                      ),
                                                      column(6,
                                                             tags$div(id="inline1", class="inline",numericInput(inputId = "ow_font_size",label = "Base Font Size",value = 11,min = 1,step=1,width = "75px"))
                                                             )
                                                    ),
                                                    tags$hr(style='border-color: black;'),
                                                    #htmlOutput("ow_ph_out"),
                                                    dataTableOutput("ow_ph_out_tab"),
                                                    verbatimTextOutput("ow_ph_details")
                                                  )#end main panel
                                                  
                                                )#end sidebar layout
                                                )#end ph tab panel
                                     )#end navlist
                                     ),#end oneway anova tabpanel
                            tabPanel("Multi-Factor",
                                     #fluidPage(
                                     navlistPanel(id = "mw_anova",widths = c(2,10),
                                                  tabPanel("Set Up",value = "mw_su",
                                                           sidebarLayout(
                                                             sidebarPanel(width=3,
                                                               HTML("<p style='color:red; text-align:center'><u>Important: Make sure factors are numeric and not set as the factor class.</u></p>"),
                                                               uiOutput("ems_factors"),
                                                               uiOutput("ems_data")
                                                             ),
                                                             mainPanel(width=9,
                                                               h3("Create Design"),
                                                               checkboxInput(inputId = "ems_show_mixed_nest",label = "Select random and nested effects?",value = FALSE),
                                                               conditionalPanel(condition = "input.ems_show_mixed_nest==1",
                                                                                fluidRow(
                                                                                  column(6,
                                                                                         uiOutput("ems_rand_select")
                                                                                         ),
                                                                                  column(6,
                                                                                         uiOutput("ems_nest_select")
                                                                                         )
                                                                                  )
                                                                                ),#end random, mixed, nested UI
                                                               fluidRow(
                                                                 column(6,
                                                                        uiOutput("ems_pool"),
                                                                        uiOutput("ems_primary")
                                                                        ),
                                                                 column(6,
                                                                        uiOutput("ems_ems_a")
                                                                        )
                                                               )
                                                             )
                                                           )
                                                  ),
                                                  tabPanel("Results",
                                                           #fluidPage(
                                                             navlistPanel(widths=c(2,10),
                                                             tabPanel("ANOVA",
                                                                      mainPanel(width=12,
                                                                        fluidRow(
                                                                          column(6,numericInput(inputId = "ems_conf",label = "Confidence",value = .95,min = 0,max = 1,width = "75px")),
                                                                          column(6,numericInput(inputId = "ems_dec",label = "Decimals",value = 4,min = 0,max = 9,width = "75px"))
                                                                        ),
                                                                        fluidRow(
                                                                          h4("Results"),
                                                                          fluidRow(
                                                                            column(4,
                                                                                   tags$div(
                                                                                     materialSwitch(inputId = "ems_disp",label = "Means",value = FALSE,inline = TRUE,status="primary"),
                                                                                     tags$span("Dispersion")
                                                                                   )
                                                                                   ),
                                                                            column(4,
                                                                                   conditionalPanel(condition = "input.ems_disp==1",
                                                                                                    radioGroupButtons(inputId = "ems_disp_type",label = "Dispersion Test",choices = c("ADA"=1,"ADM"=2,"ADM(n-1)"=3))
                                                                                                    )
                                                                            ),
                                                                            column(4,
                                                                                   checkboxInput(inputId = "ems_show_pool",label = "Show Pooled Effects?",value = FALSE)
                                                                            )
                                                                          ),
                                                                          HTML("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", paste0(#waiting spinner
                                                                            '<span data-display-if="',
                                                                            '$(&#39;html&#39;).attr(&#39;class&#39;)==&#39;shiny-busy&#39;',
                                                                            '">',
                                                                            '<i class="fa fa-spinner fa-spin-pulse fa-fw" style="color: #337ab7; font-size:50px !important;" ></i>',
                                                                            '</span>'
                                                                          )),
                                                                          #uiOutput("busy"),
                                                                          conditionalPanel(condition = "input.ems_pool==0",
                                                                                           h4("ANOVA Source Table"),
                                                                            htmlOutput("ems_table")
                                                                          ),
                                                                          conditionalPanel(condition = "input.ems_pool!=0",
                                                                                           h4("Pooled ANOVA Source Table"),
                                                                            htmlOutput("ems_table_pooled")
                                                                          )
                                                                        )
                                                                      )
                                                                      ),
                                                             tabPanel("Graphs",
                                                                      mainPanel(width=12,
                                                                      numericInput(inputId = "ems_target",label = "Target",value = NA,width = "100px"),
                                                                      plotOutput(outputId = "emssigeffects",width = "auto",height = "auto"),
                                                                      fluidRow(
                                                                        column(6,
                                                                               downloadButtonUI('emssigeffects')),
                                                                        column(6,
                                                                               tags$div(id='inline1', class='inline',downloadSelectUI('emssigeffects'))
                                                                        )
                                                                      ),
                                                                      hr(),
                                                                      checkboxInput(inputId = "ems_show_coeffs",label = "Show Reduced Model Coefficients?",value = FALSE),
                                                                      conditionalPanel(condition = "input.ems_show_coeffs==1",
                                                                                       DTOutput("multi_coeff_est")
                                                                                       ),
                                                                      hr(),
                                                                      checkboxInput(inputId = "ems_show_optimum",label = "Show Settings with Estimated Average Closest to Target?",value = FALSE),
                                                                      conditionalPanel(condition = "input.ems_show_optimum==1",
                                                                                       tags$div(id='inline1', class='inline',numericInput(inputId = "multi_response_tol",label = "Range of Averages Around Target to Display",value = 0)),
                                                                                       DTOutput("multi_response_target")
                                                                                       ),
                                                                      hr(),
                                                                      checkboxInput(inputId = "ems_show_box",label = "Show Main Effects Boxplots",value = FALSE),
                                                                      conditionalPanel(condition = "input.ems_show_box==1",
                                                                                       plotOutput("emsmaineffects",width="auto",height="auto"),
                                                                                       fluidRow(
                                                                                         column(6,
                                                                                                downloadButtonUI('emsmaineffects')),
                                                                                         column(6,
                                                                                                tags$div(id='inline1', class='inline',downloadSelectUI('emsmaineffects')
                                                                                                )
                                                                                         )
                                                                                       )
                                                                      ),
                                                                      hr(),
                                                                      uiOutput("ems_int_sel"),
                                                                      uiOutput("emsinteractions"),
                                                                      fluidRow(
                                                                        column(6,
                                                                               downloadButton(outputId = "ems_interaction_dl",label = "Download all as zip")
                                                                               ),
                                                                        column(6,
                                                                               tags$div(id='inline1', class='inline',
                                                                               pickerInput(inputId = "ems_interaction_dl_format",
                                                                                  label = "Format: ",
                                                                                  choices = c("eps","ps","tex","pdf","jpeg","tiff","png","bmp","svg","wmf"),
                                                                                  selected = "svg",
                                                                                  width = "75px")
                                                                               )
                                                                               )
                                                                      )
                                                                      )),#end graphs
                                                             tabPanel("Post-hocs",
                                                                      fluidPage(
                                                                        pickerInput(inputId = "ems_ph_select",
                                                                                    label = "Select fixed effect post-hoc",
                                                                                    choices = list(
                                                                                      "All pair-wise, equal variance"=c("Tukey"=1,"Bonferroni Procedure"=2,"Holm's Method"=3),
                                                                                      "All pair-wise, unequal variance"=c("Games-Howell"=4,"Bonferroni Procedure"=5,"Holm's Method"=6)#,
                                                                                      #"Complex Contrasts"=c("Welch"=5,"Bonferroni Approach"=6)
                                                                                      ),
                                                                                    options = list(title="Select test"),
                                                                                    selected = NULL
                                                                                    ),
                                                                        uiOutput("ems_ph_selection"),
                                                                        fluidRow(
                                                                          prettyCheckboxGroup(inputId = "ems_ph_plot_options",label = "Select Options",choices = c("Show Confidence Inervals"="CIs","Show Prediction Intervals"="PIs","Plot Horizontal?"="hor"),selected = c("CIs","PIs"),inline = TRUE,status = "success")
                                                                        ),
                                                                        plotOutput("emsphplot"),
                                                                        fluidRow(
                                                                          column(4,
                                                                                 downloadButtonUI('emsphplot')),
                                                                          column(4,
                                                                                 tags$div(id='inline1', class='inline',downloadSelectUI('emsphplot'))),
                                                                          column(4,
                                                                                 tags$div(id="inline1", class="inline",numericInput(inputId = "ph_font_size",label = "Base Font Size",value = 11,min = 1,step=1,width = "75px")))
                                                                        ),
                                                                        hr(),
                                                                        htmlOutput("ems_ph_out")
                                                                        # hr(),
                                                                        # plotOutput("emseffectsizegraph"),
                                                                        # fluidRow(
                                                                        #   column(6,
                                                                        #          downloadButtonUI('emseffectsizegraph')),
                                                                        #   column(6,
                                                                        #          tags$div(id='inline1', class='inline',downloadSelectUI('emseffectsizegraph'))
                                                                        #          
                                                                        #   )
                                                                        # )
                                                                      )#end fluid page
                                                                      )#end post-hocs tabpanel
                                                           )
                                                           #)
                                                  )
                                     )
                                     #)
                            )#end multi
                            ),#end tabpanel ANOVA
               #################################################################
               
               #Statistical Process Control charts##############################
               tabPanel(title = "SPC",
                        h3("Control Charts"),
                        tabsetPanel(
                          tabPanel(title = "Variables",
                                   sidebarLayout(
                                     sidebarPanel(
                                       h4("1. Set Up Chart"),
                                       tags$div(
                                         materialSwitch(inputId = "spc_var_ind_or_mean",label = "Mean",value = FALSE,inline = TRUE),
                                         tags$span("Individuals")
                                       ),
                                       conditionalPanel(condition = "input.spc_var_ind_or_mean==0",
                                         radioButtons(inputId = "spc_var_data_type",label = "Subgroups are:",choices = c("A row across multiple columns"=1,"Defined by a column"=2))
                                       ),
                                       uiOutput("spc_var_UI1"),#choice_column
                                       uiOutput("spc_var_UI2"),
                                       uiOutput("spc_var_set"),
                                       checkboxInput(inputId = "spc_runchart",label = "Plot as run chart (no limits)?",value = FALSE),
                                       uiOutput("spc_run_type"),
                                       conditionalPanel(condition = "input.spc_runchart==0",
                                                        h4("2. Select Chart Types and Limits"),
                                       dropdown(
                                         fluidRow(
                                           column(6,#location items
                                                  uiOutput("spc_var_loc_type"),
                                                  conditionalPanel(condition = "input.spc_var_loc_lim<11",
                                                                   selectInput(inputId = "spc_x_loc",label = "Location Centerline",choices = choice_x_centerline)
                                                  ),
                                                  conditionalPanel(condition = "input.spc_var_disp_type==4",#this is correct
                                                                   numericInput(inputId = "spc_mr_span",label = "Span of MR",value = 2,min = 2,step = 1)
                                                  ),
                                                  uiOutput("spc_var_loc_lim"),
                                                  
                                                  conditionalPanel(condition = "input.spc_var_loc_lim==12",#custom
                                                                   hr(style = "border-top: 1px solid #000000;"),
                                                                   h4("Custom Location Limits"),
                                                                   numericInput(inputId = "custom.x.upper",label = "UCL",value = 0),
                                                                   numericInput(inputId = "custom.x.center",label = "Centerline",value = 0),
                                                                   numericInput(inputId = "custom.x.lower",label = "LCL",value = 0)
                                                  )#end custom location
                                           ),#end loc column
                                           column(6,#dispersion items
                                                  uiOutput("spc_var_disp_type"),
                                                  conditionalPanel(condition = "input.spc_var_disp_lim<11 && input.spc_var_disp_lim !=9",
                                                                   selectInput(inputId = "spc_x_disp",label = "Dispersion Centerline",choices = choice_x_centerline)
                                                  ),
                                                  uiOutput("spc_var_disp_lim"),
                                                  conditionalPanel(condition = "input.spc_var_disp_lim==12",#custom
                                                                   hr(style = "border-top: 1px solid #000000;"),
                                                                   h4("Custom Dispersion Limits"),
                                                                   numericInput(inputId = "custom.disp.upper",label = "UCL",value = 0),
                                                                   numericInput(inputId = "custom.disp.center",label = "Centerline",value = 0),
                                                                   numericInput(inputId = "custom.disp.lower",label = "LCL",value = 0)
                                                  ),#end custom dispersion
                                                  style = 'border-left: 1px solid'
                                           )#end dispersion column
                                           ),#end fluid row
                                         conditionalPanel(condition = "input.spc_var_loc_lim==9 || input.spc_var_disp_lim==9",#known s
                                                          numericInput(inputId = "known_sig_x",label = "Enter \U03C3",value = 1,min = 0)
                                         ),
                                         
                                           selectInput(inputId = "std_err_x",label = "Standard Errors",choices = c(2,3),selected = 3),
                                           
                                         circle = TRUE, status = "danger",
                                         icon = icon("fas fa-chart-line"), width = "300px",
                                         tooltip = tooltipOptions(title = "Click to select charts and limits"))#end dropdown
                                                        ),#end runchart conditional
                                       
                                       
                                     ),#end sidebarpanel
                                     mainPanel(
                                     div(style = "position:relative",plotOutput("xchartout",hover = hoverOpts("plot_hover", delay = 100, delayType = "debounce")),
                                           uiOutput("hover_info_x", style = "pointer-events: none")),#placeholder for hover
                                     HTML("<p style='text-align:right;'><small>Mouse over for point information</small></p>"),
                                     fluidRow(
                                       column(3,
                                              downloadButtonUI('xchartout')),
                                       column(3,
                                              tags$div(id='inline1', class='inline',downloadSelectUI('xchartout')
                                                       )
                                              ),
                                       column(6,
                                              tags$div(id="inline1", class="inline",numericInput(inputId = "spc_font_size",label = "Base Font Size",value = 11,min = 1,step=1,width = "75px"))
                                              )
                                       ),
                                     tags$hr(style='border-color: black;'),
                                       br(),
                                       fluidRow(
                                         column(width = 2,
                                                conditionalPanel(condition = "input.spc_runchart==0",
                                                  dropdown(
                                         tags$h4("Chart Options"),
                                         uiOutput("ooc_rules_x_ui"),
                                         uiOutput("ooc_rules_disp_ui"),
                                         selectInput(inputId = "run_length_x",label = "Run Length",choices = c(8,9),selected = 8),
                                         checkboxGroupButtons(
                                           inputId = "x_chart_options",
                                           label = "Graph Features",
                                           choices = c("Connect Points"=1, 
                                                       "Control Limits"=2, "Center Line"=3,"Show OOC Points"=4,"Show OOC Labels"=5,"Show Zones"=6),
                                           direction = "vertical",selected = c(1,2,3,4)
                                         ),
                                         circle = TRUE, status = "success",
                                         icon = icon("gear"), width = "300px",
                                         
                                         tooltip = tooltipOptions(title = "Click to modify chart")
                                       )#end dropdown
                                         )
                                       
                                         ),#end column
                                       column(width = 3,
                                              uiOutput("spc_analysis")
                                              # prettySwitch(
                                              #   inputId = "x_spc_show_anova",
                                              #   label = "Show Analysis", 
                                              #   value = FALSE,
                                              #   status = "success",
                                              #   fill = TRUE
                                              # )#end material switch
                                       ),#end column
                                       column(width=3,
                                              prettySwitch(
                                                inputId = "x_spc_show_data",
                                                label = "Show plot data", 
                                                value = FALSE,
                                                status = "success",
                                                fill = TRUE
                                                )#end material switch
                                              ),#end column
                                       column(3,
                                              numericInput(inputId = "spc_x_anova_decimals",label = "Decimals",value = 4,min = 0,step = 1,width = "50px")
                                       )
                                       ),#end fluidrow
                                       conditionalPanel(condition = "input.x_spc_show_anova==1",# && typeof input.c_spc_show_anova != 'undefined'",
                                                        #show analysis stuff here
                                                        tags$div(id="inline1", class="inline",
                                                        fluidRow(
                                                          column(6,uiOutput("limit_analysis_x")
                                                                 ),#end column
                                                          column(6,
                                                                 p("Enter specs for Capability Analysis"),
                                                                 numericInput(inputId = "spc_x_USL",label = "USL: ",value = NA,width = "75px"),
                                                                 numericInput(inputId = "spc_x_target",label = "Target: ",value = NA,width = "75px"),
                                                                 numericInput(inputId = "spc_x_LSL",label = "LSL: ",value = NA,width = "75px")
                                                                 )#end column
                                                        )#end fluid row
                                                        ),#end tag
                                                        hr(style = "border-top: 1px solid #000000;"),
                                                        uiOutput("capability_analysis_x"),
                                                        hr(style = "border-top: 1px solid #000000;"),
                                                        fluidRow(
                                                          column(8,
                                                          h4("Oneway Random Effects ANOVA")
                                                          ),
                                                          column(4,
                                                                 numericInput(inputId = "spc_x_anova_conf",label = "Confidence",value = .95,min = 0,max = 1,width = "75px")
                                                          )
                                                        ),#end fluid row
                                                        htmlOutput("spc_anova")
                                       ),#end anova conditional
                                       conditionalPanel(condition = "input.x_spc_show_data==1",
                                                        hr(style = "border-top: 1px solid #000000;"),
                                                        h4("Plot Data"),
                                                        dataTableOutput("xbar_table_out")
                                       #DT::datatable(data = plot_data,options=list(dom="t",paging=FALSE),rownames = F)
                                       )#end data table conditional
                                     )#end mainpanel
                                   )#end sidebarlayout
                                   ),#end variables spc
                          tabPanel(title = "Attributes",
                                   sidebarLayout(
                                     sidebarPanel(
                                       h4("1. Set Up Chart"),
                                       # tags$div(
                                       #   materialSwitch(inputId = "spc_var_ind_or_mean",label = "Mean",value = FALSE,inline = TRUE),
                                       #   tags$span("Individuals")
                                       # ),
                                       # conditionalPanel(condition = "input.spc_var_ind_or_mean==0",
                                                        radioButtons(inputId = "spc_att_data_type",label = "Observations are:",choices = c("Each row"=1)),#"Defined by a column"=2)
                                       # ),
                                       uiOutput("spc_att_UI1"),#choice_column
                                       checkboxInput(inputId = "att_const_n",label = "Constant n?",value = FALSE),
                                       uiOutput("spc_att_UI2"),
                                       conditionalPanel(condition = "input.spc_att_loc!=3 && input.spc_att_loc_lim!=8",#
                                         uiOutput("spc_att_set")
                                       ),
                                       h4("2. Select Chart Types and Limits"),
                                       dropdown(
                                         fluidRow(
                                           
                                                  uiOutput("spc_att_loc_type"),
                                                  conditionalPanel(condition = "input.spc_att_loc_lim<6",
                                                                   uiOutput("spc_att_loc")
                                                  ),
                                                  
                                                  uiOutput("spc_att_loc_lim"),
                                                  
                                                  conditionalPanel(condition = "input.spc_att_loc_lim==8",#custom
                                                                   hr(style = "border-top: 1px solid #000000;"),
                                                                   h4("Custom Limits"),
                                                                   numericInput(inputId = "custom.att.upper",label = "UCL",value = 0),
                                                                   numericInput(inputId = "custom.att.center",label = "Centerline",value = 0),
                                                                   numericInput(inputId = "custom.att.lower",label = "LCL",value = 0)
                                                  ),#end custom location
                                           
                                           uiOutput("known_param_att"),
                                          selectInput(inputId = "std_err_att",label = "Standard Errors",choices = c(2,3),selected = 3)
                                         ),#end fluid row
                                          
                                        
                                         
                                         circle = TRUE, status = "danger",
                                         icon = icon("fas fa-chart-line"), width = "300px",
                                         tooltip = tooltipOptions(title = "Click to select charts and limits"))#end dropdown
                                     ),#end sidebarpanel
                                     mainPanel(
                                       div(style = "position:relative",plotOutput("attchartout",hover = hoverOpts("plot_hover_att", delay = 100, delayType = "debounce")),
                                           uiOutput("hover_info_att", style = "pointer-events: none")),#placeholder for hover
                                       fluidRow(
                                         column(3,
                                                downloadButtonUI("attchartout")
                                         ),
                                         column(3,
                                                tags$div(id="inline1", class="inline",
                                                         downloadSelectUI('attchartout')
                                                )
                                         ),
                                         column(6,
                                                tags$div(id="inline1", class="inline",numericInput(inputId = "att_spc_font_size",label = "Base Font Size",value = 11,min = 1,step=1,width = "75px"))
                                         )
                                       ),
                                       br(),
                                       fluidRow(
                                         column(width = 2,
                                                dropdown(
                                                  tags$h4("Chart Options"),
                                                  uiOutput("ooc_rules_att_ui"),
                                                  #uiOutput("ooc_rules_disp_ui"),
                                                  selectInput(inputId = "run_length_att",label = "Run Length",choices = c(8,9),selected = 8),
                                                  checkboxGroupButtons(
                                                    inputId = "att_chart_options",
                                                    label = "Graph Features",
                                                    choices = c("Connect Points"=1, 
                                                                "Control Limits"=2, "Center Line"=3,"Show OOC Points"=4,"Show OOC Labels"=5,"Show Zones"=6),
                                                    direction = "vertical",selected = c(1,2,3,4)
                                                  ),
                                                  circle = TRUE, status = "success",
                                                  icon = icon("gear"), width = "300px",
                                                  
                                                  tooltip = tooltipOptions(title = "Click to modify chart")
                                                )#end dropdown
                                         ),#end column
                                         column(width = 3,
                                                prettySwitch(
                                                  inputId = "att_spc_show_analysis",
                                                  label = "Limit Summary",
                                                  value = FALSE,
                                                  status = "success",
                                                  fill = TRUE
                                                )#end material switch
                                         ),#end column
                                         column(width=3,
                                                prettySwitch(
                                                  inputId = "att_spc_show_data",
                                                  label = "Show plot data", 
                                                  value = FALSE,
                                                  status = "success",
                                                  fill = TRUE
                                                )#end material switch
                                         ),#end column
                                         column(3,
                                                numericInput(inputId = "spc_att_decimals",label = "Decimals",value = 4,min = 0,step = 1,width = "75px")
                                         )
                                       ),#end fluidrow
                                       conditionalPanel(condition = "input.att_spc_show_analysis==1",
                                                        #show analysis stuff here
                                                        uiOutput("limit_analysis_att")
                                       ),#end analysis conditional
                                       conditionalPanel(condition = "input.att_spc_show_data==1",
                                                        hr(style = "border-top: 1px solid #000000;"),
                                                        h4("Plot Data"),
                                                        dataTableOutput("att_table_out")
                                                        #DT::datatable(data = plot_data,options=list(dom="t",paging=FALSE),rownames = F)
                                       )#end data table conditional
                                     )#end mainpanel
                                   )#end sidebarlayout
                                   ),#end attributes charts
                          tabPanel(title = "Limits Calculations",
                                   tabsetPanel(
                                     tabPanel(title = withMathJax("$\\bar{X}$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                              radioButtons(inputId = "x_bar_lim_stat",label = "Select Method",choices = choice_x_bar_limits)
                                                ),
                                              mainPanel(
                                                h3("Control Limit Calculations"),
                                                br(),
                                                h4("Enter Statistics"),
                                                fluidRow(column
                                                         (width = 4,
                                                tags$div(id="inline1", class="inline",
                                                         numericInput(inputId = "x_bar_lim_x_bar",label = withMathJax("$\\overline{\\overline{X}}:$"),value = 0,width = "75px"),
                                                         uiOutput("x_bar_lim_value"),
                                                         numericInput(inputId = "x_bar_lim_n",label = withMathJax("$n:$"),value = 5,min = 1,step = 1,width = "75px"),
                                                ),#end tag
                                                ),
                                                column(width = 4,
                                                       tags$div(id="inline1", class="inline",
                                                       numericInput(inputId = "x_bar_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                       br(),
                                                       numericInput(inputId = "x_bar_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                       )
                                                       )
                                                ),
                                                br(),
                                                h4("Results"),
                                                htmlOutput("x_bar_lim_out")
                                              )#end mainpanel
                                              )#end sidebarlayout
                                              ),#end x-bar tab
                                     # tabPanel(title = withMathJax("$\\widetilde{X}$"),
                                     #          sidebarLayout(
                                     #            sidebarPanel(
                                     #              radioButtons(inputId = "x_tilde_lim_stat",label = "Select Method",choices = choice_x_tilde_limits)
                                     #            ),
                                     #            mainPanel(
                                     #              h3("Control Limit Calculations"),
                                     #              br(),
                                     #              h4("Enter Statistics"),
                                     #              fluidRow(column
                                     #                       (width = 4,
                                     #                         tags$div(id="inline1", class="inline",
                                     #                                  numericInput(inputId = "x_tilde_lim_x_bar",label = withMathJax("$\\widetilde{X}:$"),value = 0,width = "75px"),
                                     #                                  uiOutput("x_tilde_lim_value"),
                                     #                                  numericInput(inputId = "x_tilde_lim_n",label = withMathJax("$n:$"),value = 5,min = 1,step = 1,width = "75px"),
                                     #                         ),#end tag
                                     #                       ),
                                     #                       column(width = 4,
                                     #                              tags$div(id="inline1", class="inline",
                                     #                                       numericInput(inputId = "x_tilde_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                     #                                       br(),
                                     #                                       numericInput(inputId = "x_tilde_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                     #                              )
                                     #                       )
                                     #              ),
                                     #              br(),
                                     #              h4("Results"),
                                     #              htmlOutput("x_tilde_lim_out")
                                     #            )#end mainpanel
                                     #          )#end sidebarlayout
                                     #          ),#end median
                                     tabPanel(title = withMathJax("$X$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "x_lim_stat",label = "Select Method",choices = choice_x_limits)
                                                ),
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      numericInput(inputId = "x_lim_x_bar",label = withMathJax("$\\bar{X}:$"),value = 0,width = "75px"),
                                                                      uiOutput("x_lim_value"),
                                                                      uiOutput("x_lim_n_UI")
                                                                      ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "x_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "x_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("x_lim_out")
                                                )#end mainpanel
                                              )#end sidebarlayout
                                              ),#end ind
                                     tabPanel(title = withMathJax("$R$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "r_lim_stat",label = "Select Method",choices = choice_r_limits)
                                                ),
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      uiOutput("r_lim_value"),
                                                                      numericInput(inputId = "r_lim_n",label = withMathJax("$n:$"),value = 5,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "r_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "r_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("r_lim_out")
                                                )#end mainpanel
                                              )#end sidebarlayout
                                              ),#end R
                                     tabPanel(title = withMathJax("$s$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "s_lim_stat",label = "Select Method",choices = choice_r_limits,selected = 3)
                                                ),
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      uiOutput("s_lim_value"),
                                                                      numericInput(inputId = "s_lim_n",label = withMathJax("$n:$"),value = 5,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "s_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "s_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("s_lim_out")
                                                )#end mainpanel
                                              )#end sidebarlayout
                                              ),#end s
                                     tabPanel(title = withMathJax("$s^{2}$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "s2_lim_stat",label = "Select Method",choices = choice_r_limits,selected = 5)
                                                ),
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      uiOutput("s2_lim_value"),
                                                                      numericInput(inputId = "s2_lim_n",label = withMathJax("$n:$"),value = 5,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "s2_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "s2_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("s2_lim_out")
                                                )#end mainpanel
                                              )#end sidebarlayout
                                              ),#end var
                                     tabPanel(title = withMathJax("$p$"),
                                               sidebarLayout(
                                                 sidebarPanel(
                                                   radioButtons(inputId = "p_lim_stat",label = "Select Method",choices = c("Exact"=1,"Approximate"=2))
                                                 ),#end panel
                                                 mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      numericInput(inputId = "p_lim_value",label = withMathJax("$\\bar{p}:$"),value = .5,min = 0,max = 1,width = "75px"),
                                                                      numericInput(inputId = "p_lim_n",label = withMathJax("$n:$"),value = 10,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "p_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "p_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("p_lim_out")
                                                 )#end mainpanel
                                               )#end sidbarlayout
                                              ),#end p
                                     tabPanel(title = withMathJax("$np$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "np_lim_stat",label = "Select Method",choices = c("Exact"=1,"Approximate"=2))
                                                ),#end panel
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      numericInput(inputId = "np_lim_value",label = withMathJax("$\\overline{np}:$"),value = 5,min = 0,max = 1,width = "75px"),
                                                                      numericInput(inputId = "np_lim_n",label = withMathJax("$n:$"),value = 10,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "np_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "np_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("np_lim_out")
                                                )#end mainpanel
                                              )#end sidbarlayout
                                              ),#end np
                                     tabPanel(title = withMathJax("$c$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "c_lim_stat",label = "Select Method",choices = c("Exact"=1,"Approximate"=2))
                                                ),#end panel
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      numericInput(inputId = "c_lim_value",label = withMathJax("$\\bar{c}:$"),value = 5,min = 0,max = 1,width = "75px"),
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "c_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "c_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("c_lim_out")
                                                )#end mainpanel
                                              )#end sidbarlayout
                                              ),#end c
                                     tabPanel(title = withMathJax("$u$"),
                                              sidebarLayout(
                                                sidebarPanel(
                                                  radioButtons(inputId = "u_lim_stat",label = "Select Method",choices = c("Exact"=1,"Approximate"=2))
                                                ),#end panel
                                                mainPanel(
                                                  h3("Control Limit Calculations"),
                                                  br(),
                                                  h4("Enter Statistics"),
                                                  fluidRow(column
                                                           (width = 4,
                                                             tags$div(id="inline1", class="inline",
                                                                      numericInput(inputId = "u_lim_value",label = withMathJax("$\\bar{u}:$"),value = .5,min = 0,max = 1,width = "75px"),
                                                                      numericInput(inputId = "u_lim_n",label = withMathJax("$n:$"),value = 10,width = "75px")
                                                             ),#end tag
                                                           ),
                                                           column(width = 4,
                                                                  tags$div(id="inline1", class="inline",
                                                                           numericInput(inputId = "u_lim_sterr",label = "Standard Errors",value = 3,min = 1,width = "75px"),
                                                                           br(),
                                                                           numericInput(inputId = "u_lim_decimals",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                                                  )
                                                           )
                                                  ),
                                                  br(),
                                                  h4("Results"),
                                                  htmlOutput("u_lim_out")
                                                )#end mainpanel
                                              )#end sidbarlayout
                                              )#end u
                                   ))
                        )),
               
               tabPanel(title = "MSA",#Measurement System Analysis
                        tabsetPanel(
                                    tabPanel("Continuous",
                        sidebarLayout(
                          sidebarPanel(width=4,
                            radioButtons(inputId = "msa_data_type",label = "How is the data configured?",choices = c("Use reference columns"=2)),
                            uiOutput("msa_UI1"),
                            uiOutput("msa_UI2"),
                            uiOutput("msa_UI3"),
                            uiOutput("msa_UI4"),
                            fluidRow(
                              column(6,
                                     radioButtons(inputId = "msa_level",label = "Data Level",choices = c("Interval/Ratio"=1))#,"Nominal"=2))
                                     ),
                              column(6,
                                     conditionalPanel(condition = "input.msa_level == 1",
                                                      radioButtons(inputId = "msa_type",label = "What type of Study?",choices = c("Potential"=1,"Short-Term"=2,"Long-Term"=3)),
                                                      checkboxInput(inputId = "msa_details",label = "Info about study?")
                                     )
                              )
                              
                            ),#end fluid row
                            tags$hr(style="border-color: black;"),
                            fluidRow(
                            column(6,
                              checkboxInput(inputId = "msa_stand",label = "Check Linearity and Bias?",value = FALSE)
                            ),
                            column(6,
                              conditionalPanel(condition = "input.msa_stand==1",
                                             uiOutput("msa_UI5")
                                             )
                            )
                            ),
                            tags$hr(style="border-color: black;"),
                            #column(6,
                            conditionalPanel(condition = "input.msa_level == 1",
                                             radioButtons(inputId = "msa_calc",label = "Calculation",choices = c("Range"=1,"Standard Deviation"=2,"ANOVA"=3))
                                             ),
                            #)
                            #),
                            
                            conditionalPanel(condition = "input.msa_level == 1",
                                             fluidRow(column(2),column(8,
                                                                       tags$div(
                                                                         materialSwitch(inputId = "msa_sigmas",label = "5.15\U03c3",value = FALSE,inline = TRUE),
                                                                         tags$span("6\U03c3")
                                                                         )#end div
                                                                       ),#end column
                                                      column(2)
                                                      ),#end fluid row
                                             tags$div(
                                               materialSwitch(inputId = "msa_range_b",label = "Spec Range",value = FALSE,inline = TRUE),
                                               tags$span("Enter Specs")
                                               )#end div
                                             ),#end conditional
                              conditionalPanel("input.msa_range_b==1",
                                               fluidRow(
                                                 column(6,
                                                        numericInput(inputId = "msa_LSL",label = "LSL",value = NA)
                                                        ),
                                                 column(6,
                                                        numericInput(inputId = "msa_USL",label = "USL",value = NA)
                                                        )
                                               )
                                               
                              ),#end conditional
                              conditionalPanel("input.msa_range_b==0",
                                             numericInput(inputId = "msa_range",label = "Spec Range",value = NA)
                              ),#end conditional
                            HTML("<p><b>Optional:</b> Enter specs or a spec range, the average of the process and the standard devation of the process <i>without measurement error</i> to see if there is a danger of misclassification and to get the number of distinct categories and discrimination ratio for the process.</p>"),
                            fluidRow(
                              column(6,
                                     numericInput(inputId = "proc_mean",label = withMathJax("$\\mu_{process}$"),value = NULL)
                                     ),
                              column(6,
                                     numericInput(inputId = "proc_std",label = withMathJax("$\\sigma_{process}$"),value = NULL)
                                     )
                              )#end row
                            ),#end sidebarpanel
                          
                          mainPanel(
                            conditionalPanel(condition = "input.msa_level==1",
                                             h3("Measurement System Analysis - Interval/Ratio Data")
                            ),
                            conditionalPanel(condition = "input.msa_level==2",
                                             h3("Measurement System Analysis - Nominal Data")
                            ),
                            fluidRow(
                              column(7,
                                     materialSwitch(inputId = "msa_diagnostic",label = "Show Detailed Diagnostics?",value = FALSE,status = "success"),
                                     materialSwitch(inputId = "msa_graphs",label = "Show Graphs?",value = TRUE,status = "success")
                                     ),
                              column(3,
                                     numericInput(inputId = "conf_msa",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px")
                                     ),
                              column(2,
                                     numericInput(inputId = "deci_msa",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                     )
                            ),
                            
                            htmlOutput("msa_out"),
                            
                            conditionalPanel(condition = "input.msa_graphs==1",
                                             h4("Summary Graphs"),
                                             
                                             conditionalPanel(condition = "input.msa_type==3",
                                                              checkboxInput(inputId = "msd_lt_axis",label = "Match y axis?",value = TRUE),
                                                              uiOutput("lt_plot"),
                                                              fluidRow(
                                                                column(3, downloadButtonUI("msalt")),
                                                                column(6,
                                                                       tags$div(id="inline1", class="inline",
                                                                                downloadSelectUI("msalt")
                                                                       )
                                                                )
                                                              ),
                                                              tags$hr(style="border-color: black;"),
                                                              uiOutput("lt_plot_2"),
                                                              fluidRow(
                                                                column(3,
                                                                       downloadButtonUI('msa_lt_overall')),
                                                                column(6,tags$div(id='inline1', class='inline',downloadSelectUI('msa_lt_overall')
                                                                                  )
                                                                       )
                                                                ),
                                                              tags$hr(style='border-color: black;')
                                                              ),
                                             uiOutput("msa_cchart1"),
                                             fluidRow(
                                               column(3,
                                                      downloadButtonUI('msacchart1')),
                                               column(6,
                                                      tags$div(id='inline1', class='inline',downloadSelectUI('msacchart1')
                                                               )
                                                      )
                                               ),
                                             tags$hr(style='border-color: black;'),
                                             
                                             conditionalPanel(condition = "input.msa_stand==1",
                                              uiOutput("msa_linearity_2"),
                                              fluidRow(
                                                column(3, downloadButtonUI("linearityPlot")),
                                                column(3,
                                                       tags$div(id="inline1", class="inline",
                                                                downloadSelectUI("linearityPlot")
                                                                )
                                                       ),
                                                column(3,
                                                       checkboxInput(inputId = "msa_violin_line",label = "Add violins?",value = FALSE)
                                                ),
                                                column(3,
                                                       checkboxInput(inputId = "msa_jitter_line",label = "Add jitter?",value=FALSE)
                                                       ,)
                                              ),
                                              tags$hr(style="border-color: black;")
                                             ),
                                             plotOutput("msascatter"),
                                             fluidRow(
                                               column(3,
                                                      downloadButtonUI('msascatter')),
                                               column(6,
                                                      tags$div(id='inline1', class='inline',downloadSelectUI('msascatter')
                                                               )
                                                      )
                                               ),tags$hr(style='border-color: black;'),
                                             
                                             uiOutput("msa_cchart0"),
                                             fluidRow(
                                               column(3,
                                                      downloadButtonUI('msachart0')),
                                               column(3,
                                                      tags$div(id='inline1', class='inline',downloadSelectUI('msachart0')
                                                               ) 
                                                      ),
                                               column(2,
                                                      checkboxInput(inputId = "msa_violin",label = "Add violins?",value = FALSE)
                                                      ),
                                               column(2,
                                                      checkboxInput(inputId = "msa_jitter",label = "Add jitter?",value=FALSE)
                                                      ,),
                                               column(2,
                                                      checkboxInput(inputId = "norm_chart0",label = "Normalize?",value = FALSE)
                                                      )
                                               ),
                                             tags$hr(style='border-color: black;'),
                                             uiOutput("msa_box"),
                                             fluidRow(
                                               column(3,
                                                      downloadButtonUI('msabox')),
                                               column(3,
                                                      tags$div(id='inline1', class='inline',downloadSelectUI('msabox')
                                                               )
                                                      ),
                                               column(4),
                                               column(2,
                                                      checkboxInput(inputId = "norm_box",label = "Normalize?",value = FALSE)
                                               )
                                               ),
                                             tags$hr(style='border-color: black;'),
                                             plotOutput("msavarcompgraph"),
                                             fluidRow(
                                               column(3,
                                                      downloadButtonUI('msavarcompgraph')),
                                               column(6,
                                                      tags$div(id='inline1', class='inline',downloadSelectUI('msavarcompgraph')
                                                               )
                                                      )
                                               ),
                                             tags$hr(style='border-color: black;'),
                                             h4("Estimation of Specification Misclassification"),
                              plotOutput("msadangerzone"),
                              fluidRow(
                                column(3,
                                       downloadButtonUI('msadangerzone')),
                                column(6,
                                       tags$div(id='inline1', class='inline',downloadSelectUI('msadangerzone')
                                                )
                                       )
                                ),
                              tags$hr(style='border-color: black;')
                            )#end show graphs conditional
                            
                          )#end main panel
                        )#end sidebarlayout cont msa
                        ),#end tabpanel continuous msa un-comment starting here for discrete
                        tabPanel("Discrete",
                                 sidebarLayout(
                                   sidebarPanel(
                                     radioButtons(inputId = "msa_d_data_type",label = "How is the data configured?",choices = c("Columns are Appraisers"=1)),
                                     radioButtons(inputId = "msa_d_level",label = "Data Level",choices = c("Nominal or Ordinal"=1)),
                                     uiOutput("msa_d_1"),
                                     #checkboxInput(inputId = "msa_d_internal",label = "Internal Consistency?",value = FALSE),
                                     div(id="d_assessor0"),

                                     # uiOutput("msa_d_3"),
                                     checkboxInput(inputId = "msa_d_standard",label = "Set Standard?"),
                                     conditionalPanel(condition = "input.msa_d_standard==1",
                                       uiOutput("msa_d_standard_ID")
                                     ),
                                     radioButtons(inputId = "msa_d_type",label = "Assessor Selection",choices = c("Fixed (Light's)"=1))#,"Random (Fleiss')"
                                   ),#end sidebarpanel
                                   mainPanel(
                                     h3("Measurement System Analysis - Discrete Data"),
                                     fluidRow(
                                       column(7,
                                              #materialSwitch(inputId = "msa_diagnostic_d",label = "Show Detailed Diagnostics?",value = FALSE,status="success"),
                                              #materialSwitch(inputId = "msa_d_xtab",label = "Show Crosstabs?",value = FALSE,status = "success")
                                              ),
                                       column(3,
                                              numericInput(inputId = "conf_msa_d",label = "Confidence",value = .95,min = 0,max = 1,step = .05,width = "75px")
                                              ),
                                       column(2,
                                              numericInput(inputId = "deci_msa_d",label = "Decimals",value = 4,min = 0,max = 9,step = 1,width = "75px")
                                              )
                                              ),
                                     conditionalPanel(condition = "input.msa_d_xtab==1",
                                                      uiOutput("msa_xtab")
                                                      ),
                                     htmlOutput("msa_out_d")
                                   )#end main panel
                                 )#end sidebarlayout
                                    )#end tabpanel for discrete
                        )#end tabsetpanel MSA
                        )#end fluidpage
               
    )#end of navbarpage menu
               
)#end fluid page and UI

# Define server logic
server <- function(input, output, session) {
  
  #initialize session-wide variables
  plot_data_r<-reactive(0)
  att_plot_data_r<-reactive(0)
  scat_dat<-reactive(0)
  newfile<-F
  above_USL<-NULL
  below_LSL<-NULL
  #chart_complete<-FALSE
  plot_data_change<-0
  plot_data_change_att<-0
  msa_data_r<-reactive(0)
  sig_e<-reactiveVal(0)
  sig_rpt<-reactiveVal(0)
  sig_rpd<-reactiveVal(0)
  sig_part_app<-reactiveVal(0)
  sig_app<-reactiveVal(0)
  #msa_change<-reactive(0)
  msa_init<-reactiveVal(0)
  app_num<-reactiveVal(0)
  msa_d_assessor_num<-NULL
  dist_test_mvp_count<-0
  mann_whitney_test_count<-0
  aov_model <- reactiveVal(NULL)
  emm_model<-reactiveVal(NULL)
  emm_sig<-reactiveVal(NULL)
  model_mean_est<-reactiveVal(NULL)
  
  hist_height<-reactive(input$hist_height)
  hist_width<-reactive(input$hist_width)
  box_height<-reactive(input$box_height)
  box_width<-reactive(input$box_width)
  
  useSweetAlert()
  
  #Data Import ##########################################
  observeEvent(input$launch_modal, {
    req(input$from)
    import_modal(
      id = "modal_import",
      from = input$from,
      title = "Import data to be used in application"
    )
  })
  
  imported <- import_server("modal_import",
                            return_class = "data.frame",
                            read_fns = list(
                              dat = function(file) {
                                readr::read_delim(file = file)
                              }
                            )
  )
  
  output$name <- renderPrint({
    req(imported$name())
    imported$name()
  })
  
  output$data <- renderPrint({
    req(imported$data())
    #newfile$test<-T
    updateTabsetPanel(session, "eda_panel", selected= "eda_data_setup")
    updateTabsetPanel(session, "mw_anova", selected= "mw_su")
    updateCheckboxInput(inputId = "mult_data_choice",value = F)
    if (!is.null(updated_data())) {newfile<<-T}
    output<-imported$data()
    
    
    
    output
  })
  
  working_data<-reactive({#function to get the current working data
    
    data_imp<-imported$data()
    data_up<-updated_data()
    

    if(newfile==T || is.null(data_up)){
      output<-data_imp
      newfile<<-F
      #plot_data_r<-reactive(x = NULL)
    }else
    {output<-data_up}

    output
  })
  
  ######################################################
  
  ######Functions for select rename and convert variables
  updated_data <- update_variables_server(
    id = "vars",
    data = reactive(imported$data())
  )
  
  output$original <- renderPrint({
    imported$data()
  })
  output$original_str <- renderPrint({
    str(imported$data())
  })
  
  output$modified <- renderPrint({
    updated_data()
  })
  output$modified_str <- renderPrint({
    str(updated_data())
  })
  
  ##Dynamic filter##################################
  #####filter data
  data <- reactive({
    working_data()
  })
  
  
  res_filter <- filter_data_server(
    id = "filtering",
    data = data,
    widget_num = "slider",
    widget_date = "slider",
    label_na = "Missing"
  )
  
  observeEvent(res_filter$filtered(), {#if filtered, render the progress bar
    updateProgressBar(
      session = session, id = "pbar",
      value = nrow(res_filter$filtered()), total = nrow(data())
    )
  })
  
  output$w_data <- DT::renderDT({#renders the current working data
    res_filter$filtered()
  })
  
  output$table <- DT::renderDT({#renders the data as it would be if it is filtered
    res_filter$filtered()
  }, options = list(pageLength = 5))
  
  
  output$code_dplyr <- renderPrint({#renders the dplyr code as currently filtered
    res_filter$code()
  })
  output$code <- renderPrint({#renders the expression based on the current filter
    res_filter$expr()
  })
  
  output$res_str <- renderPrint({#renders the str of the filtered data
    str(res_filter$filtered())
  })
  ##############################################################################

    
    #Binomial Distribution###############################
    #reactive data and R functions to generate binomial plot and table
    data_bi<-reactive({
        n<-input$n_bi #total count
        p<-input$pi_bi #probability of failure
        R<-input$decimal_bi #decimals
        r_bi_table<-input$r_bi_table
        
        if(r_bi_table==FALSE){NULL}
        else{
        #Build the table
          req(n,p,R)
        binom_table<-table.dist.binomial(n=n, p=p) #make a table of this binomial distribution
        binom_table<-as.data.frame(binom_table)
        binom_table<-ro(binom_table,R)
        binom_table[binom_table$p.at.x>.000000001,] #filter low p
        #final table to send to data
        }
    })#end binomial data table
  
  output$bi_tails<-renderUI({#show tail probs when selecting R of interest
    n<-input$n_bi
    p<-input$pi_bi
    r_bi<-input$r_bi
    one_or_two<-input$one_or_two_bi
    r_l<-as.numeric(input$biUI1)
    r_u<-as.numeric(input$biUI2)
    low_inc<-input$bi_low_inc
    hi_inc<-input$bi_hi_inc
    R<-input$decimal_bi
    
    bi_table<-table.dist.binomial(n = n,p = p)
    
    if(r_bi==FALSE){output<-NULL}
    
    else{
      req(r_l,low_inc)
      if(low_inc==2){r_l=r_l-1}
      if(one_or_two==2){
        req(r_u,hi_inc)
        if(hi_inc==2){r_u=r_u+1}
      }
      output<-
        paste(
          "<table width= 100%; style='border-spacing: 10px;'><tr>",
          "<td>p(",r_l,") =",ro(bi_table$p.at.x[r_l+1],R),"</td>",
          "<td>p(",r_l," and below) =",ro(bi_table$eq.and.below[r_l+1],R),"</td>",
        "<td>p(",r_l," and above) =",ro(bi_table$eq.and.above[r_l+1],R),"</td></tr>"
        
                   )
      
      if(one_or_two==2){
        output<-paste(output,
                  paste(
                    "<tr><td>p(",r_u,") =",ro(bi_table$p.at.x[r_u+1],R),"</td>",
                    "<td>p(",r_u," and below) =",ro(bi_table$eq.and.below[r_u+1],R),"</td>",
                    "<td>p(",r_u," and above) =",ro(bi_table$eq.and.above[r_u+1],R),"</td></tr>",
                    "<tr><td style='background-color:",col_fill,";'></td>",
                    "<td>p(between) =",ro(1-bi_table$eq.and.below[r_l+1]-bi_table$eq.and.above[r_u+1],R),"</td><td>",paste0(r_l+1," \U2264 R \U2264 ",r_u-1),"</td></tr>",
                    "<tr><td style='background-color:",color[2],";'></td>",
                    "<td>p(tails) =",ro(bi_table$eq.and.below[r_l+1]+bi_table$eq.and.above[r_u+1],R),"</td><td>",paste0("R \U2264 ",r_l," + R \U2265 ",r_u),"</td></tr>"
                  )
                  )
                  
      }
       output<-paste(output,"</table><br><br>")     
    }
    
    HTML(output)
  })
    
    # Barplot of Binomial Probability Distribution
  
  output$biplot<-renderPlot(bi_plot(),height = 300)
  bi_width<-reactive(400*4)
  bi_height<-reactive(300*4)
  downloadServer('biplot', bi_plot,height = bi_height,width = bi_width)
  
    
    bi_plot<- reactive({
        n<-input$n_bi
        p<-input$pi_bi
        r_bi<-input$r_bi
        one_or_two<-input$one_or_two_bi
        r_l<-as.numeric(input$biUI1)
        r_u<-as.numeric(input$biUI2)
        low_inc<-input$bi_low_inc
        hi_inc<-input$bi_hi_inc
        
        #checks
        validate(need(n == round(n),"Enter integer for the sample size"),
                 need(p > 0 && p < 1,"p must be a proportion between 0 and 1")
        )
        rmin<-max(0,round((p*n)-4*((n*p*(1-p))^.5)))
        rmax<-round((p*n)+4*((n*p*(1-p))^.5))
        if(r_bi && one_or_two==1){
          validate(need(r_l == round(r_l),"Enter integer for the point of interest"))
          rmin<-min(rmin,r_l)
        } else if(r_bi && one_or_two==2) {
          validate(need(r_l == round(r_l),"Enter integer for the lower point of interest"),
                   need(r_u == round(r_u),"Enter integer for the upper point of interest"),
                   need(r_u > r_l,"The upper point of interest needs to be greater than the lower point of interest")
          )
          rmin<-min(rmin,r_l)
          rmax<-max(rmax,r_u)
        }
        
        r<-seq(rmin,rmax)
        p_r<-dbinom(r,n,p)
        
        plot_data<-data.frame(r=r,p=p_r)
        
        plot_data$r<-factor(plot_data$r)
        
        pl<-ggplot(data=plot_data,aes(x=r,y=p))+
          geom_col(fill=color[5],color=color[1])
        
        if(r_bi){
          if(one_or_two==1){
            if(low_inc==2){r_l=r_l-1}
            lower<-data.frame(r=r,p=p_r)
            lower[which(lower$r>r_l),2]<-0
            lower$r<-factor(lower$r)
            pl<-pl+
              geom_col(data=lower,aes(x=r,y=p),fill=color[2],color=color[1])
          } else{
            if(low_inc==2){r_l=r_l-1}
            if(hi_inc==2)(r_u=r_u+1)
            tails<-data.frame(r=r,p=p_r)
            tails[which(tails$r>r_l & tails$r<r_u),2]<-0
            tails$r<-factor(tails$r)
            pl<-pl+
              geom_col(data=tails,aes(x=r,y=p),fill=color[2],color=color[1])
          }
        }
        
        pl+theme(legend.position = "none")+
          ggtitle(paste("Binomial Distribution with \U03C0 = ",p,"and n =",n))+theme(plot.title = element_text(hjust = 0.5))+
          xlab("R")+
          ylab("p(R)")+
          scale_x_discrete(guide = guide_axis(check.overlap = TRUE))
        
        # bi_plot<-dbinom(x = 0:n, size = n, prob = p)
        # names(bi_plot)<-0:n
        # barplot(height = bi_plot,
        #         main=paste("Binomial Distribution with \U03C0 = ",p,"and n =",n),
        #         xlab = "R", ylab = "Probability at R",
        #         col = col_fill)
        
    })#end binomial reactive plot
    ####################################################
    
    #Hypergeometric#####################################
    
    #dynamic UI
    output$ui_hype1<-renderUI({
      one_or_two<-input$one_or_two_hype
      req(one_or_two)
      
      if(one_or_two==1){
        output<-numericInput(inputId = "hypeUI1",label = "X",value = 0,min = 0,step = 1,width = "75px")
      }
      if(one_or_two==2){
        output<-numericInput(inputId = "hypeUI1",label = "Lower X",value = 0,min = 0,step = 1,width = "75px")
      }
      output
    })
    output$ui_hype2<-renderUI({
      one_or_two<-input$one_or_two_hype
      req(one_or_two)
      
      if(one_or_two==1){
        output<-NULL
      }
      if(one_or_two==2){
        output<-numericInput(inputId = "hypeUI2",label = "Upper X",value = 4,min = 0,step = 1,width = "75px")
      }
      output
    })
    
    output$ui_hype3<-renderUI({#include lower R in calculation?
      enterX<-input$x_hype
      if(!enterX){output<-NULL}
      
      else{
        output<- radioButtons(inputId = "hype_low_inc",label = "Include X?",choices=c("\U2264"=1,"<"=2))
      }
      
      output
    })
    
    output$ui_hype4<-renderUI({#include upper R in calculation?
      one_or_two<-input$one_or_two_hype
      req(one_or_two)
      if(one_or_two == 1){output<-NULL}
      
      else{
        output<- radioButtons(inputId = "hype_hi_inc",label = "Include X?",choices=c("\U2265"=1,">"=2))
      }
      
      output
    })
    
    #plot
    output$hypeplot<-renderPlot(hype_plot(),height = 300)
    hype_width<-reactive(400*4)
    hype_height<-reactive(300*4)
    downloadServer('hypeplot', hype_plot,height = hype_height,width = hype_width)
    
    
    hype_plot<- reactive({
      k<-input$k_hype
      N<-input$N_hype
      p<-input$pi_hype
      x_hype<-input$x_hype
      one_or_two<-input$one_or_two_hype
      x_l<-as.numeric(input$hypeUI1)
      x_u<-as.numeric(input$hypeUI2)
      low_inc<-input$hype_low_inc
      hi_inc<-input$hype_hi_inc
      
      #checks
      validate(need(N == round(N),"Enter integer for the population size"),
               need(p > 0 && p < 1,"\U03C0 must be a proportion between 0 and 1")
      )
      m<-ceiling(x = p*N)
      xmin<-max(0,round((p*k)-4*((k*p*(1-p))^.5)))
      xmax<-min(m,k+1)
      if(x_hype && one_or_two==1){
        validate(need(x_l == round(x_l),"Enter integer for the point of interest"))
        xmin<-min(xmin,x_l)
      } else if(x_hype && one_or_two==2) {
        validate(need(x_l == round(x_l),"Enter integer for the lower point of interest"),
                 need(x_u == round(x_u),"Enter integer for the upper point of interest"),
                 need(x_u > x_l,"The upper point of interest needs to be greater than the lower point of interest")
        )
        xmin<-min(xmin,x_l)
        xmax<-max(xmax,x_u)
      }
      
      x<-seq(xmin,xmax)
      p_x<-dhyper(x = x, m = m, n = N-m, k = k)
      
      plot_data<-data.frame(x=x,p=p_x)
      
      plot_data$x<-factor(plot_data$x)
      
      pl<-ggplot(data=plot_data,aes(x=x,y=p))+
        geom_col(fill=color[5],color=color[1])
      
      if(x_hype){
        if(one_or_two==1){
          if(low_inc==2){x_l=x_l-1}
          lower<-data.frame(x=x,p=p_x)
          lower[which(lower$x>x_l),2]<-0
          lower$x<-factor(lower$x)
          pl<-pl+
            geom_col(data=lower,aes(x=x,y=p),fill=color[2],color=color[1])
        } else{
          if(low_inc==2){x_l=x_l-1}
          if(hi_inc==2)(x_u=x_u+1)
          tails<-data.frame(x=x,p=p_x)
          tails[which(tails$x>x_l & tails$x<x_u),2]<-0
          tails$x<-factor(tails$x)
          pl<-pl+
            geom_col(data=tails,aes(x=x,y=p),fill=color[2],color=color[1])
        }
      }
      
      pl+theme(legend.position = "none")+
        ggtitle(paste("Hypergeometric Distribution with \U03C0 = ",p,", m =",m,"\n k = ",k," and N = ",N))+theme(plot.title = element_text(hjust = 0.5))+
        xlab("X")+
        ylab("p(X)")+
        scale_x_discrete(guide = guide_axis(check.overlap = TRUE))

    })#end hyper reactive plot
    
    output$hype_tails<-renderUI({#show tail probs when selecting X of interest
      k<-input$k_hype
      p<-input$pi_hype
      N<-input$N_hype
      x_hype<-input$x_hype
      one_or_two<-input$one_or_two_hype
      x_l<-as.numeric(input$hypeUI1)
      x_u<-as.numeric(input$hypeUI2)
      low_inc<-input$hype_low_inc
      hi_inc<-input$hype_hi_inc
      R<-input$decimal_hype
      
      if(x_hype==FALSE){output<-NULL}
      
      else{
        m=ceiling(x = p*N)
        hype_table<-table.dist.hypergeometric(pop.success.count = m,total.count = N,sample.size = k)
        req(x_l,low_inc)
        if(low_inc==2){x_l=x_l-1}
        if(one_or_two==2){
          req(x_u,hi_inc)
          if(hi_inc==2){x_u=x_u+1}
        }
        output<-
          paste(
            "<table width= 100%; style='border-spacing: 10px;'><tr>",
            "<td>p(",x_l,") =",ro(hype_table$p.at.x[x_l+1],R),"</td>",
            "<td>p(",x_l," and below) =",ro(hype_table$eq.and.below[x_l+1],R),"</td>",
            "<td>p(",x_l," and above) =",ro(hype_table$eq.and.above[x_l+1],R),"</td></tr>"
          )
        
        if(one_or_two==2){
          output<-paste(output,
                        paste(
                          "<tr><td>p(",x_u,") =",ro(hype_table$p.at.x[x_u+1],R),"</td>",
                          "<td>p(",x_u," and below) =",ro(hype_table$eq.and.below[x_u+1],R),"</td>",
                          "<td>p(",x_u," and above) =",ro(hype_table$eq.and.above[x_u+1],R),"</td></tr>",
                          "<tr><td style='background-color:",col_fill,";'></td>",
                          "<td>p(between) =",ro(1-hype_table$eq.and.below[x_l+1]-hype_table$eq.and.above[x_u+1],R),"</td><td>",paste0(x_l+1," \U2264 X \U2264 ",x_u-1),"</td></tr>",
                          "<tr><td style='background-color:",color[2],";'></td>",
                          "<td>p(tails) =",ro(hype_table$eq.and.below[x_l+1]+hype_table$eq.and.above[x_u+1],R),"</td><td>",paste0("X \U2264 ",x_l," + X \U2265 ",x_u),"</td></tr>"
                        )
          )
          
        }
        output<-paste(output,"</table><br><br>")     
      }
      
      HTML(output)
    })
    
    #reactive data and R functions to generate hypergeometric plot and table
    data_hype<-reactive({
      k<-input$k_hype #sample size
      N<-input$N_hype
      p<-input$pi_hype #probability of failure
      R<-input$decimal_hype #decimals
      hype_table_show<-input$hype_table_show#logical show table
      
      if(hype_table_show==FALSE){NULL}
      else{
        #Build the table
        m<-ceiling(N*p)
        output<-table.dist.hypergeometric(pop.success.count = m,total.count = N,sample.size = k) #make a table of this hypergeometric distribution
        output<-as.data.frame(output)
        output<-ro(output,R)
        output<-output[output$p.at.x>.000000001,] #filter low p
        #final table to send to data
        output
      }
    })#end hyper data table
    
    
    ####################################################
    
    #Geometric##########################################
    
    #dynamic UI
    output$ui_geom1<-renderUI({
      #one_or_two<-input$one_or_two_geom
      low_inc<-input$geom_low_inc
      req(low_inc)
      
      if(low_inc==1){xmin=1} else{xmin=0}
      
      output<-numericInput(inputId = "geomUI1",label = "X",value = xmin,min = xmin,step = 1,width = "75px")
      
      output
    })
    # output$ui_geom2<-renderUI({
    #   one_or_two<-input$one_or_two_geom
    #   
    #   if(one_or_two==1){
    #     output<-NULL
    #   }
    #   if(one_or_two==2){
    #     output<-numericInput(inputId = "geomUI2",label = "Upper X",value = 4,min = 0,step = 1,width = "75px")
    #   }
    #   output
    # })
    
    output$ui_geom3<-renderUI({#show x?
      radioButtons(inputId = "geom_low_inc",label = "Select p()",choices=c("p(First Occurrence is X)"=1,"p(X Non-Occurrences)"=2))
      
    })
    
    # output$ui_geom4<-renderUI({#include upper R in calculation?
    #   one_or_two<-input$one_or_two_geom
    #   if(one_or_two == 1){output<-NULL}
    #   
    #   else{
    #     output<- radioButtons(inputId = "geom_hi_inc",label = "Include X?",choices=c("\U2265"=1,">"=2))
    #   }
    #   
    #   output
    # })
    
    #plot
    output$geomplot<-renderPlot(geom_plot(),height = 300)
    geom_width<-reactive(400*4)
    geom_height<-reactive(300*4)
    downloadServer('geomplot', geom_plot,height = geom_height,width = geom_width)
    
    
    geom_plot<- reactive({
      #m<-input$m_hype
      #k<-input$k_hype
      xmax<-input$xmax_geom
      p<-input$pi_geom
      x_geom<-input$x_geom
      #one_or_two<-input$one_or_two_geom
      x_l<-as.numeric(input$geomUI1)
      #x_u<-as.numeric(input$geomUI2)
      low_inc<-input$geom_low_inc
      #hi_inc<-input$geom_hi_inc
      
      #checks
      req(low_inc)
      validate(need(xmax == round(xmax),"Enter integer for the max X"),
               need(xmax>=0,"Enter a non-negative number for the max X"),
               need(p > 0 && p < 1,"\U03C0 must be a proportion between 0 and 1")
      )
      #m<-ceiling(x = p*N)
      if(low_inc==1){xmin<-1} else {xmin<-0}
      
      x<-seq(xmin,xmax)
      
      if(low_inc==1){
        p_x<-dgeom(x = x-1,prob = p)
      } else {
        p_x<-dgeom(x = x,prob = p)
      }
      
      plot_data<-data.frame(x=x,p=p_x)
      
      plot_data$x<-factor(plot_data$x)
      
      leg_names<-c("Non-occurrence"=color[2],"Occurrence"=color[3],"Future"=color[5])
      
      pl<-ggplot(data=plot_data,aes(x=x,y=p))+
        theme(legend.position = "none")+
        scale_fill_manual(values=leg_names)+
        #geom_col(fill=color[5],color=color[1])
        geom_col(aes(fill="Future"),color=color[1])
      
       if(x_geom){
         validate(need(x_l == round(x_l),"Enter integer for X of interest"),
                  need(x_l <= xmax,"Enter X below the max X to display"),
                  need(x_l>=0,"Enter a non-negative X")
                  )
         pl<-pl+
           theme(legend.position = "bottom")+
           labs(fill="")
         if(low_inc==1){
           sel_x<-seq(xmin,x_l)
           sel_y<-dgeom(x = sel_x-1,prob = p)
         } else {
           sel_x<-seq(xmin,x_l)
           sel_y<-dgeom(x = sel_x,prob = p)
         }
         selected<-data.frame(x=sel_x,p=sel_y)
         selected$x<-factor(selected$x)
         #sel_x<-data.frame(x=x_l+1,p=dgeom(x = x_l,prob = p))#+1 is to account for the zero in the factor data set
         pl<-pl+
           geom_col(data=selected,aes(x=x,y=p,fill="Non-occurrence"))
         
         if(low_inc==1){
           pl<-pl+
             geom_col(data=selected[x_l,],aes(x=x,y=p,fill="Occurrence"))
         } else {
           temp<-data.frame(x=x_l+2,p=dgeom(x_l+1,p))
           pl<-pl+
             geom_col(data=temp,aes(x=x,y=p,fill="Occurrence"))
         }
           
         
       }
      
      pl+
        ggtitle(paste("Geometric Distribution with \U03C0 = ",p))+
        theme(plot.title = element_text(hjust = 0.5))+
        xlab("X")+
        ylab("p(X)")+
        scale_x_discrete(guide = guide_axis(check.overlap = TRUE))
        
      
    })#end hyper reactive plot
    
    output$geom_tails<-renderUI({#show tail probs when selecting X of interest
      #k<-input$k_hype
      p<-input$pi_geom
      xmax<-input$xmax_geom
      x_geom<-input$x_geom
      #one_or_two<-input$one_or_two_geom
      x_l<-as.numeric(input$geomUI1)#X
      #x_u<-as.numeric(input$geomUI2)
      low_inc<-input$geom_low_inc#which form - 1 is x-1, 2 is x
      #hi_inc<-input$geom_hi_inc
      R<-input$decimal_geom
      
      if(x_geom==FALSE){output<-NULL}
      
      else{
        validate(need(x_l == round(x_l),"Enter integer for X of interest"))
        req(low_inc)
        output<-paste(
          "<table width= 100%; style='border-spacing: 10px;'>"
          )
        if(low_inc==1){#probability that the first occurrence is X
          output<-paste0(output,
            "<tr><td style='background-color:",color[2],"'</td>",
            "<td style='text-align: left'>p(First Occurrence on or before ",x_l,") = ",ro(pgeom(q = x_l-1,prob = p,lower.tail = TRUE),R),"</td></tr>" ,           
            "<tr><td style='background-color:",color[3],"'</td>",
            "<td style='text-align: left'>p(First Occurrence is ",x_l,") = ",ro(dgeom(x = x_l-1,prob = p),R),"</td></tr>",
            "<tr><td style='background-color:",color[5],"'</td>",
            "<td style='text-align: left'>p(First Occurrence on or after ",x_l,") = ",ro(pgeom(q = x_l-2,prob = p,lower.tail = FALSE),R),"</td></tr>"
          )
          
        } else {#probability no occurrences until X
          output<-paste0(
            #"<p>p(No Occurrence Until ",x_l,") =",ro(dgeom(x = x_l,prob = p),R),"</p>"
            output,
            "<tr><td style='background-color:",color[2],"'</td>",
            "<td style='text-align: left'>p(No Occurrence on or before ",x_l,") = ",ro(pgeom(q = x_l,prob = p,lower.tail = TRUE),R),"</td></tr>" ,           
            "<tr><td style='background-color:",color[3],"'</td>",
            "<td style='text-align: left'>p(First Occurrence at ",x_l,") = ",ro(dgeom(x = x_l,prob = p),R),"</td></tr>",
            "<tr><td style='background-color:",color[5],"'</td>",
            "<td style='text-align: left'>p(No Occurrence on or after ",x_l,") = ",ro(pgeom(q = x_l-1,prob = p,lower.tail = FALSE),R),"</td></tr>"
          )
          }
         output<-paste(output,"</table>")
      
      HTML(output) 
      }
      
      
    })
    
    #reactive data and R functions to generate hypergeometric plot and table
    data_geom<-reactive({
      xmax<-input$xmax_geom
      p<-input$pi_geom #probability of failure
      R<-input$decimal_geom #decimals
      geom_table_show<-input$geom_table_show#logical show table
      low_inc<-input$geom_low_inc#which form - 1 is x-1, 2 is x
      
      if(geom_table_show==FALSE){NULL}
      else{
        #Build the table
        #m<-ceiling(N*p)
        output<-table.dist.geometric(p = p,max.x = xmax) #make a table of this geometric distribution
        output<-as.data.frame(output)
        if(low_inc==1){output$x<-output$x+1}
        row.names(output)<-output$x
        output<-ro(output,R)
        output<-output[output$p.at.x>.000000001,] #filter low p
        #final table to send to data
        output
      }
    })#end geom data table
    
    
    ####################################################
    
    
    
    #Poisson Distribution################################
    #reactive data and R functions to create a Poisson plot and table
    data_pois<- reactive({
        lambda<-input$lambda_po #count parameter
        R<-input$decimal_po
        r_po_table<-input$r_po_table
        
        if(r_po_table==FALSE){NULL}
        else{
        #Build the table
        poisson_table<-table.dist.poisson(lambda=lambda) #make the Poisson table
        poisson_table <- as.data.frame(poisson_table)
        poisson_table<-ro(poisson_table,R)
        poisson_table[poisson_table$p.at.x>.000000001,] #filter low p
        }

    })#end reactive for table
    
    output$po_tails<-renderUI({#show tail probs when selecting R of interest
      lambda<-input$lambda_po #count parameter
      r_po<-input$r_po
      one_or_two<-input$one_or_two_po
      r_l<-as.numeric(input$poUI1)
      r_u<-as.numeric(input$poUI2)
      R<-input$decimal_po
      
      po_table<-table.dist.poisson(lambda = lambda)
      
      if(r_po==FALSE){output<-NULL}
      
      else{
        low_inc<-input$po_low_inc
        req(r_l,low_inc)
        if(low_inc==2){r_l=r_l-1}
        output<-
          paste(
            "<table width= 100%; style='border-spacing: 10px;'><tr>",
            "<td>p(",r_l,") =",ro(po_table$p.at.x[r_l+1],R),"</td>",
            "<td>p(",r_l," and below) =",ro(po_table$eq.and.below[r_l+1],R),"</td>",
            "<td>p(",r_l," and above) =",ro(po_table$eq.and.above[r_l+1],R),"</td></tr>"
            
          )
        
        if(one_or_two==2){
          hi_inc<-input$po_hi_inc
          req(r_u,hi_inc)
          if(hi_inc==2){r_u=r_u+1}
          output<-paste(output,
                        paste(
                          "<tr><td>p(",r_u,") =",ro(po_table$p.at.x[r_u+1],R),"</td>",
                          "<td>p(",r_u," and below) =",ro(po_table$eq.and.below[r_u+1],R),"</td>",
                          "<td>p(",r_u," and above) =",ro(po_table$eq.and.above[r_u+1],R),"</td></tr>",
                          "<tr><td style='background-color:",col_fill,";'></td>",
                          "<td>p(between) =",ro(1-po_table$eq.and.below[r_l+1]-po_table$eq.and.above[r_u+1],R),"</td><td>",paste0(r_l+1," \U2264 X \U2264 ",r_u-1),"</td></tr>",
                          "<tr><td style='background-color:",color[2],";'></td>",
                          "<td>p(tails) =",ro(po_table$eq.and.below[r_l+1]+po_table$eq.and.above[r_u+1],R),"</td><td>",paste0("X \U2264 ",r_l," + X \U2265 ",r_u),"</td></tr>"
                        )
          )
          
        }
        output<-paste(output,"</table><br><br>")     
      }
      
      HTML(output)
    })
    
    output$poisplot<-renderPlot(pois_plot(),height = 300)
    pois_width<-reactive(400*4)
    pois_height<-reactive(300*4)
    downloadServer('poisplot', pois_plot,height = pois_height,width = pois_width)
    
    pois_plot<-reactive({
        lambda<-input$lambda_po
        r_po<-input$r_po
        one_or_two<-input$one_or_two_po
        r_l<-as.numeric(input$poUI1)
        r_u<-as.numeric(input$poUI2)
        R<-input$decimal_po
        
        min_po<-max(0,as.integer(lambda-6*(lambda)^.5))
        max_po<-as.integer(lambda+6*(lambda)^.5)
        
        data<-data.frame(R=min_po:max_po,pdf=dpois(x = min_po:max_po,lambda = lambda))
        
        pl<-ggplot(data = data,aes(x=factor(R),y = pdf))+
          geom_col(fill=col_fill,col="black")
        
        if(r_po==TRUE){
          low_inc<-input$po_low_inc
          req(low_inc)
          if(low_inc==2){r_l=r_l-1}
          validate(need(r_l>=min_po,"X out of range of the graph!"),
                   need(r_l<=max_po,"X out of range of the graph!"))
          
          data_l<-data.frame(R=min_po:r_l,pdf=dpois(x=min_po:r_l,lambda = lambda))
          pl<-pl+geom_col(data=data_l,aes(x=factor(R),y = pdf),fill=color[2])
        }
        
        if(one_or_two==2 && r_po==TRUE){
          hi_inc<-input$po_hi_inc
          req(hi_inc)
          if(hi_inc==2){r_u=r_u+1}
          validate(need(r_l<r_u,"Make sure your lower point of interest is in fact lower than your upper point of interest!"))
          validate(need(r_l<=max_po && r_u<=max_po,"X out of range of the graph!"))
          data_u<-data.frame(R=r_u:max_po,pdf=dpois(x=r_u:max_po,lambda = lambda))
          pl<-pl+geom_col(data=data_u,aes(x=factor(R),y = pdf),fill=color[2])
        }
        
        pl+theme(legend.position = "none")+
          ggtitle(paste("Poisson Distribution with \U03BB = ",lambda))+theme(plot.title = element_text(hjust = 0.5))+
          xlab("X")+
          ylab("p(X)")+
          scale_x_discrete(guide = guide_axis(check.overlap = TRUE))
        
    })#end Poisson reactive plot
    ####################################################

    #Normal Distribution################################
    #reactive data and R functions to create a normal plot
    
    #dynamic UI elements for normal distribution graphic
    output$lowertail_norm<-renderUI({
      tails<-input$tails_norm
      req(tails)
      
      if(tails==1){
        output<-numericInput(inputId = "tail1_norm",
                     label = "Point of Interest",
                     value = 9,
                     width = "100px")
      } else{
        output<-numericInput(inputId = "tail1_norm",
                     label = "Lower Tail",
                     value = 9,
                     width = "100px")
      }
      output
    })
    
    output$uppertail_norm<-renderUI({
      tails<-input$tails_norm
      req(tails)
      
      if(tails==1){
        output<-NULL
      } else{
        output<-numericInput(inputId = "tail2_norm",
                     label = "Upper Tail",
                     value = 11,
                     width = "100px")
      }
      output
    })
    
    output$inorout_norm<-renderUI({
      tails<-input$tails_norm
      req(tails)
      
      if(tails==1){
        radioButtons(inputId = "in_or_out_norm",
                     label = "Area above or below?",
                     choices = c("Above"=1,"Below"=2))
      } else{
        radioButtons(inputId = "in_or_out_norm",
                     label = "Area between or outside of points?",
                     choices = c("Inside"=1,"Outside"=2))
      }
    })
    
    
    ###Allows downloading of distribution
    output$normplot<-renderPlot(norm_plot(),height = 300)
    norm_height<-reactive(300*4)
    norm_width<-reactive(400*4)
    downloadServer("normplot", norm_plot,width = norm_width,height = norm_height)
    ###
    
    
    norm_plot<-reactive({
      mu<-input$mu_norm
      sigma<-input$sigma_norm
      tails<-input$tails_norm
      R<-input$decimal_norm
      data_label<-input$data_label_norm
      X1<- input$tail1_norm #First point of interest
      X2<- input$tail2_norm #second point of interest
      in_or_out<-input$in_or_out_norm#change to above or below for one tail
      
      validate(need(mu,"Need a population mean"),
               need(sigma,"Need a population standard deviation"),
               need(X1,"Need X"),
               need(R,"Need the number of decimal places")
               )
      
      
      if(tails==2){
        validate(need(X2,"Need second tail"),
                 need(X1<=X2,"X1 needs to be less than X2"),
                 need(in_or_out,"You shoudln't see this error")
                 )
        }
      xmin<-min(X1,mu-4*sigma)
      if(tails==1){
        xmax<-max(X1,mu+4*sigma)
      } else{
        xmax<-max(X1,X2,mu+4*sigma)
      }
      
      area<-0
      
      p<-ggplot()
      
      if(!is.null(X1)){
        #x1n<-ceiling(512*X1/(xmax-xmin))#fix this
        
        if(in_or_out==1 && tails==2){
          p<-p+
            stat_function(geom="area",fun=dnorm,args=list(mean=mu,sd=sigma),xlim=c(X1,X2),fill=color[2])
          area<-area+pnorm(q = X1,mean = mu,sd = sigma,lower.tail = F)-pnorm(X2,mu,sigma,lower.tail = F)
        }
        else if(in_or_out==1 && tails==1){
          area<-area+pnorm(q = X1,mean = mu,sd = sigma,lower.tail = F)
          p<-p+
            stat_function(geom="area",fun=dnorm,args=list(mean=mu,sd=sigma),xlim=c(X1,mu+4*sigma),fill=color[2])
        }
        else if(in_or_out==2){
          area<-area+pnorm(q = X1,mean = mu,sd = sigma)
          p<-p+
            stat_function(geom="area",fun=dnorm,args=list(mean=mu,sd=sigma),xlim=c(mu-4*sigma,X1),fill=color[2])
        }
        p<-p+
          geom_vline(xintercept=X1,color=color[3],linetype=5)
      }
      
      if(!is.null(X2) && tails==2){
        
        if(in_or_out==2){
          area<-area+pnorm(X2,mu,sigma,lower.tail = F)
          p<-p+
            stat_function(geom="area",fun=dnorm,args=list(mean=mu,sd=sigma),xlim=c(X2,mu+4*sigma),fill=color[2])
        }
        p<-p+
          geom_vline(xintercept=X2,color=color[3],linetype=5)
      }
      
      
      if(data_label){
        if(!is.null(X1)){
          p<- p+
            geom_label(aes(x=X1,y=Inf),label=paste0("X1 = ",X1),vjust="inward")
          }
        if(tails==2){
          p<- p+
            geom_label(aes(x=X2,y=Inf),label=paste0("X2 = ",X2),vjust="inward")
        }
        
      }
      
      p<-p+
        ggtitle(paste0("A normal distribution with \U03BC = ",mu," and \U03C3 = ",sigma),subtitle=paste0("Shaded area = ",ro(area,R)))+
        geom_function(fun=dnorm,args=list(mean=mu,sd=sigma))+
        xlim(xmin,xmax)+
        geom_vline(xintercept=mu,color=color[4])+
        ylab("Density")+
        xlab("X")
      
      
      p
    })
    
    
    #reactive data for numeric results
    data_norm <- reactive({
        #X<- input$tail_norm #Point of interest
        mu<-input$mu_norm
        sigma<-input$sigma_norm
        tails<-input$tails_norm
        R<-input$decimal_norm
        X1<- input$tail1_norm #First point of interest
        X2<-input$tail2_norm #second point of interest
        in_or_out<-input$in_or_out_norm
        req(mu,sigma,tails,R,X1,in_or_out)
        if(tails==2){req(X2)}
        
        if (tails==1){    
            #build the table with areas above and below X1
            x_or_lower<-pnorm(q=X1, mean=mu, sd =sigma, lower.tail = T)#X or lower
            x_or_higher<-pnorm(q=X1, mean=mu, sd =sigma, lower.tail = F)#X or higher
            #create the table
            data_labels <- c("\U00B5 = ","\U03C3 = ","X = ","Area above X","Area below X")
            results <- c(mu,sigma,X1,x_or_higher,x_or_lower)
            norm_table <- data.frame(data_labels,results)
            ro(norm_table,R)
        } else#end if
        
        if(tails==2){
            #areas inside of points
            if(in_or_out==1){
                #build the table with areas inside of X1 and X2
                between_x1_x2<-pnorm(q=max(X1,X2), mean=mu, sd =sigma, lower.tail = T)-pnorm(q=min(X1,X2), mean=mu, sd=sigma, lower.tail = T)#Between X and X2
                #create the table
                data_labels <- c("\U00B5 = ","\U03C3 = ","Lower X = ","Upper X = ","Area between tails =")
                results <- c(mu,sigma,X1,X2,between_x1_x2)
                norm_table <- data.frame(data_labels,results)
                ro(norm_table,R)
            }#end inside if
            else {
                #area outside points
                if(in_or_out==2){
                    outside_x1_x2<-1-(pnorm(q=max(X1,X2), mean=mu, sd =sigma, lower.tail = T)-pnorm(q=min(X1,X2), mean=mu, sd=sigma, lower.tail = T))#Outside of X and X2
                    data_labels <- c("\U00B5 = ","\U03C3 = ","Lower X = ","Upper X = ","Area of tails =")
                    results <- c(mu,sigma,X1,X2,outside_x1_x2)
                    norm_table <- data.frame(data_labels,results)
                    ro(norm_table,R)
                }#end outside if
            }
        }
    })#end normal results table
    ####################################################
    
    #Exponential Distribution###########################
    output$expplot<-renderPlot(exp_plot(),height = 300)
    exp_width<-reactive(400*4)
    exp_height<-reactive(300*4)
    downloadServer('expplot', exp_plot,height = exp_height,width = exp_width)

    exp_plot <- reactive({
        X_min <- input$X_min_exp
        mu <- input$mu_exp
        X <- input$tail_exp
        upper_or_lower <- input$upper_or_lower_exp
        R<-input$decimal_exp
        tailu_exp<-input$tailu_exp
        interest<-input$exp_interest
        tails_exp<-input$tails_exp
        
        req(X)
        
        max_exp<-5*mu
        
        data<-data.frame(x=X_min:max_exp,pdf=dexp(x = X_min:max_exp,rate = 1/mu))
        
        #limits<-data.frame(x=c(X_min,max_exp))
        
        pl<-ggplot(data = data,aes(x=x,y=pdf))+
          geom_line()
        
        if(tails_exp==1){
          if(interest==1){#draw lower tail
            data_l<-data.frame(x=X_min:X,pdf=dexp(x = X_min:X,rate = 1/mu))
            pl<-pl+
              geom_area(data=data_l,aes(x=x,y=pdf),fill=color[2],color=color[1])
          }
          if(interest==2){#draw upper tail
            data_u<-data.frame(x=X:max_exp,pdf=dexp(x = X:max_exp,rate = 1/mu))
            pl<-pl+
              geom_area(data=data_u,aes(x=x,y=pdf),fill=color[2],color=color[1])
          }
        }
        if(tails_exp==2){
          req(tailu_exp)
          if(interest==1){#draw inner section
            data_in<-data.frame(x=X:tailu_exp,pdf=dexp(x = X:tailu_exp,rate = 1/mu))
            pl<-pl+
              geom_area(data=data_in,aes(x=x,y=pdf),fill=color[2],color=color[1])+
              geom_vline(aes(xintercept=tailu_exp),color=col_plot_line,size=1,linetype=2)
          }
          if(interest==2){#draw outer sections
            data_l<-data.frame(x=X_min:X,pdf=dexp(x = X_min:X,rate = 1/mu))
            data_u<-data.frame(x=tailu_exp:max_exp,pdf=dexp(x = tailu_exp:max_exp,rate = 1/mu))
            pl<-pl+
              geom_area(data=data_u,aes(x=x,y=pdf),fill=color[2],color=color[1])+
              geom_area(data=data_l,aes(x=x,y=pdf),fill=color[2],color=color[1])+
              geom_vline(aes(xintercept=tailu_exp),color=col_plot_line,size=1,linetype=2)
          }
        }
        
        pl+theme(legend.position = "none")+
          ggtitle(paste("Exponential Distribution with \U00B5 = ",mu,"and Xmin = ",X_min))+theme(plot.title = element_text(hjust = 0.5))+
          geom_vline(aes(xintercept=mu),color=color[4])+
          geom_vline(aes(xintercept=X),color=color[3],linetype=2)+
          xlab("X")+
          ylab("pdf(X)")+
          scale_x_continuous(guide = guide_axis(check.overlap = TRUE))
        
        
    })#end exponential plot
    
    #reactive data for numeric results
    data_exp <-reactive({
        X_min <- input$X_min_exp
        mu <- input$mu_exp
        X <- input$tail_exp
        upper_or_lower <- input$upper_or_lower_exp
        R<-input$decimal_exp
        tailu_exp<-input$tailu_exp
        interest<-input$exp_interest
        tails_exp<-input$tails_exp
        
        req(X)
        
        if(tails_exp==1){
        x_and_higher<-pexp.low(q = X, low = X_min, mean = mu, lower.tail = F)#Upper tail
        x_and_lower<-pexp.low(q = X, low = X_min, mean = mu, lower.tail = T)#Lower tail
        
        #build the table with areas above and below X.exp
        #create the table
        data_labels <- c("\U00B5 = ","Xmin = ","X = ","Area above X","Area below X")
        results <- c(mu,X_min,X,x_and_higher,x_and_lower)
        exp_table <- data.frame(data_labels,results)
        output<-ro(exp_table,R)
        }
        if(tails_exp==2){
          req(tailu_exp)
          x_and_higher<-pexp.low(q = tailu_exp, low = X_min, mean = mu, lower.tail = F)#Upper tail
          x_and_lower<-pexp.low(q = X, low = X_min, mean = mu, lower.tail = T)#Lower tail
          
          #build the table with areas above and below X.exp
          #create the table
          data_labels <- c("\U00B5 = ","Xmin = ","X = ","Area above Upper Tail","Area below Lower Tail","Area Inside Tails")
          results <- c(mu,X_min,X,x_and_higher,x_and_lower,1-(x_and_higher+x_and_lower))
          exp_table <- data.frame(data_labels,results)
          output<-ro(exp_table,R)
        }
        output
    })#end exponential table results
    

    ####################################################

    #F Distribution#####################################
    #reactive data and R functions to create an f plot
    
    output$lowertail_f<-renderUI({
      tails<-input$tails_f
      req(tails)
      
      if(tails==1){
        output<-numericInput(inputId = "tail1_f",
                             label = "Point of Interest",
                             value = .5,
                             width = "100px")
      } else{
        output<-numericInput(inputId = "tail1_f",
                             label = "Lower Tail",
                             value = .5,
                             width = "100px")
      }
      output
    })
    
    output$uppertail_f<-renderUI({
      tails<-input$tails_f
      req(tails)
      
      if(tails==1){
        output<-NULL
      } else{
        output<-numericInput(inputId = "tail2_f",
                             label = "Upper Tail",
                             value = 3,
                             width = "100px")
      }
      output
    })
    
    output$inorout_f<-renderUI({
      tails<-input$tails_f
      req(tails)
      
      if(tails==1){
        radioButtons(inputId = "in_or_out_f",
                     label = "Area above or below?",
                     choices = c("Above"=1,"Below"=2))
      } else{
        radioButtons(inputId = "in_or_out_f",
                     label = "Area between or outside of points?",
                     choices = c("Inside"=1,"Outside"=2))
      }
    })
    
    ###Allows downloading of distribution
    output$fplot<-renderPlot(f_plot(),height = 300)
    f_height<-reactive(300*4)
    f_width<-reactive(400*4)
    downloadServer("fplot", f_plot,width = f_width,height = f_height)
    ###
    
    
    f_plot<-reactive({
      df1<-input$df1_f
      df2<-input$df2_f
      tails<-input$tails_f
      R<-input$decimal_f
      data_label<-input$data_label_f
      X1<-input$tail1_f
      X2<-input$tail2_f
      in_or_out<-input$in_or_out_f
      
      validate(need(df1,"Need df1"),
               need(df2,"Need df2"),
               need(X1,"Need X"),
               need(R,"Need the number of decimal places")
      )


      if(tails==2){
        validate(need(X2,"Need second tail"),
                 need(X1<=X2,"X1 needs to be less than X2"),
                 need(in_or_out,"You shoudln't see this error")
        )
      }
      
      dmode<-((df1-2)/(df1))*(df2/(df2+2))
      
      d<-1
      xmax<-dmode
      while(d>.001){
        xmax<-xmax+.01
        d<-df(xmax,df1 = df1,df2 = df2)
      }
      d<-1
      xmin<-dmode
      while(d>0.001){
        xmin<-xmin-.01
        d<-df(xmin,df1 = df1,df2=df2)
      }
      if(xmin<0) xmin=0
      xmin<-min(X1,xmin)
      if(tails==1){
        xmax<-max(X1,xmax)
      } else{
        xmax<-max(X1,X2,xmax)
      }
      
      area<-0
      
      p<-ggplot()
      
      if(!is.null(X1)){
        if(in_or_out==1 && tails==2){
          p<-p+
            stat_function(geom="area",fun=df,args=list(df1=df1,df2=df2),xlim=c(X1,X2),fill=color[2])
          area<-area+pf(q = X1,df1=df1,df2=df2,lower.tail = F)-pf(X2,df1=df1,df2=df2,lower.tail = F)
        }
        else if(in_or_out==1 && tails==1){
          area<-area+pf(q = X1,df1=df1,df2=df2,lower.tail = F)
          p<-p+
            stat_function(geom="area",fun=df,args=list(df1=df1,df2=df2),xlim=c(X1,xmax),fill=color[2])
        }
        else if(in_or_out==2){
          area<-area+pf(q = X1,df1=df1,df2=df2)
          p<-p+
            stat_function(geom="area",fun=df,args=list(df1=df1,df2=df2),xlim=c(xmin,X1),fill=color[2])
        }
        p<-p+
          geom_vline(xintercept=X1,color=color[3],linetype=5)
      }
      
      if(!is.null(X2) && tails==2){
        
        if(in_or_out==2){
          area<-area+pf(X2,df1=df1,df2=df2,lower.tail = F)
          p<-p+
            stat_function(geom="area",fun=df,args=list(df1=df1,df2=df2),xlim=c(X2,xmax),fill=color[2])
        }
        p<-p+
          geom_vline(xintercept=X2,color=color[3],linetype=5)
      }
      
      
      if(data_label){
        if(!is.null(X1)){
          p<- p+
            geom_label(aes(x=X1,y=Inf),label=paste0("X1 = ",X1),vjust="inward")
        }
        if(tails==2){
          p<- p+
            geom_label(aes(x=X2,y=Inf),label=paste0("X2 = ",X2),vjust="inward")
        }
        
      }
      
      p<-p+
        ggtitle(paste0("An F-distribution with \U03BC = ",df1," and \U03C3 = ",df2," degrees of freedom"),subtitle=paste0("Shaded area = ",ro(area,R)))+
        geom_function(fun=df,args=list(df1=df1,df2=df2),n=512,color=color[1])+
        xlim(xmin,xmax)+
        #geom_vline(xintercept=mu,color=color[4])+
        ylab("Density")+
        xlab("F")
      
      
      p
    })
    
    # plot_f<- reactive({
    #     X<- input$tail_f #Point of interest
    #     df1<-input$df1_f
    #     df2<-input$df2_f
    #     tails<-input$tails_f
    #     R<-input$decimal_f
    #     data_label<-input$data_label_f
    #     X1<-input$tail1_f
    #     X2<-input$tail2_f
    # 
    #     
    #     #graph the f distribution
    #     x=seq(.01,qf(p = .999,df1 = df1,df2 = df2),length=200)
    #     min.x=min(x)
    #     max.x=max(x)
    #     y=df(x = x,df1 = df1,df2 = df2)
    #     max.y=max(y)
    #     plot(x,y,
    #          type="l",
    #          ylab = "PDF of the F distribution",lwd=1,main = paste("An F distribution with df1 = ",df1," and df2 = ",df2),
    #          col=col_plot_line)
    #     
    #     #One Tail
    #     if (tails==1){    
    #         
    #         #calculate tail areas
    #         x_or_lower<-pf(q=X, df1 = df1,df2 = df2, lower.tail = T)#X or lower
    #         x_or_higher<-pf(q=X, df1 = df1,df2 = df2, lower.tail = F)#X or higher
    #         
    #         #Shade the lower tail area
    #         x=seq(min.x,X,length=100)
    #         y=df(x = x,df1 = df1,df2 = df2)
    #         polygon(c(min.x,x,X),c(0,y,0),col=col_fill_highlight)#error here when df1 = 1
    #         abline(v=X,lty=2, col=col_point_of_interest_line)
    #         abline(v=1, col=col_mean_line,lwd=3)
    #         if(data_label==T){
    #             text(x = max.x,y=max.y,labels=paste("X = ",ro(X,R)),pos=2)
    #             text(x=max.x, y=max.y*.9, labels=paste("Area above tail = ",ro(x_or_higher,R)), pos = 2)
    #             text(x=max.x, y=max.y*.8, labels=paste("Tail Area = ",ro(x_or_lower,R)), pos = 2)
    #         }#end if label
    #     } else#end if one tail
    #         
    #         if (tails==2){
    #             
    #                 #Area outside of X
    #                     #calculate the outer area
    #                     outside_x1_x2<-1-(pf(q=max(X1,X2), df1 = df1, df2 = df2, lower.tail = T)-pf(q=min(X1,X2), df1 = df1,df2 = df2 , lower.tail = T))#Outside of X and X2
    #                     # Shade the lower tail area
    #                     x=seq(min.x,min(X1,X2),length=100)
    #                     y=df(x = x,df1 = df1,df2 = df2)
    #                     polygon(c(min.x,x,min(X1,X2)),c(0,y,0),col=col_fill_highlight)
    #                     
    #                     # Shade the upper tail area
    #                     x=seq(max(X1,X2),max.x,length=100)
    #                     y=df(x = x,df1 = df1, df2 = df2)
    #                     polygon(c(max(X1,X2),x,max.x),c(0,y,0),col=col_fill_highlight)
    #                     
    #                     # Add line at mean
    #                     abline(v=1, col=col_mean_line,lwd=3)
    #                     
    #                     #Add line at points of interest
    #                     abline(v=X1,lty=2,col=col_point_of_interest_line)
    #                     abline(v=X2,lty=2,col=col_point_of_interest_line)
    #                     if(data_label==T){
    #                         text(x = max.x,y=max.y,labels=paste("X1 = ",ro(X1,R)),pos=2)
    #                         text(x = max.x,y=max.y*.9,labels=paste("X2 = ",ro(X2,R)),pos=2)
    #                         text(x=max.x, y=max.y*.8,labels=paste("Area = ",ro(outside_x1_x2,R)),pos=2)
    #                     }#end text
    # 
    #         }#end if for two tails
    # })#end normal plot
    
    #reactive data for numeric results
    data_f <- reactive({
        #X<- input$tail_f #Point of interest
        df1<-input$df1_f
        df2<-input$df2_f
        tails<-input$tails_f
        R<-input$decimal_f
        data_label<-input$data_label_f
        X1<-input$tail1_f
        X2<-input$tail2_f
        
        req(X1,df1,df2,tails,R)
        
        if (tails==1){    
            #build the table with areas above and below X1
            x_or_lower<-pf(q=X1, df1 = df1,df2 = df2, lower.tail = T)#X or lower
            x_or_higher<-pf(q=X1, df1 = df1,df2 = df2, lower.tail = F)#X or higher
            #create the table
            data_labels <- c("df1 = ","df2 = ","X = ","Area above X","Area below X")
            results <- c(df1,df2,X1,x_or_higher,x_or_lower)
            f_table <- data.frame(data_labels,results)
            ro(f_table,R)
        } else#end if
            
            if(tails==2){
              req(X2)
                    #area insdie/outside points
                        outside_x1_x2<-1-(pf(q=max(X1,X2), df1 = df1, df2 = df2, lower.tail = T)-pf(q=min(X1,X2), df1 = df1,df2 = df2 , lower.tail = T))#Outside of X and X2
                        inside_x1_x2<-1-outside_x1_x2 #pf(q = X1,df1 = df1,df2 = df2,lower.tail = FALSE)-pf(q = X2,df1 = df1,df2 = df2,lower.tail = FALSE)
                        data_labels <- c("df1 = ","df2 = ","Lower X = ","Upper X = ","Area outside = ","Area inside = ")
                        results <- c(df1,df2,X1,X2,outside_x1_x2,inside_x1_x2)
                        f_table <- data.frame(data_labels,results)
                        ro(f_table,R)
            }
    })#end f results table
    ####################################################
    
    #Sample Size Calculations###########################
    s_size_results<-reactive({
      
      alt<-input$one_or_two_size
      sample_calc<-input$sample_calc
      power_s<-input$power_s
      s_size_alpha<-input$s_size_alpha
      s_size_beta<-input$s_size_beta
      s_size_n<-input$s_size_n
      s_sizeUI1<-input$s_sizeUI1
      s_sizeUI2<-input$s_sizeUI2
      s_sizeUI3<-input$s_sizeUI3
      s_sizeUI4<-input$s_sizeUI4
      sample_size_type<-input$sample_size_type
      
      req(sample_size_type,sample_calc,s_sizeUI1,s_sizeUI2)
      
      if(s_size_alpha==0 || s_size_beta==0){return(NULL)}
      
      if(sample_size_type==5){sample_calc<-15}
      #if(sample_size_type==4){sample_calc<-16}
      
      #if(one_or_two_size==1){alt="greater"}else {alt="two.sided"}
      
      #calculate sample size
      if(power_s==F){
        
        if(sample_calc==1){
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.z.onesample(effect.size = s_sizeUI2,variance = s_sizeUI1^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==3){
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.z.twosample.independent(effect.size = s_sizeUI2,variance = s_sizeUI1^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==5){
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.t.onesample(effect.size = s_sizeUI2,variance = s_sizeUI1^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==6){
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.t.test.twosample.independent.equal.variance(mean.g1 = 0, mean.g2 = s_sizeUI2, variance.est.g1 = s_sizeUI1^2,variance.est.g2 = s_sizeUI1^2,alpha = s_size_alpha,beta = s_size_beta,null.hypothesis.difference = 0,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==7){
          req(s_sizeUI4)
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.t.test.twosample.independent.unequal.variance(mean.g1 = 0, mean.g2 = s_sizeUI2, variance.est.g1 = s_sizeUI1^2,variance.est.g2 = s_sizeUI4^2,alpha = s_size_alpha,beta = s_size_beta,null.hypothesis.difference = 0,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==8){
          if(alt=="less"){alt<-"greater"}
          s_size_out<-sample.size.mean.t.twosample.dependent.dbar(effect.size = s_sizeUI2,variance.diff = s_sizeUI1^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==9){
          req(s_sizeUI4)
          s_size_out<-sample.size.variance.onesample(null.hypothesis.variance = s_sizeUI1^2,alternative.hypothesis.variance = s_sizeUI4^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==10){
          req(s_sizeUI4)
          s_size_out<-sample.size.variance.twosample.independent(variance.estimate.g1 = s_sizeUI1^2,variance.estimate.g2 = s_sizeUI4^2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==11){
          s_size_out<-sample.size.cor.pearson.r.onesample(null.hypothesis.correlation = s_sizeUI1,alternative.hypothesis.correlation = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==12){
          s_size_out<-sample.size.proportion.test.onesample.approximate(null.hypothesis.proportion = s_sizeUI1,alternative.hypothesis.proportion = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==13){
          s_size_out<-sample.size.proportion.test.onesample.exact(null.hypothesis.proportion = s_sizeUI1,alternative.hypothesis.proportion = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==14){
          s_size_out<-sample.size.proportion.test.twosample.approximate(proportion.g1 = s_sizeUI1,proportion.g2 = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==15){
          req(s_sizeUI4)
          s_size_out<-power.anova.test(groups = s_sizeUI4,n = NULL,between.var = var(c(rep(0,s_sizeUI4-2),-.5*s_sizeUI2,.5*s_sizeUI2)),within.var = s_sizeUI1^2,sig.level = s_size_alpha,power = 1-s_size_beta)
        }
        if(sample_calc==16){#Poisson rate one sample - exact
          req(s_sizeUI1,s_sizeUI2,s_size_alpha,s_size_beta,alt)
          s_size_out<-sample.size.count.poisson.onesample.exact(lambda_0 = s_sizeUI1,lambda_1 = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt)
        }
        if(sample_calc==17){#Poisson rate one sample - approximate
          s_size_out<-sample.size.count.poisson.onesample.approximate(lambda.null.hypothesis = s_sizeUI1,lambda.alternative.hypothesis = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt,details = T,power.from.actual = T)
        }
        if(sample_calc==18){#Poisson rate two sample
          s_size_out<-sample.size.count.poisson.twosample.approximate(lambda_1 = s_sizeUI1,lambda_2 = s_sizeUI2,alpha = s_size_alpha,beta = s_size_beta,alternative = alt)
        }
        
      }#end sample size calcs
      
      
      #calculate power
      else if (power_s==T){
        req(s_size_n)
        if(sample_calc==1){
          if(alt=="less"){s_sizeUI2=-s_sizeUI2}
          s_size_out<-power.mean.z.onesample(sample.size = s_size_n,effect.size = s_sizeUI2,variance = s_sizeUI1^2,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==3){#no two sample z power function in lolcat?
          
          #two-tailed
          if(alt=="two.sided"){
            z_beta=sqrt( (s_size_n*s_sizeUI2^2) / (2*s_sizeUI1^2) )-qnorm(1-(s_size_alpha/2))
            s_size_out<-pnorm(z_beta)
          }
          if(alt != "two.sided"){
            z_beta=sqrt( (s_size_n*s_sizeUI2^2) / (2*s_sizeUI1^2) )-qnorm(1-(s_size_alpha))
            s_size_out<-pnorm(z_beta)
          }
        }
        if(sample_calc==5){
          if(alt=="less"){s_sizeUI2=-s_sizeUI2}
          s_size_out<-power.mean.t.onesample(sample.size = s_size_n,effect.size = s_sizeUI2,variance.est = s_sizeUI1^2,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==6){
          if(alt=="less"){s_sizeUI2=-s_sizeUI2}
          s_size_out<-power.mean.t.test.twosample.independent.equal.variance(mean.g1 = 0,mean.g2 = s_sizeUI2,variance.est.g1 = s_sizeUI1^2,variance.est.g2 = s_sizeUI1^2,sample.size.g1 = s_size_n,sample.size.g2 = s_sizeUI3,null.hypothesis.difference = 0,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==7){
          if(alt=="less"){s_sizeUI2=-s_sizeUI2}
          s_size_out<-power.mean.t.test.twosample.independent.unequal.variance(mean.g1 = 0,mean.g2 = s_sizeUI2,variance.est.g1 = s_sizeUI1^2,variance.est.g2 = s_sizeUI4^2,sample.size.g1 = s_size_n,sample.size.g2 = s_sizeUI3,null.hypothesis.difference = 0,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==8){
          if(alt=="less"){s_sizeUI2=-s_sizeUI2}
          s_size_out<-power.mean.t.onesample(sample.size = s_size_n,effect.size = s_sizeUI2,variance.est = s_sizeUI1^2,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==9){
          s_size_out<-power.variance.onesample(sample.size = s_size_n,null.hypothesis.variance = s_sizeUI1^2,alternative.hypothesis.variance = s_sizeUI4^2,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==10){
          s_size_out<-power.variance.twosample.independent(variance.estimate.g1 = s_sizeUI1^2,variance.estimate.g2 = s_sizeUI4^2,sample.size.g1 = s_size_n,sample.size.g2 = s_sizeUI3,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==11){
          s_size_out<-power.cor.pearson.r.onesample(sample.size = s_size_n,null.hypothesis.correlation = s_sizeUI1,alternative.hypothesis.correlation = s_sizeUI2,alpha = s_size_alpha,alternative = alt,details = T)
        }
        if(sample_calc==12){
          s_size_out<-power.proportion.test.onesample.approximate(null.hypothesis.proportion = s_sizeUI1,alternative.hypothesis.proportion = s_sizeUI2,alpha = s_size_alpha,sample.size = s_size_n,alternative = alt,details = T)
        }
        if(sample_calc==13){
          s_size_out<-power.proportion.test.onesample.exact(null.hypothesis.proportion = s_sizeUI1,alternative.hypothesis.proportion = s_sizeUI2,alpha = s_size_alpha,sample.size = s_size_n,alternative = alt,details = T)
        }
        if(sample_calc==14){
          s_size_out<-power.proportion.test.twosample.approximate(proportion.g1 = s_sizeUI1,proportion.g2 = s_sizeUI2,alpha = s_size_alpha,sample.size = s_size_n,alternative = alt,details = T)
        }
        if(sample_calc==15){
          s_size_out<-power.anova.test(groups = s_sizeUI4,n = s_size_n,between.var = var(c(rep(0,s_sizeUI4-2),-.5*s_sizeUI2,.5*s_sizeUI2)),within.var = s_sizeUI1^2,sig.level = s_size_alpha,power = NULL)
        }
        if(sample_calc==16){
          req(s_size_n,s_sizeUI1,s_sizeUI2,s_size_alpha,alt)
          s_size_out<-power.count.poisson.onesample.exact(n = s_size_n,lambda_0 = s_sizeUI1,lambda_1 = s_sizeUI2,alpha = s_size_alpha,alternative = alt)
        }
        if(sample_calc==17){
          s_size_out<-power.count.poisson.onesample.approximate(sample.size = s_size_n,lambda.null.hypothesis = s_sizeUI1,lambda.alternative.hypothesis = s_sizeUI2,alpha = s_size_alpha,alternative = alt,details=T)
        }
        if(sample_calc==18){
          s_size_out<-power.count.poisson.twosample.approximate(n1 = s_size_n,n2 = s_sizeUI3,lambda_1 = s_sizeUI1,lambda_2 = s_sizeUI2,alpha = s_size_alpha,alternative = alt)
        }
        
        
      }#end power calcs
      
      
      #test<-s_size_out$sample.size
      #test
      ro(s_size_out,4)
    })
    
    
    ####################################################
    
    #EDA########################################################################
    
    #create the object we will be working with not needed now
    file_in_memory<-reactive({
        
        inFile<-input$file1
        
        req(inFile)
        
        working.stiff<- read.csv(input$file1$datapath,
                                 header = input$header,
                                 sep = input$sep,
                                 quote = input$quote)
        
        working.stiff
    })
  
    ####################################################
    
    #Mean tests Output##################################
    mean_out <- reactive({
         conf<-input$conf
        UI1<- input$md_UI1
        UI2<- input$md_UI2
        UI3<- input$md_UI3
        UI4<- input$md_UI4
        UI5<- input$md_UI5
        UI6<- input$md_UI6
        md_alt<-input$md_alt
        t_type<-input$t_type
        
        md_test_num<-md_test_num()
        
        req(md_test_num,UI1,UI2,UI3,conf,md_alt)
        
        results<-NULL
        
        #one sample z
        if(md_test_num==1){
                results<-z.test.onesample.simple(sample.mean = UI1,
                                        known.population.variance = UI3^2,
                                        sample.size = UI5,
                                        null.hypothesis.mean = UI2,
                                        alternative = md_alt,
                                        conf.level = conf)
                
                }#end one samp z
        else if(md_test_num==2){#one-sample t
              results<- t.test.onesample.simple(sample.mean = UI1,
                                                sample.variance = UI3^2,
                                                sample.size = UI5,
                                                null.hypothesis.mean = UI2,
                                                alternative = md_alt,
                                                conf.level = conf)
              } #end 1 samp t
                
        else if(md_test_num==3){#one sample var test
                  results <- variance.test.onesample.simple(sample.variance = UI1^2,
                                                            sample.size = UI3,
                                                            null.hypothesis.variance = UI2^2,
                                                            alternative = md_alt,
                                                            conf.level = conf)
                }  #end one-sample var test
        
        else if(md_test_num==4){#two-sample z indep
          req(UI4,UI5,UI6)
                  results<- mean.z.test.twosample.independent.simple(sample.mean.g1 = UI1,
                                                                     variance.g1 = UI3^2,
                                                                     sample.size.g1 = UI5,
                                                                     sample.mean.g2 = UI2,
                                                                     variance.g2 = UI4^2,
                                                                     sample.size.g2 = UI6,
                                                                     null.hypothesis.difference = 0,
                                                                     alternative = md_alt,
                                                                     g1.details = T,
                                                                     g2.details = T,
                                                                     conf.level = conf)
                } #end of 2 samp z indep
        else if(md_test_num==5){#2 samp t indep
          req(UI4,UI5,UI6,t_type,md_alt,conf)
                  results <- t.test.twosample.independent.simple(sample.mean.g1 = UI1,
                                                                 sample.variance.g1 = UI3^2,
                                                                 sample.size.g1 = UI5,
                                                                 sample.mean.g2 = UI2,
                                                                 sample.variance.g2 = UI4^2,
                                                                 sample.size.g2 = UI6,
                                                                 null.hypothesis.difference = 0,
                                                                 assume.equal.variances = t_type,
                                                                 alternative = md_alt,
                                                                 conf.level = conf,
                                                                 var.test.conf.level = conf,
                                                                 var.test.details = T,
                                                                 g1.details = T,
                                                                 g2.details =  T
                                                                   )

                } #end of 2 samp t independent

                    if(md_test_num==6){results<-"Not Applicable"}#two sample z dep
        else if(md_test_num==7){#two sample t dep
          dep_t_type<-input$md_t_dep_type_stat
          req(dep_t_type)
          if(dep_t_type==1){
            req(UI5)
            results<-t.test.twosample.dependent.simple.dbar(pair.differences.mean = UI1,
                                                            pair.differences.variance = UI3^2,
                                                            sample.size = UI5,
                                                            null.hypothesis.difference = UI2,
                                                            alternative = md_alt,
                                                            conf.level = conf)
            
          } else if (dep_t_type==2){
                      req(UI4,UI5,UI6,md_alt,conf)
                    results <- 
                      t.test.twosample.dependent.simple.meandiff(sample.mean.g1 = UI1,
                                                                          sample.variance.g1 = UI3^2,
                                                                          sample.size = UI5,
                                                                          sample.mean.g2 = UI2,
                                                                          sample.variance.g2 = UI4^2,
                                                                          rho.estimate = UI6,
                                                                          null.hypothesis.difference = 0,#error need to get a number here from UI?
                                                                          assume.equal.variances = "yes",#no Welch test on dependent
                                                                          alternative = md_alt,
                                                                          conf.level = conf,
                                                                          var.test.conf.level = conf,
                                                                          var.test.details = T,
                                                                          g1.details = T,
                                                                          g2.details =  T)

          }
 
              }#end of 2 samp t dep
        
        ro(results,R)
        
    })#end mean_out reactive

    #dispersion tests output - needed for data means/dispersion testing - place above mean output and use to determine which test to use
    
    #Mean/dispersion plot - this would be nice to have####
    mean_plot_out <- reactive({
      
    })#end mean plot out
    ###################################################
    
    output$md_t_dep_stat<-renderUI({
      test_num<-md_test_num()
      req(test_num)
      NULL
      if(test_num==7){
        radioButtons(inputId = "md_t_dep_type_stat",label = "Dependency by",choices = c("Nature $(\\bar{D})$"=1,"Design (Mean Difference)"=2))
      }
    })
    
    output$md_sig_known <- renderUI({
      req(input$one_or_two)
      dep_or_indep <-input$dep_or_indep
      req(dep_or_indep)# is it a dependent test
      
      if(dep_or_indep == 1){
        output <- radioButtons(inputId = "sigma_known",
                               label = "Is \U03C3 definitively known?",
                               choices = c("No, use t"=1,"Yes, use z"=2)
        )
      } else {
        output <- radioButtons(inputId = "sigma_known",
                               label = "Is \U03C3 definitively known?",
                               choices = c("No, use t"=1)
        )
      }
      output
    })
    
    output$md_t_type_stat<-renderUI({
      test_num<-md_test_num()
      req(test_num)
      NULL
      if(test_num==5){
        radioButtons(inputId = "t_type",label = "Select:",choices = c(
          "Welch (recommended)"="no",
          "Student (unknown but equal variance)"="yes",
          "Choose based on variance test (not recommended)"="auto"
        ))
      }
      # else if(test_num==7){#two-sample dependent
      #   type<-input$md_t_dep_type_stat
      #   req(type)
      #   if(type==2){
      #     radioButtons(inputId = "t_type",label = "Select:",choices = c(
      #       "Welch (recommended)"="no",
      #       "Student (unknown but equal variance)"="yes",
      #       "Choose based on variance test (not recommended)"="auto"
      #     ))
      #   }
      # }
    })
    
    output$md_t_dep<-renderUI({
      test_num<-data_md_test_num()
      req(test_num)
      NULL
      if(test_num==7){
        radioButtons(inputId = "md_t_dep_type",label = "Dependency by",choices = c("Nature $(\\bar{D})$"=1,"Design (Mean Difference)"=2))
      }
    })
    
    output$md_t_type<-renderUI({
      test_num<-data_md_test_num()
      req(test_num)
      NULL
      if(test_num==5){
        radioButtons(inputId = "t_type_dat",label = "Select:",choices = c(
          "Welch (recommended)"="no",
          "Student (unknown but equal variance)"="yes",
          "Choose based on variance test (not recommended)"="auto"
        ))
      } 
      # else if(test_num==7){#two-sample dependent
      #   type<-input$md_t_dep_type
      #   req(type)
      #   if(type==2){
      #     radioButtons(inputId = "t_type_dat",label = "Select:",choices = c(
      #     "Welch (recommended)"="no",
      #     "Fisher (unknown but equal variance)"="yes",
      #     "Choose based on variance test (not recommended)"="auto"
      #   ))
      #   }
      # }
    })
    
    
    #Mean and dispersion for data######################
    m_d_data_out <- reactive({
      R<-input$decimal_m_d_d
      conf<-input$conf_m_d_data
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      md_data_UI1<-input$md_data_UI1
      md_data_UI2<-input$md_data_UI2
      md_data_UI3<-input$md_data_UI3
      md_data_UI4<-input$md_data_UI4
      one_or_two_md_data<-input$one_or_two_md_data
      t_type<-input$t_type_dat
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      test_num<-data_md_test_num()
      
      num_col_selected<-length(md_data_selected_columns)
      
      req(type,test_num,one_or_two_md_data,data)

      
      if(type==1){
      req(md_data_selected_columns)
      #one-sample z
      if(test_num==1){
        mean_data<-na.omit(data[,as.numeric(md_data_selected_columns[1])])
        results<-mean.z.test.onesample(x = mean_data,known.population.variance = md_data_UI3^2,null.hypothesis.mean = md_data_UI2,alternative = one_or_two_md_data,conf.level = conf)
      }#else
      #one-sample t
        if(test_num==2){
          req(md_data_UI2,one_or_two_md_data,conf)
          mean_data<-na.omit(data[,as.numeric(md_data_selected_columns[1])])
          results<-mean.t.test.onesample(x = mean_data,null.hypothesis.mean = md_data_UI2,alternative = one_or_two_md_data,conf.level = conf)
        } #else
          
      #one-sample var
          if(test_num==3){
            var_data<-na.omit(data[,as.numeric(md_data_selected_columns[1])])
            results<-variance.test.onesample(g1 = var_data,null.hypothesis.variance = md_data_UI2^2,alternative = one_or_two_md_data,conf.level = conf)
          }#else
            
      #two-sample z indep
            if(test_num==4){
              req(md_data_selected_columns)
              mean_data_1<-na.omit(data[,as.numeric(md_data_selected_columns[1])])
              mean_data_2<-na.omit(data[,as.numeric(md_data_selected_columns[2])])
              
              #only simple version at this point
              
              mean_g1=mean(mean_data_1)
              var_g1=var(mean_data_1)
              n_g1=length(mean_data_1[!is.na(mean_data_1)])

              mean_g2=mean(mean_data_2)
              var_g2=var(mean_data_2)
              n_g2=length(mean_data_2[!is.na(mean_data_1)])
              
              
              results<-mean.z.test.twosample.independent.simple(sample.mean.g1 = mean_g1,
                                                                variance.g1 = var_g1,
                                                                sample.size.g1 = n_g1,
                                                                sample.mean.g2 = mean_g2,
                                                                variance.g2 = var_g2,
                                                                sample.size.g2 = n_g2,
                                                                null.hypothesis.difference = 0,
                                                                alternative = one_or_two_md_data,
                                                                conf.level = conf,
                                                                g1.details = T,
                                                                g2.details = T)
              
              
                
            }#else
              
      #two-sample t indep
              if(test_num==5){
                req(md_data_selected_columns,t_type)
                mean_data_1<-na.omit(data[,as.numeric(md_data_selected_columns[1])])
                mean_data_2<-na.omit(data[,as.numeric(md_data_selected_columns[2])])
                
                results<-t.test.twosample.independent(g1 = mean_data_1,g2 = mean_data_2,alternative = one_or_two_md_data,conf.level = conf,assume.equal.variances=t_type)
                  
              }else
                
      #two-sample z dep
                if(test_num==6){
                 
                  
                  results<-"No test available"
                  
                }else
                  
      #two-sample t dep
                  if(test_num==7){
                    type_dep_t<-input$md_t_dep_type#1 is d-bar 2 is mean diff
                    req(md_data_selected_columns,type_dep_t)
                    mean_data_1<-data[,as.numeric(md_data_selected_columns[1])]
                    mean_data_2<-data[,as.numeric(md_data_selected_columns[2])]
                    mean_data<-na.omit(data.frame(mean_data_1,mean_data_2))
                    validate(need(length(mean_data$mean_data_1)==length(mean_data$mean_data_2),"Data columns need to be the same length"))
                    
                    if(type_dep_t==1){#d-bar
                    results<-t.test.twosample.dependent(x1 = mean_data$mean_data_2,#this does not give the option to use the Welch t-test since it is really a one-samp t-test
                                                        x2 = mean_data$mean_data_1,
                                                        null.hypothesis.difference = md_data_UI2,
                                                        alternative = one_or_two_md_data,
                                                        conf.level = conf)

                    } else if(type_dep_t==2){
                    mean_g1<-mean(x = mean_data$mean_data_1)
                    mean_g2<-mean(x = mean_data$mean_data_2)
                    var_g1<-var(mean_data$mean_data_1)
                    var_g2<-var(mean_data$mean_data_2)
                    n_data<-length(mean_data$mean_data_1)
                    rho_est<-cor(mean_data$mean_data_1,mean_data$mean_data_2)
                    
                    results<-t.test.twosample.dependent.simple.meandiff(sample.mean.g1 = mean_g1,
                                                                        sample.mean.g2 = mean_g2,
                                                                        sample.variance.g1 = var_g1,
                                                                        sample.variance.g2 = var_g2,
                                                                        sample.size = n_data,
                                                                        rho.estimate = rho_est,
                                                                        alternative = one_or_two_md_data,
                                                                        conf.level =conf,
                                                                        assume.equal.variances = "yes")#no welch test for dependent
                    }

                  }
      }#end type==1 
      
      if(type==2){#reference
        #two-sample z indep
        if(test_num==4){
          req(data_col,ref_col,g1_num,g2_num)
          #only simple version at this point
         
          mean_g1=mean(na.omit(data[,data_col][which(data[ref_col]==g1_num)]))
          var_g1=var(na.omit(data[,data_col][which(data[ref_col]==g1_num)]))
          n_g1=length(na.omit(data[,data_col][which(data[ref_col]==g1_num)]))
          mean_g2=mean(na.omit(data[,data_col][which(data[ref_col]==g2_num)]))
          var_g2=var(na.omit(data[,data_col][which(data[ref_col]==g2_num)]))
          n_g2=length(na.omit(data[,data_col][which(data[ref_col]==g2_num)]))
          
          results<-mean.z.test.twosample.independent.simple(sample.mean.g1 = mean_g1,
                                                            variance.g1 = var_g1,
                                                            sample.size.g1 = n_g1,
                                                            sample.mean.g2 = mean_g2,
                                                            variance.g2 = var_g2,
                                                            sample.size.g2 = n_g2,
                                                            null.hypothesis.difference = 0,
                                                            alternative = one_or_two_md_data,
                                                            conf.level = conf,
                                                            g1.details = T,
                                                            g2.details = T)
        }#else
        
        #two-sample t indep
        if(test_num==5){
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num | data[ref_col]==g2_num)]
          temp2<-data[,ref_col][which(data[ref_col]==g1_num | data[ref_col]==g2_num)]
          temp<-(data.frame(temp1,temp2))
          results<- t.test.twosample.independent.fx(fx = temp1~temp2,data = temp,assume.equal.variances=t_type,alternative=one_or_two_md_data)
          
          
        }else
          
          #two-sample z dep
          if(test_num==6){
            
            results<-"No test available"
            
            # req(data_col,ref_col,g1_num ,g2_num)
            # temp1<-data[,data_col][which(data[ref_col]==g1_num)]
            # temp2<-data[,data_col][which(data[ref_col]==g2_num)]
            # temp<-na.omit(data.frame(g1=temp1,g2=temp2))
            # g1_mean<-mean(temp$g1)
            # g2_mean<-mean(temp$g2)
            # g1_sd<-sd(temp$g1)
            # g2_sd<-sd(temp$g2)
            # rho<-cor(temp$g1,temp$g2)
            # 
            # results<- mean.z
            
            
          }else
            
            #two-sample t dep
            if(test_num==7){
              type_dep_t<-input$md_t_dep_type#1 is d-bar 2 is mean diff
              req(data_col,ref_col,g1_num ,g2_num,type_dep_t)
              temp1<-data[,data_col][which(data[ref_col]==g1_num)]
              temp2<-data[,data_col][which(data[ref_col]==g2_num)]
              if(length(temp1)!= length(temp2)){
                return("Need equal length groups for dependent test")
              }
              temp<-na.omit(data.frame(g1=temp1,g2=temp2))
              
              if(type_dep_t==1){
                req(md_data_UI2)
                results<-t.test.twosample.dependent(x1 = temp$g1,#this does not give the option to use the Welch t-test since it is really a one-samp t-test
                                                    x2 = temp$g2,
                                                    null.hypothesis.difference = md_data_UI2,
                                                    alternative = one_or_two_md_data,
                                                    conf.level = conf)
                
              } else if (type_dep_t==2){
                g1_mean<-mean(temp$g1)
              g2_mean<-mean(temp$g2)
              g1_sd<-sd(temp$g1)
              g2_sd<-sd(temp$g2)
              rho<-cor(temp$g1,temp$g2)
              
              results<-t.test.twosample.dependent.simple.meandiff(sample.mean.g1 = g1_mean,
                                                                  sample.mean.g2 = g2_mean,
                                                                  sample.variance.g1 = g1_sd^2,
                                                                  sample.variance.g2 = g2_sd^2,
                                                                  sample.size = nrow(temp),
                                                                  rho.estimate = rho,
                                                                  null.hypothesis.difference = 0,
                                                                  alternative = one_or_two_md_data,
                                                                  conf.level = conf,
                                                                  assume.equal.variances = t_type,
                                                                  var.test.conf.level = conf,
                                                                  var.test.details = TRUE,
                                                                  g1.details = TRUE,
                                                                  g2.details = TRUE
                                                                  )
              }
              
              
              
              #results<-t.test.twosample.dependent(x1 = temp1,x2 = temp2,null.hypothesis.difference = 0,alternative = one_or_two_md_data,conf.level = conf)
            }
      }#end type==2  
      
       ro(results,R)
      
    })
    
    ###################################################
    
    #Proportion tests output###########################
    prop_out <- reactive({
      decimal_p <- input$decimal_p
      alt_p <- input$alt_p
      alt_p2<-input$alt_p2
      conf_p <- input$conf_p
      one_or_two_p <- input$one_or_two_p
      p_samp <- input$p_samp
      n_samp_p <- input$n_samp_p
      n_samp_p_2 <- input$n_samp_p_2
      p0 <- input$p0
      p2 <- input$p2
      
      if(one_or_two_p==1){
        #fix error if np isn't quite an integer
        #np<-round(x = p_samp*n_samp_p,digits = 0)#not needed anymore
        
        results <- proportion.test.onesample.exact.simple(sample.proportion = p_samp,#np/n_samp_p,
                                                          sample.size = n_samp_p,
                                                          null.hypothesis.proportion = p0,
                                                          alternative = alt_p,
                                                          conf.level = conf_p)
      } else #end one sample p test
        
        if(one_or_two_p==2){
          #fix error if np isn't quite an integer
          # np1<-round(p_samp*n_samp_p,0)
          # np2<-round(p2*n_samp_p_2,0)#not needed anymore
          results<-proportion.test.twosample.exact.simple(sample.proportion.g1 = p_samp,#np1/n_samp_p,
                                                          sample.size.g1 = n_samp_p,
                                                          sample.proportion.g2 = p2,#np2/n_samp_p_2,
                                                          sample.size.g2 = n_samp_p_2,
                                                          alternative = alt_p2,
                                                          conf.level = conf_p)
        }
      
      
      ro(results,decimal_p)

    })#end prop out
    ##################################################
    
    #Poisson tests output#############################
    poi_out <- reactive({
      decimal_poi <- input$decimal_poi
      alt_poi <- input$alt_poi
      alt_poi_2 <- input$alt_poi_2
      conf_poi <- input$conf_poi
      one_or_two_poi <- input$one_or_two_poi
      poi_samp <- input$poi_samp
      n_samp_poi <- input$n_samp_poi
      n_samp_poi_2 <- input$n_samp_poi_2
      poi0 <- input$poi0
      poi2 <- input$poi2
      
      req(poi_samp,n_samp_poi,conf_poi)
      
      if(one_or_two_poi==1){
        req(poi0,alt_poi)
        results <- poisson.test.onesample.simple(sample.count = poi_samp,
                                                 sample.size = n_samp_poi,
                                                 null.hypothesis.lambda = poi0,
                                                 alternative = alt_poi,
                                                 conf.level = conf_poi)
      } else #end one sample p test
      
      if(one_or_two_poi==2){
        req(poi2,n_samp_poi_2,alt_poi_2)
        results<-poisson.test.twosample.simple(sample.count.g1 = poi_samp,
                                               sample.size.g1 = n_samp_poi,
                                               sample.count.g2 = poi2,
                                               sample.size.g2 = n_samp_poi_2,
                                               alternative = alt_poi_2,
                                               conf.level = conf_poi)
      }
      
      ro(results,decimal_poi)
      
    })#end Poisson out
    ############################################
    
    #####Poisson Data UI
    
    output$data_choice_column_poi <-renderUI({
      
      req(res_filter$filtered())
      
      choices<-seq(1:ncol(res_filter$filtered()))
      names(choices)<-names(res_filter$filtered())
      
      output<-checkboxGroupInput(inputId = "poi_data_selected_columns",
                                 label = "Analyze which column(s)?",
                                 choices = choices)
      output
    })
    
    output$data_choice_ref_poi <- renderUI({ #Column with reference
      req(res_filter$filtered())
      data<- res_filter$filtered()
      choices<-seq(1:ncol(data))
      names(choices)<-names(data)
      
      choices<-seq(1:ncol(data))
      names(choices)<-names(data)
      output<-selectInput(inputId = "data_choice_ref_poi",
                          label = "Select Factor",
                          multiple=F,
                          choices = choices)
      output
    })
    
    output$data_choice_data_poi <- renderUI({ #Column with data
      req(res_filter$filtered())
      data<- res_filter$filtered()
      choices<-seq(1:ncol(data))
      names(choices)<-names(data)
      factor<-input$data_choice_ref_poi
      req(factor,choices,data)
      
      #take out the one already selected
      fact_selected<-as.numeric(unlist(strsplit (x = factor,split = "\\s+")))
      temp<-seq(1:length(choices))
      temp<-temp[-fact_selected]
      choices<-choices[temp]
      
      output<-selectInput(inputId = "data_choice_data_poi",
                          label = "Select Data",
                          multiple=F,
                          choices = choices)
      output
      
    })
    
    output$data_choice_g1_poi <- renderUI({ #the number identifying group 1#get unique numbers from choice_ref
      
      data<- res_filter$filtered()
      ref<-input$data_choice_ref_poi
      req(data,ref)
      
      factor<-unique(data[as.numeric(ref)])
      
      output<-selectInput(inputId = "data_choice_g1_poi",label = "Group 1",choices = factor)
      
      output
      
    })
    
    output$data_choice_g2_poi <- renderUI({ #the number identifying group 2#get unique numbers from choice_ref
      
      data<- res_filter$filtered()
      ref<-input$data_choice_ref_poi
      factor_g1<-input$data_choice_g1_poi
      req(data,ref,factor_g1)
      
      factor<-unique(data[as.numeric(ref)])
      
      #take out the one already selected
      #fact_selected<-as.numeric(factor_g1)
      temp<-factor[-which(x = factor==factor_g1),]
      output<-selectInput(inputId = "data_choice_g2_poi",label = "Group 2",choices = temp)
      
      output
    })
    
    output$alt_poi_data<-renderUI({
      data_type<-input$data_type_poi#columns=1 ref=2
      req(data_type)
      
      if(data_type==1){
        data_columns<-input$poi_data_selected_columns
        if(!isTruthy(data_columns)){return("Select at least one data column")}
        samples<-length(data_columns)
      } else{
        factor_col<-input$data_choice_ref_poi
        if(!isTruthy(factor_col)){return("Select factor column")}
        samples<-2
      }
      
      if(samples>2){return("Select at most two columns")}
      if(samples==1){
        selectInput(inputId = "alt_poi_data",
                    label = "Alternative hypothesis for rates",
                    choices = choice_poi_alt_1
        )
      } else if(samples==2) {
        selectInput(inputId = "alt_poi_data",
                    label = "Alternative hypothesis for rates",
                    choices = choice_poi_alt_2
        )
      }
    })
    
    output$poi_test_data_ui1<-renderUI({
      data_type<-input$data_type_poi#columns=1 ref=2
      data<- res_filter$filtered()
      R<-input$decimal_poi_d
      
      req(data,data_type,R)
      
      if (data_type==1){
        sel_col<-as.numeric(input$poi_data_selected_columns)
        samples<-length(sel_col)
        if(samples>2 || !isTruthy(sel_col)) {return()}
        poi_data<-data[sel_col]
        count<-sum(na.omit(poi_data[1]))
        n<-nrow(na.omit(poi_data[1]))
        
        if(samples==2){output<-HTML(paste0(withMathJax("$\\lambda_{1}=$"),ro(count/n,R)))}
        else {output<-HTML(paste0(withMathJax("$\\lambda=$"),ro(count/n,R)))}
        
      } else{#end columns, start ref
        ref_col<-as.numeric(input$data_choice_ref_poi)
        data_col<-as.numeric(input$data_choice_data_poi)
        g1_id<-input$data_choice_g1_poi
        req(data_col,ref_col,g1_id)
        poi_data<-data.frame(group=data[ref_col][data[ref_col]==g1_id],count=data[data_col][data[ref_col]==g1_id])
        names(poi_data)<-c("Group","Count")

        count<-sum(na.omit(poi_data$Count))
        n<-length(na.omit(poi_data$Count))
        output<-HTML(paste0(withMathJax("$\\lambda_{1}=$"),ro(count/n,R)))
      }
      output
    })#end UI1
    
    output$poi_test_data_ui3<-renderUI({
      data_type<-input$data_type_poi#columns=1 ref=2
      data<- res_filter$filtered()
      #success1<-input$bi_data_success1
      R<-input$decimal_bi_d
      
      req(data,data_type,R)
      
      if (data_type==1){
        sel_col<-as.numeric(input$poi_data_selected_columns)
        samples<-length(sel_col)
        if(samples>2 || !isTruthy(sel_col)) {return()}
        poi_data<-data[sel_col]
        #count<-sum(na.omit(poi_data[1]))
        n<-nrow(na.omit(poi_data[1]))
        if(samples==2){output<-HTML(paste0(withMathJax("$n_1=$"),n))}
        else {output<-HTML(paste0(withMathJax("$n=$"),n))}
        
      } else{#end columns, start ref
        ref_col<-as.numeric(input$data_choice_ref_poi)
        data_col<-as.numeric(input$data_choice_data_poi)
        g1_id<-input$data_choice_g1_poi
        req(data_col,ref_col,g1_id)
        poi_data<-data.frame(group=data[ref_col][data[ref_col]==g1_id],count=data[data_col][data[ref_col]==g1_id])
        names(poi_data)<-c("Group","Count")
        #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
        #names(bi_data)<-c("g1","g2")
        #count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
        n<-length(na.omit(poi_data$Count))
        output<-HTML(paste0(withMathJax("$n_1=$"),n))
      }
      output
    })#end UI3
    
    output$poi_test_data_ui2<-renderUI({
      data_type<-input$data_type_poi#columns=1 ref=2
      data<- res_filter$filtered()
      R<-input$decimal_bi_d
      
      req(data,data_type,R)
      
      if (data_type==1){
        sel_col<-as.numeric(input$poi_data_selected_columns)
        samples<-length(sel_col)
        if(samples>2 || !isTruthy(sel_col)) {return()}
        if(samples==1){return(tags$div(id="inline1", class="inline",numericInput(inputId = "poi_test_data_ui2",label = "$\\lambda_{0}=$",value = .5,min = 0,max = 1,width = "75px")))}
        #req(success2)
        poi_data<-data[sel_col]
        count<-sum(na.omit(poi_data[2]))
        n<-nrow(na.omit(poi_data[2]))
        if(samples==2){output<-HTML(paste0(withMathJax("$\\lambda_2=$"),ro(count/n,R)))}
        #else {output<-HTML(paste0(withMathJax("$p=$"),ro(count/n,R)))}
        
      } else{#end columns, start ref
        ref_col<-as.numeric(input$data_choice_ref_poi)
        data_col<-as.numeric(input$data_choice_data_poi)
        g2_id<-input$data_choice_g2_poi
        req(data_col,ref_col,g2_id)
        poi_data<-data.frame(group=data[ref_col][data[ref_col]==g2_id],count=data[data_col][data[ref_col]==g2_id])
        names(poi_data)<-c("Group","Count")
        #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
        #names(bi_data)<-c("g1","g2")
        count<-sum(na.omit(poi_data$Count))
        n<-length(na.omit(poi_data$Count))
        output<-HTML(paste0(withMathJax("$\\lambda_2=$"),ro(count/n,R)))
      }
      output
    })#end UI2
    
    output$poi_test_data_ui4<-renderUI({
      data_type<-input$data_type_poi#columns=1 ref=2
      data<- res_filter$filtered()
      R<-input$decimal_bi_d
      
      req(data,data_type,R)
      
      if (data_type==1){
        sel_col<-as.numeric(input$poi_data_selected_columns)
        samples<-length(sel_col)
        if(samples>2 || !isTruthy(sel_col)) {return()}
        if(samples==1){return()}
        #req(success2)
        poi_data<-data[sel_col]
        #count<-length(na.omit(bi_data[2][bi_data[2]==success2]))
        n<-nrow(na.omit(poi_data[2]))
        if(samples==2){output<-HTML(paste0(withMathJax("$n_2=$"),n))}
        #else {output<-HTML(paste0(withMathJax("$p=$"),ro(count/n,R)))}
        
      } else{#end columns, start ref
        ref_col<-as.numeric(input$data_choice_ref_poi)
        data_col<-as.numeric(input$data_choice_data_poi)
        g2_id<-input$data_choice_g2_poi
        req(data_col,ref_col,g2_id,)
        poi_data<-data.frame(group=data[ref_col][data[ref_col]==g2_id],count=data[data_col][data[ref_col]==g2_id])
        names(poi_data)<-c("Group","Count")
        #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
        #names(bi_data)<-c("g1","g2")
        #count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
        n<-length(na.omit(poi_data$Count))
        output<-HTML(paste0(withMathJax("$n_2=$"),n))
      }
      output
    })#end UI4
    
    #####
    
    ####Poisson output for data
    output$pretty_poi_stat_data<-renderUI({
      alt<-input$alt_poi_data
      R <- input$decimal_poi_d
      conf<-input$conf_poi_data
      data<- res_filter$filtered()
      data_type<-input$data_type_poi#columns=1 ref=2
      sel_col<-as.numeric(input$poi_data_selected_columns)
      
      req(data,alt,R,conf,data_type)
      
      if(alt=="two.sided"){
        alt_num<-1
      }
      if (alt=="less"){
        alt_num<- 2
      }
      if (alt=="greater"){
        alt_num<-3
      }
      
      if (data_type==1){
        sel_col<-as.numeric(input$poi_data_selected_columns)
        samples<-length(sel_col)
        if(samples>2 || !isTruthy(sel_col)) {return()}
        poi_data<-data[sel_col]
        count1<-sum(na.omit(poi_data[1]))
        n1<-nrow(na.omit(poi_data[1]))
        
        if(samples==2){
          count2<-sum(na.omit(poi_data[2]))
          n2<-nrow(na.omit(poi_data[2]))
        }
        
      } else{#end columns, start ref
        ref_col<-as.numeric(input$data_choice_ref_poi)
        data_col<-as.numeric(input$data_choice_data_poi)
        g1_id<-input$data_choice_g1_poi
        g2_id<-input$data_choice_g2_poi
        req(data_col,ref_col,g1_id,g2_id)
        poi_data1<-data.frame(group=data[ref_col][data[ref_col]==g1_id],count=data[data_col][data[ref_col]==g1_id])
        poi_data2<-data.frame(group=data[ref_col][data[ref_col]==g2_id],count=data[data_col][data[ref_col]==g2_id])
        names(poi_data1)<-c("Group","Count")
        names(poi_data2)<-c("Group","Count")
        count1<-sum(na.omit(poi_data1$Count))
        n1<-length(na.omit(poi_data1$Count))
        count2<-sum(na.omit(poi_data2$Count))
        n2<-length(na.omit(poi_data2$Count))
        samples<-2
      }
 
      
      if(samples==1){#one-sample rate data
        ui2<-input$poi_test_data_ui2
        req(ui2)
        resultsR<-ro(poisson.test.onesample.simple(sample.count = count1,sample.size = n1,null.hypothesis.lambda = ui2,alternative = alt,conf.level = conf),R)
        output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                       "<br><br>",
                       "<table>",
                       "<tr>",
                       "<td>",paste(withMathJax("$c =$"),resultsR$statistic),"</td>",
                       "<td>","</td>",
                       "<td>",paste(withMathJax("$\\lambda_{0} =$"),resultsR$null.value),"</td>",
                       "</tr>",
                       
                       "<tr>",
                       "<td>",paste(withMathJax("$n= $"),resultsR$parameter),"</td>",
                       "<td>","</td>",
                       "<td>","</td>",
                       "</tr>",
                       
                       "</table>",
                       
                       "<table>",
                       "<tr>",
                       "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\lambda: $")),"</td>",
                       "<td>",resultsR$conf.int[1],"</td>",
                       "<td>","to","</td>",
                       "<td>",resultsR$conf.int[2],"</td>",
                       "</tr>",
                       "</table>",
                       
                       "<table>",
                       "<tr>",
                       "<td>",paste("Exact test for ",names(choice_poi_alt_1[alt_num]),": "),"</td>",
                       "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                       "</tr>",
                       "</table>"
                       )
        )
        }
      
      if(samples==2){#two-sample prop stat
        if (data_type==1){#columns
          group1_name<-names(data)[as.numeric(input$poi_data_selected_columns)[1]]
          group2_name<-names(data)[as.numeric(input$poi_data_selected_columns)[2]]
        } else{#reference
          group1_name<-paste("Group 1 = ",input$data_choice_g1_poi)
          group2_name<-paste("Group 2 = ",input$data_choice_g2_poi)
        }
        resultsR<-ro(poisson.test.twosample.simple(sample.count.g1 = count1,sample.size.g1 = n1,sample.count.g2 = count2,sample.size.g2 = n2,alternative = alt,conf.level = conf))
        output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                       "<br><br>",
                       "<table>",
                       "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                       "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                       "<tr>",
                       "<td>",paste(withMathJax("$c_{1} =$"),count1),"</td>",
                       "<td>","</td>",
                       "<td>",paste(withMathJax("$c_{2} =$"),count2),"</td>",
                       "</tr>",
                       
                       "<tr>",
                       "<td>",paste(withMathJax("$n_{1}= $"),n1),"</td>",
                       "<td>","</td>",
                       "<td>",paste(withMathJax("$n_{2}= $"),n2),"</td>",
                       "</tr>",
                       
                       "</table>",
                       
                       "<table>",
                       "<tr>",
                       "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\lambda_{1}: $")),"</td>",
                       "<td>",resultsR[["estimate"]][["g1.lambda.lowerci"]],"</td>",
                       "<td>","to","</td>",
                       "<td>",resultsR[["estimate"]][["g1.lambda.upperci"]],"</td>",
                       "</tr>",
                       "<tr>",
                       "<td align='right'>",paste(withMathJax("$\\lambda_{2}: $")),"</td>",
                       "<td>",resultsR[["estimate"]][["g2.lambda.lowerci"]],"</td>",
                       "<td>","to","</td>",
                       "<td>",resultsR[["estimate"]][["g2.lambda.upperci"]],"</td>",
                       "</tr>",
                       "</table>",
                       
                       "<table>",
                       "<tr>",
                       "<td>",paste("Exact test for ",names(choice_poi_alt_2[alt_num]),": "),"</td>",
                       "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                       "</tr>",
                       "</table>"
                       
        )
        )
        
        
      }
      
      output
    })
    
    
    
    #Critical values graphic output####################
    
    ###Allows downloading of distribution
    output$critplot<-renderPlot(crit_plot(),height = 300)
    crit_height<-reactive(300*4)
    crit_width<-reactive(400*4)
    downloadServer("critplot", crit_plot,width = crit_width,height = crit_height)
    ###
    
    
    crit_plot<-reactive({
      crit_select <- input$crit_select #1=z, 2=t, 3=chi, 4=F
      stat_or_val <- input$stat_or_val #1=p, 2=score
      tails_crit <- input$tails_crit #1=both, 2=lower, 3=upper
      R <- input$decimals_crit
      crit_value <- input$crit_value #entered value
      df1<-input$df1_crit
      df2<-input$df2_crit
      
      req(crit_select,stat_or_val,tails_crit)
      validate(need(R,"Need number of decimal places"),
               need(crit_value,"Need critical value"))
      
      p<-ggplot()
      
      if(crit_select==1){#normal
        if(tails_crit==1){#both
          
          if(stat_or_val==2){#convert to stat
            validate(need(crit_value<=1,"Enter a proportion"))
            
            crit_value<- qnorm(crit_value/2)
          }
          crit_value<- abs(crit_value)
          xmin<-min(-crit_value,-4)
          xmax<-max(crit_value,4)
          p<-p+
            stat_function(geom="area",fun=dnorm,fill=color[2],xlim = c(xmin,-crit_value))+#lower
            stat_function(geom="area",fun=dnorm,fill=color[2],xlim = c(crit_value,xmax))+
            geom_vline(xintercept = crit_value,linetype=5,color=color[2])+
            geom_vline(xintercept = -crit_value,linetype=5,color=color[2])
          area=2*pnorm(-crit_value,lower.tail = TRUE)
          
        } else{#one tail
          if (stat_or_val==2){
            validate(need(crit_value<=1,"Enter a proportion"))
            crit_value<-qnorm(crit_value)
            if(tails_crit==3){
              crit_value<- -(crit_value)
              }
          }
          xmin<-min(crit_value,-4)
          xmax<-max(crit_value,4)
          if(tails_crit==2){
            p<-p+
              stat_function(geom="area",fun=dnorm,fill=color[2],xlim = c(xmin,crit_value))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pnorm(crit_value,lower.tail = TRUE)
          } else{
            p<-p+
              stat_function(geom="area",fun=dnorm,fill=color[2],xlim = c(crit_value,xmax))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pnorm(crit_value,lower.tail = FALSE)
          }
        }#end norm one tail
        if(tails_crit==1){plusminus<-"\U00B1"}else(plusminus<-"")
        p<-p+
          geom_function(fun=dnorm,color=color[1],xlim=c(-4,4))+
          geom_vline(xintercept = 0,color=color[3])+
          ggtitle("Standard Normal Distribution",subtitle = paste0("Shaded Area = ",ro(area,R),", z = ",plusminus,ro(crit_value,R)))+
          xlab("z")+
          ylab("Density")
        
      }#end normal
      
      if(crit_select==2){#t
        req(df1)
        if(tails_crit==1){#both
          
          if(stat_or_val==2){#convert to stat
            validate(need(crit_value<=1,"Enter a probability"))
            crit_value<- qt(crit_value/2,df = df1)
          }
          crit_value<- abs(crit_value)
          xmin<-min(-crit_value,-6)
          xmax<-max(crit_value,6)
          p<-p+
            stat_function(geom="area",fun=dt,args=list(df=df1),fill=color[2],xlim = c(xmin,-crit_value))+#lower
            stat_function(geom="area",fun=dt,args=list(df=df1),fill=color[2],xlim = c(crit_value,xmax))+
            geom_vline(xintercept = crit_value,linetype=5,color=color[2])+
            geom_vline(xintercept = -crit_value,linetype=5,color=color[2])
          area=2*pt(-crit_value,df=df1,lower.tail = TRUE)
          
        } else{#one tail
          if (stat_or_val==2){
            validate(need(crit_value<=1,"Enter a probability"))
            crit_value<-qt(crit_value,df=df1)
            if(tails_crit==3){
              crit_value<- -(crit_value)
            }
          }
          xmin<-min(crit_value,-6)
          xmax<-max(crit_value,6)
          if(tails_crit==2){
            p<-p+
              stat_function(geom="area",fun=dt,args=list(df=df1),fill=color[2],xlim = c(xmin,crit_value))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pt(crit_value,df=df1,lower.tail = TRUE)
          } else{
            p<-p+
              stat_function(geom="area",fun=dt,args=list(df=df1),fill=color[2],xlim = c(crit_value,xmax))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pt(crit_value,df=df1,lower.tail = FALSE)
          }
        }#end one tail
        if(tails_crit==1){plusminus<-"\U00B1"}else(plusminus<-"")
        p<-p+
          geom_function(fun=dt,args=list(df=df1),color=color[1],xlim=c(-6,6))+
          geom_vline(xintercept = 0,color=color[3])+
          ggtitle(paste0("Student's t Distribution with ",df1," df"),subtitle = paste0("Shaded Area = ",ro(area,R),", t = ",plusminus,ro(crit_value,R)))+
          xlab("z")+
          ylab("Density")
        
      }#end t
      
      if(crit_select==3){#chi-sq
        #req(df1)
        validate(need(df1>0,"Need degrees of freedom"))
        
          xmin<-qchisq(p = 0.0001,df = df1)
          if(df1==1){xmin<-1e-2}
          xmax<-qchisq(p = 0.0001,df = df1,lower.tail = FALSE)
        
        if(tails_crit==1){#two tail
          if(stat_or_val==2){#convert to stat
            validate(need(crit_value<=1,"Enter a probability"))
            crit_value_l<- qchisq(p = crit_value/2,df = df1,lower.tail = TRUE)
            crit_value_u<- qchisq(p = crit_value/2,df = df1,lower.tail = FALSE)
          } else{
            crit_value_l<-crit_value
            crit_value_u<-qchisq(p = pchisq(q = crit_value,df = df1),df = df1,lower.tail = FALSE)
          }
          #switch if crit_value_u is smaller
        if(crit_value_u<crit_value_l){
          temp<-crit_value_u
          crit_value_u<-crit_value_l
          crit_value_l<-temp
        }
          area<-2*pchisq(q = crit_value_l,df = df1)
          tail_text<-paste0(ro(crit_value_l,R)," and ",ro(crit_value_u,R))
          
          p<-p+
            stat_function(geom="area",fun=dchisq,args = list(df=df1),fill=color[2],xlim = c(xmin,crit_value_l))+#lower
            stat_function(geom="area",fun=dchisq,args = list(df=df1),fill=color[2],xlim = c(crit_value_u,xmax))+
            geom_vline(xintercept = crit_value_l,linetype=5,color=color[2])+
            geom_vline(xintercept = crit_value_u,linetype=5,color=color[2])
          
        } else{#one tail
          if (stat_or_val==2){
            validate(need(crit_value<=1,"Enter a probability"))
            if(tails_crit==2){
              crit_value<-qchisq(crit_value,df = df1)
            } else {
              crit_value<-qchisq(crit_value,df = df1,lower.tail = FALSE)
            }
            
          }
          
          tail_text<-ro(crit_value,R)
          if(tails_crit==2){
            p<-p+
              stat_function(geom="area",fun=dchisq,args = list(df=df1),fill=color[2],xlim = c(xmin,crit_value))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pchisq(q = crit_value,df = df1,lower.tail = TRUE)
          } else{
            p<-p+
              stat_function(geom="area",fun=dchisq,args = list(df=df1),fill=color[2],xlim = c(crit_value,xmax))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pchisq(q = crit_value,df = df1,lower.tail = FALSE)
          }
        }#end one tail
        
        p<-p+
          geom_function(fun=dchisq,args = list(df=df1),color=color[1],n=512,xlim=c(xmin,xmax))+
          xlab(expression(chi^2))+
          ylab("Density")+
          ggtitle(label = paste0("\U1D6D8\U00B2 Distribution with ",df1," df"),subtitle=paste0("Shaded Area = ",ro(area,R),", \U1D6D8\U00B2 = ",tail_text))
        
        if(df1==1){
          p<-p+
            labs(caption="At 1df, \U1D6D8\U00B2 rapidly drops from infinity at 0. This graph starts at 1e-2 instead of 0 so the graph can show the distribution.")
        }
      }#end chi
      
      if(crit_select==4){#f
        req(df1,df2)
        xmin=qf(p = .0001,df1 = df1,df2 = df2)
        if(df1 == 1 || df2 == 1){xmin<-1e-2}
        xmax=qf(p = .0001,df1 = df1,df2 = df2 ,lower.tail = F)
        
        if(tails_crit==1){#two tail
          if(stat_or_val==2){#convert to stat
            validate(need(crit_value<=1,"Enter a proportion"))
            crit_value_l<- qf(p = crit_value/2,df1 = df1,df2=df2,lower.tail = TRUE)
            crit_value_u<- qf(p = crit_value/2,df1 = df1,df2=df2,lower.tail = FALSE)
          } else{
            crit_value_u<-crit_value
            crit_value_l<-qf(p = pf(q = crit_value,df1 = df1,df2 = df2,lower.tail = FALSE),df = df1,df2=df2,lower.tail = TRUE)
          }
          p<-p+
            stat_function(geom="area",fun=df,args = list(df1=df1,df2=df2),fill=color[2],xlim = c(xmin,crit_value_l))+#lower
            stat_function(geom="area",fun=df,args = list(df1=df1,df2=df2),fill=color[2],xlim = c(crit_value_u,xmax))+
            geom_vline(xintercept = crit_value_l,linetype=5,color=color[2])+
            geom_vline(xintercept = crit_value_u,linetype=5,color=color[2])
          area=pf(q = crit_value_u,df1 = df1,df2 = df2,lower.tail = FALSE)+pf(q = crit_value_l,df1 = df1,df2 = df2,lower.tail = TRUE)
          tail_text<-paste0(ro(crit_value_l,R)," and ",ro(crit_value_u,R))
          
        } else{#one tail
          if (stat_or_val==2){
            validate(need(crit_value<=1,"Enter a proportion"))
            if(tails_crit==2){
              crit_value<-qf(crit_value,df1 = df1,df2 = df2)
            } else{
              crit_value<-qf(crit_value,df1 = df1,df2 = df2,lower.tail = FALSE)
            }
            
          }
          
          tail_text<-ro(crit_value,R)
          if(tails_crit==2){
            p<-p+
              stat_function(geom="area",fun=df,args = list(df1=df1,df2=df2),fill=color[2],xlim = c(xmin,crit_value))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pf(q = crit_value,df1 = df1,df2=df2,lower.tail = TRUE)
          } else{
            p<-p+
              stat_function(geom="area",fun=df,args = list(df1=df1,df2=df2),fill=color[2],xlim = c(crit_value,xmax))+
              geom_vline(xintercept = crit_value,linetype=5,color=color[2])
            area<-pf(q = crit_value,df1 = df1,df2=df2,lower.tail = FALSE)
          }
        }#end one tail
        
        p<-p+
          geom_function(fun=df,args = list(df1=df1,df2=df2),color=color[1],n=512,xlim=c(xmin,xmax))+
          xlab("F")+
          ylab("Density")+
          ggtitle(label = paste0("F Distribution with ",df1,", ",df2," df"),subtitle=paste0("Shaded Area = ",ro(area,R),", F = ",tail_text))
        
        if(df1==1 || df2==1){
          p<-p+
            labs(caption="At 1df, F rapidly drops from infinity at 0. This graph starts at 1e-2 instead of 0 so the graph can show the distribution.")
        }
      }#end f
      
      p
      
    })
    
    ###################################################
    
    #Critical values text output####################
    crit_text_out <- reactive({
      crit_select <- input$crit_select
      stat_or_val <- input$stat_or_val
      tails_crit <- input$tails_crit
      decimals_crit <- input$decimals_crit
      crit_value <- input$crit_value
      df1_crit<-input$df1_crit
      df2_crit<-input$df2_crit
      
      
      
      #start of z crit
      if(crit_select==1){ #zcrit
        if(stat_or_val==1){ #zcrit want p 
          if(tails_crit==1){ #zcrit want p two tail
            p_crit<-1-(pnorm(q=abs(crit_value), mean=0, sd =1, lower.tail = T)-pnorm(q=-abs(crit_value), mean=0, sd=1, lower.tail = T))
            results <- c("Two-tailed p-value",ro(p_crit,decimals_crit))
          } else#end zcrit want p two tail
            if(tails_crit==2){#start zcrit want p lower tail
              p_crit<-pnorm(q=crit_value, mean=0, sd =1, lower.tail = T)
              results <- c("Lower-tail p-value",ro(p_crit,decimals_crit))
            }else #end zcrit want p lower tail
              if(tails_crit==3){#start zcrit want p upper tail
                p_crit<-pnorm(q=crit_value, mean=0, sd =1, lower.tail = F)
                results <- c("Upper-tail p-value",ro(p_crit,decimals_crit))
              } #end zcrit want p upper tail
                
        } else #end zcrit want p
        if(stat_or_val==2){
          if(tails_crit==1){ #zcrit want value two tail
            p_crit<- abs(  qnorm(p = crit_value/2, mean=0, sd =1, lower.tail = T))
            results <- c("Two-tailed value \U00B1",ro(p_crit,decimals_crit))
          } else#end zcrit want value two tail
            if(tails_crit==2){#start zcrit want value lower tail
              p_crit<-qnorm(p=crit_value, mean=0, sd =1, lower.tail = T)
              results <- c("Lower-tail value",ro(p_crit,decimals_crit))
            }else #end zcrit want value lower tail
              if(tails_crit==3){#start zcrit want value upper tail
                p_crit<- qnorm(p=crit_value, mean=0, sd =1, lower.tail = F)
                results <- c("Upper-tail value",ro(p_crit,decimals_crit))
              } #end zcrit want pvalue upper tail
          
        }#end zcrit want p
        
      } else #end of z-crit
      
      #start of t crit
      
      if(crit_select==2){ #tcrit
        if(stat_or_val==1){ #tcrit want p 
          if(tails_crit==1){ #tcrit want p two tail
            p_crit<-1-(pt(q=abs(crit_value), df = df1_crit, lower.tail = T)-pt(q=-abs(crit_value), df = df1_crit, lower.tail = T))
            results <- c("Two-tailed p-value",ro(p_crit,decimals_crit))
          } else#end tcrit want p two tail
            if(tails_crit==2){#start tcrit want p lower tail
              p_crit<-pt(q=crit_value, df=df1_crit, lower.tail = T)
              results <- c("Lower-tail p-value",ro(p_crit,decimals_crit))
            }else #end tcrit want p lower tail
              if(tails_crit==3){#start tcrit want p upper tail
                p_crit<-pt(q=crit_value, df = df1_crit, lower.tail = F)
                results <- c("Upper-tail p-value",ro(p_crit,decimals_crit))
              } #end tcrit want p upper tail
          
        } else #end zcrit want p
          if(stat_or_val==2){
            if(tails_crit==1){ #tcrit want value two tail
              p_crit<- abs(  qt(p = crit_value/2, df = df1_crit, lower.tail = T))
              results <- c("Two-tailed value \U00B1",ro(p_crit,decimals_crit))
            } else#end tcrit want value two tail
              if(tails_crit==2){#start tcrit want value lower tail
                p_crit<-qt(p=crit_value, df = df1_crit, lower.tail = T)
                results <- c("Lower-tail value",ro(p_crit,decimals_crit))
              }else #end tcrit want value lower tail
                if(tails_crit==3){#start tcrit want value upper tail
                  p_crit<- qt(p=crit_value, df = df1_crit, lower.tail = F)
                  results <- c("Upper-tail value",ro(p_crit,decimals_crit))
                } #end tcrit want pvalue upper tail
            
          }#end tcrit want p
        
      } else #end of t-crit
      
      #start of chi crit
      
      if(crit_select==3){ #chicrit
        if(stat_or_val==1){ #chicrit want p 
          if(tails_crit==1){ #chicrit want p two tail
            chi_lower<-pchisq(q=crit_value, df = df1_crit, lower.tail = T)
            chi_upper<-pchisq(q=crit_value, df = df1_crit, lower.tail = F)
            if(chi_lower>chi_upper){p_crit<-2*pchisq(q=crit_value, df = df1_crit, lower.tail = F)
              }else{p_crit<-2*pchisq(q=crit_value, df = df1_crit, lower.tail = T)}
              
            results <- c("Two-tailed p-value",ro(p_crit,decimals_crit))
          } else#end chicrit want p two tail
            if(tails_crit==2){#start chicrit want p lower tail
              p_crit<-pchisq(q=crit_value, df=df1_crit, lower.tail = T)
              results <- c("Lower-tail p-value",ro(p_crit,decimals_crit))
            }else #end chicrit want p lower tail
              if(tails_crit==3){#start chicrit want p upper tail
                p_crit<-pchisq(q=crit_value, df = df1_crit, lower.tail = F)
                results <- c("Upper-tail p-value",ro(p_crit,decimals_crit))
              } #end chicrit want p upper tail
          
        } else #end chicrit want p
          if(stat_or_val==2){ #chicrit want value
            if(tails_crit==1){ #chicrit want value two tail
              p_crit<- qchisq(p = crit_value/2, df = df1_crit, lower.tail = T)#lower
              p_crit2<-qchisq(p = crit_value/2, df = df1_crit, lower.tail = F)#upper
              results <- c("Two-tailed values ",ro(p_crit,decimals_crit),", ",ro(p_crit2,decimals_crit))
            } else#end chicrit want value two tail
              if(tails_crit==2){#start chicrit want value lower tail
                p_crit<-qchisq(p=crit_value, df = df1_crit, lower.tail = T)
                results <- c("Lower-tail value",ro(p_crit,decimals_crit))
              }else #end zcrit want value lower tail
                if(tails_crit==3){#start zcrit want value upper tail
                  p_crit<- qchisq(p=crit_value, df = df1_crit, lower.tail = F)
                  results <- c("Upper-tail value",ro(p_crit,decimals_crit))
                } #end chicrit want pvalue upper tail
            
          }#end chicrit want p
        
      } else #end of chi-crit
      

      #start of F crit
      if(crit_select==4){ #Fcrit
        if(stat_or_val==1){ #Fcrit want p 
          if(tails_crit==1){ #Fcrit want p two tail
            if(crit_value<=0){p_crit=1}else
            p_crit<- 2*pf(q=crit_value, df = df1_crit, df2 = df2_crit, lower.tail = F)
            results <- c("Two-tailed p-value ",ro(p_crit,decimals_crit))
          } else#end Fcrit want p two tail
            if(tails_crit==2){#start Fcrit want p lower tail
              p_crit<-pf(q=crit_value, df = df1_crit, df2 = df2_crit, lower.tail = T)
              results <- c("Lower-tail p-value",ro(p_crit,decimals_crit))
            }else #end Fcrit want p lower tail
              if(tails_crit==3){#start Fcrit want p upper tail
                p_crit<- pf(q=crit_value, df = df1_crit, df2 = df2_crit, lower.tail = F)
                results <- c("Upper-tail p-value",ro(p_crit,decimals_crit))
              } #end Fcrit want p upper tail
          
        } else #end Fcrit want p
          
          if(stat_or_val==2){ #Fcrit want value
            if(tails_crit==1){ #Fcrit want value two tail
              p_crit<- qf(p = crit_value/2, df = df1_crit, df2 = df2_crit,lower.tail = T)#lower
              p_crit2<-qf(p = crit_value/2, df = df1_crit, df2 = df2_crit, lower.tail = F)#upper
              results <- c("Two-tailed values ",ro(p_crit,decimals_crit),", ",ro(p_crit2,decimals_crit))
            } else#end Fcrit want value two tail
              if(tails_crit==2){#start Fcrit want value lower tail
                p_crit<-qf(p=crit_value, df = df1_crit,df2 = df2_crit, lower.tail = T)
                results <- c("Lower-tail value",ro(p_crit,decimals_crit))
              }else #end Fcrit want value lower tail
                if(tails_crit==3){#start Fcrit want value upper tail
                  p_crit<- qf(p=crit_value, df = df1_crit,df2 = df2_crit, lower.tail = F)
                  results <- c("Upper-tail value",ro(p_crit,decimals_crit))
                } #end Fcrit want pvalue upper tail
            
          }#end chicrit want p
        
      } else #end of F-crit
      

      ro(results,decimals_crit)
      

    })#end crit text reactive
    
    ###################################################
    
    #Correlation and Association#######################
    corr_out <- reactive ({
      conf_corr<-input$conf_corr
      corr_tests<-input$corr_tests
      corr_hyp<-input$alt_corr
      stat_corr1<-input$stat_corr1#first sample statistic, upper left
      stat_corr2<-input$stat_corr2#second sample statistic, upper right
      stat_corr3<-input$stat_corr3#third sample statistic, lower left
      stat_corr4<-input$stat_corr4#fourth sample statistic, lower right
      n_corr<-input$n_corr#first sample size
      decimal_corr<-input$decimal_corr
      stat_corr6<-input$stat_corr6
      
      req(corr_tests,conf_corr,corr_hyp,decimal_corr)
      
      if(corr_tests==1){
        req(stat_corr1,stat_corr2,n_corr)
        if(abs(stat_corr1)>1){return ()}
        results_corr<-cor.pearson.r.onesample.simple(sample.r = stat_corr1,
                                                     sample.size = n_corr,
                                                     null.hypothesis.rho = stat_corr2,
                                                     alternative = corr_hyp,
                                                     conf.level = conf_corr)
      }
      else if(corr_tests==2){
        req(stat_corr1,stat_corr2,n_corr)
        if(abs(stat_corr1)>1){return ()}
        results_corr<-cor.spearman.rank.simple(r_sp = stat_corr1,
                                               sample.size = n_corr,
                                               alternative = corr_hyp,
                                               conf.level = conf_corr)
      }
      else if(corr_tests==3){
        req(stat_corr1,stat_corr2,stat_corr3,stat_corr4,n_corr)
        #if(!(near(stat_corr1,as.integer(stat_corr1)) || near(stat_corr2,as.integer(stat_corr2)) || near(stat_corr3,as.integer(stat_corr3)) || near(stat_corr4,as.integer(stat_corr4)) || near(n_corr,as.integer(n_corr)))) {return()}
        results_corr<-cor.kendall.tau.simple(count.concordant = stat_corr1,
                                             count.discordant = stat_corr2,
                                             ties.x1 = stat_corr3,
                                             ties.x2 = stat_corr4,
                                             sample.size = n_corr,
                                             alternative = corr_hyp,
                                             conf.level = conf_corr
                                             )
      }
      else if(corr_tests==4){
        req(stat_corr1,stat_corr2,stat_corr3,stat_corr4)
        M<-matrix(data = c(stat_corr1,stat_corr3,stat_corr2,stat_corr4),nrow = 2,ncol = 2)
        results_corr<-cor.cramer.phi(observed.frequencies = M)
        #if(!(near(stat_corr1,as.integer(stat_corr1)) || near(stat_corr2,as.integer(stat_corr2)) || near(stat_corr3,as.integer(stat_corr3)) || near(stat_corr4,as.integer(stat_corr4))) ) {return()}
        #M<-as.table(rbind(c(stat_corr1,stat_corr3),c(stat_corr2,stat_corr4)))
        #test<-chisq.test(M,correct = F)
        #phi<-ro(cor.matthews.simple(true.positive = stat_corr1,false.positive = stat_corr3,true.negative = stat_corr4,false.negative = stat_corr2)[1],decimal_corr)
        
        # results_corr<-(c(phi,
        #                 "Test for Significance",
        #                 "Chi-square",test[1],"df",test[2],"p =",test[3]
        #                       ))
      }
      
      else if(corr_tests==5){
        req(stat_corr1,stat_corr2,stat_corr4)
        if(abs(stat_corr1)>1 || abs(stat_corr2)>1 ){return ()}
        results_corr<-cor.pearson.r.twosample.independent.simple(sample.r.g1.g2 = stat_corr1,
                                                                 sample.size.g1.g2 = n_corr,
                                                                 sample.r.g3.g4 = stat_corr2,
                                                                 sample.size.g3.g4 = stat_corr4,
                                                                 alternative = corr_hyp,
                                                                 conf.level = conf_corr)
      }
      
      else if(corr_tests==6){
        req(stat_corr1,stat_corr2,stat_corr3,stat_corr4)
        if(abs(stat_corr1)>1 || abs(stat_corr2)>1 ){return ()}
        results_corr<-cor.goodman.kruskal.gamma.twosample.independent.simple(gamma.g1 = stat_corr1,
                                                                             se.est.gamma.g1 = stat_corr3,
                                                                             gamma.g2 = stat_corr2,
                                                                             se.est.gamma.g2 = stat_corr4,
                                                                             alternative = corr_hyp,
                                                                             conf.level = conf_corr)
      }
      else if(corr_tests==7){
        req(stat_corr1,stat_corr2,stat_corr3,stat_corr4)
        if(abs(stat_corr1)>1 || abs(stat_corr2)>1 ){return ()}
        results_corr<-cor.cohen.kappa.twosample.independent.simple(kappa.g1 = stat_corr1,
                                                                   se.kappa.g1 = stat_corr3,
                                                                   kappa.g2 = stat_corr2,
                                                                   se.kappa.g2 = stat_corr4,
                                                                   alternative = corr_hyp
                                                                   ,conf.level=conf_corr)
      }
      
      else if(corr_tests==8){
        req(stat_corr1,stat_corr2,stat_corr3,n_corr)
        if(abs(stat_corr1)>1 || abs(stat_corr2)>1 ||abs(stat_corr3)>1){return ()}
        results_corr<-cor.pearson.r.twosample.dependent.simple(sample.r.g1.g3 = stat_corr1,
                                                               sample.r.g2.g3 = stat_corr2,
                                                               sample.r.g1.g2 = stat_corr3,
                                                               sample.size = n_corr,
                                                               alternative = corr_hyp,conf.level = conf_corr
                                                                )
      }
      else if(corr_tests==9){
        req(stat_corr3,stat_corr4,n_corr,stat_corr6)
        #if(!(near(stat_corr3,as.integer(stat_corr3)) || near(stat_corr4,as.integer(stat_corr4)) || near(stat_corr5,as.integer(stat_corr5)) || near(stat_corr6,as.integer(stat_corr6)))) {return()}
        observed<-matrix(data = c(stat_corr3,stat_corr4,n_corr,stat_corr6),nrow = 2,ncol = 2)
        expected<-chi.square.2d.expected.frequencies(observed.frequencies =observed)
    
        results_corr<-cor.cohen.kappa.onesample(observed.frequencies = observed,
                                                #expected.frequencies = expected,
                                                alternative = corr_hyp,conf.level = conf_corr)
      }
      
      ro(results_corr,decimal_corr)
      #results_corr<-c(stat_corr1, stat_corr2, stat_corr3, stat_corr4, n_corr, corr_hyp, conf_corr,decimal_corr)
      #results_corr
      
      
    })#end corr_out
    
    ###################################################
    
    #Selected columns for md_data######################
    num_selected_columns_md_data<-reactive({
      md_data_selected_columns<-input$md_data_selected_columns
      
      length(md_data_selected_columns)
      
    })
    
    ###################################################
    
    
    #generate test number for m_d data tests##########
    data_md_test_num<-reactive({
      num_columns<-num_selected_columns_md_data()
      md_one_samp_var<-input$md_one_samp_var
      dep_or_indep_data<-input$dep_or_indep_data
      sigma_known_data<-input$sigma_known_data
      type<-input$data_type_md
      
      req(type,sigma_known_data)
      
      if(num_columns==1 && sigma_known_data==1){req(!is.null(md_one_samp_var))}
      
      output_data_md_test_num<-NULL
      
      #for column data
      if(type==1){
        req(num_columns)
    #one sample z
    if(num_columns==1 && sigma_known_data==2){
    output_data_md_test_num<-1}
    
    #one sample t
      if(num_columns==1 && sigma_known_data==1 && md_one_samp_var==F)
        {output_data_md_test_num<-2}
      
    
    #one sample var
      if(num_columns==1 && sigma_known_data==1 && md_one_samp_var==T)
        {output_data_md_test_num<-3}
      
    
    #two-sample z - ind
      if(num_columns==2 && sigma_known_data==2 && dep_or_indep_data==1)
        {output_data_md_test_num<-4}
      
    
    #two-sample t - ind
      if(num_columns==2 && sigma_known_data==1)
      {
        req(dep_or_indep_data)
        if(dep_or_indep_data==1){
          output_data_md_test_num<-5}
        }
    
    #two-sample z - dep
      if(num_columns==2 && sigma_known_data==2 )
      {
        req(dep_or_indep_data)
        if(dep_or_indep_data==2){
           output_data_md_test_num<-7}#is 6 but currently not implemented
        }
    
    #two-sample t - dep
      if(num_columns==2 && sigma_known_data==1)
      {
        req(dep_or_indep_data)
        if(dep_or_indep_data==2){
          output_data_md_test_num<-7}
        }
      
      } else
        
        if(type==2){ #for reference data
          #two-sample z - ind
          req(dep_or_indep_data)
          if(sigma_known_data==2 && dep_or_indep_data==1)
          {output_data_md_test_num<-4}
          
          
          #two-sample t - ind
          if(sigma_known_data==1 && dep_or_indep_data==1)
          {output_data_md_test_num<-5}
          
          
          #two-sample z - dep
          if(sigma_known_data==2 && dep_or_indep_data==2)
          {output_data_md_test_num<-6}
          
          
          #two-sample t - dep
          if(sigma_known_data==1 && dep_or_indep_data==2)
          {output_data_md_test_num<-7}
        }
      
      output_data_md_test_num
    
    })
    
    ###################################################
    
    #generate test number for m_d no data tests##########
    md_test_num<-reactive({
      one_or_two<-input$one_or_two
      sigma_known <- input$sigma_known
      dep_or_indep <- input$dep_or_indep
      one_samp_var <- input$one_samp_var

      req(one_or_two,sigma_known)#,!is.null(one_samp_var))
      if(one_or_two==2){req(dep_or_indep)}
      
      output<-NULL
      
      if(one_or_two==1){req(!is.null(one_samp_var))}
      
      #one sample z
      if(one_or_two==1 && sigma_known==2){
        output<-1}
      
      #one sample t
      else if(one_or_two==1 && sigma_known==1 && one_samp_var==F)
      {output<-2}
      
      
      #one sample var
      else if(one_or_two==1 && sigma_known==1 && one_samp_var==T)
      {output<-3}
      
      #two-sample z - ind
      if(one_or_two==2 && sigma_known==2 && dep_or_indep==1)
      {output<-4}
      
      
      #two-sample t - ind
      else if(one_or_two==2 && sigma_known==1 && dep_or_indep==1)
      {output<-5}
      
      
      #two-sample z - dep
      else if(one_or_two==2 && sigma_known==2 && dep_or_indep==2)
      {output<-6}
      
      
      #two-sample t - dep
      else if(one_or_two==2 && sigma_known==1 && dep_or_indep==2)
      {output<-7}
      
      
      
      output
      
    })
   

    #render the hypergeometric table
    output$hype_table <- renderDataTable({
      data_hype()
    })#end of hyper table
    
    #render the geometric table
    output$geom_table <- renderDataTable({
      data_geom()
    })#end of geom table
  
       
 #Render the binomial table
    output$bi_table <- renderDataTable({
        data_bi()
    })#end of binom table
    
    #Render the binomial plot
    # output$bi_plot <- renderPlot({
    #     plot_bi()
    # })#end of binom plot
    
    #Render the Poisson table
    output$pois_table <- renderDataTable({
        data_pois()
    })
    #Render the Poisson plot
    # output$pois_plot<-renderPlot({
    #     plot_pois()
    # })
    #Render the normal plot
    # output$norm_plot<-renderPlot({
    #     plot_norm()
    # })
    #Render the normal table
    output$norm_table<-renderDataTable({
        DT::datatable(data_norm(),options=list(dom="t",paging=FALSE),rownames = F,colnames = c("","Result"))
    })
    #Render the exponential plot
    # output$exp_plot<-renderPlot({
    #     plot_exp()
    # })
    #Render the exponential table
    output$exp_table<-renderDataTable({
        DT::datatable(data_exp(),options=list(dom="t",paging=FALSE),rownames = F,colnames = c("","Result"))
    })
    #Render the F-plot
    # output$f_plot<-renderPlot({
    #     plot_f()
    # })
    #Render the f table
    output$f_table <- renderDataTable({
        DT::datatable(data_f(),options=list(dom="t",paging=FALSE,autoWidth=TRUE,columnDefs=list(list(width='150px',targets=c(0,1) ))),rownames = F,colnames = c("","Result"))
    })
    #Render the file in memory - temp for EDA
    output$file_in_memory.out <- renderDataTable({
        file_in_memory()
    })
    
    #Render the summary stats for continuous data
    output$summary.stats.cont <-renderDataTable({
        #summary.continuous(fx = file_in_memory())
      data<-res_filter$filtered()#imported$data()
      req(data)
      summary.continuous(fx = data)
      
      
    })
    
    #Render means tests
    output$mean_table <-renderPrint({
        mean_out()
    })
    #Render proportions tests
    output$prop_table <- renderPrint({
      prop_out()
    })
    #Render Poisson tests
    output$poi_table <- renderPrint({
      poi_out()
    })
    #Render critical values plot
    output$crit_plot <- renderPlot({
      crit_plot_out()
    })
    #Render critical values text
    output$crit_text <- renderText({
      crit_text_out()
    })
    #Render the label for the critical values page
    output$crit_label <- renderUI({
      if(input$stat_or_val==1){
      h3(
        paste(
          "Convert ",
          names(choice_crit)[as.numeric(input$crit_select)],
          " into p-value")
        )
      } else
        if(input$stat_or_val==2){
          h3(
            paste(
              "Convert p-value into ",
              names(choice_crit)[as.numeric(input$crit_select)]
              )
          )
        }
    })
    
    #Render the alternative hypothesis for the correlation association page
    output$corr_alt <- renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      #choice_corr_alt_text

      choice_corr_alt <-c("two.sided","less","greater")
      if(corr_tests==4){choice_corr_alt <-c("two.sided","","")}
      index=(3*(as.numeric(corr_tests)-1))+1
      
      names(choice_corr_alt) <-choice_corr_alt_text[c(seq(index,index+2))]
      
      
      selectInput(inputId = "alt_corr",label = "Alternative Hypothesis",choices = choice_corr_alt)
    })
    
    
    #Render the correlation test radio buttons
    output$corr_tests<-renderUI({
      one_or_two_corr<-input$one_or_two_corr
      
      if(one_or_two_corr==1){#one sample test
        corr_test_choice<-c(1,2,3,4)
        names(corr_test_choice)<-c("Pearson r","Spearman Rank r\U209B","Kendall's \U1D70F","\U1D719 / Cramers V")
      }
      if(one_or_two_corr==2){#two sample independent
        corr_test_choice<-c(5, 6, 7)
        names(corr_test_choice)<-c("Pearson r","Goodman and Kruskal's \U1D6FE","Cohen's \U1D73F")
      }
      if(one_or_two_corr==3){#two sample dependent
        corr_test_choice<-c(8,9)
        names(corr_test_choice)<-c("Pearson r","\U1D73F Agreement (2x2)")
        }
      radioButtons(inputId = "corr_tests",label = "Select Test",choices = corr_test_choice)
    })
    
    #Render the correlation/association output
    output$corr_text<-renderPrint({
      corr_out()
    })
    
    #render corr more info text
      observeEvent(input$corr_more_info,{#})   output$corr_more_info_text<-renderUI({
      if(!input$corr_more_info){return()}
      corr_tests<-input$corr_tests
      req(corr_tests)
      
      # if(corr_more_info==F){
      #   text_out<-HTML("")
      # }
      # else{
        if (corr_tests==1){
          title="One-Sample Pearson r Test"
          text_out<-HTML("The one-sample Pearson r test is used with interval or ratio data to determine if the linear correlation between two variables could be the same as \U1D70C\U2080. If \U1D70C\U2080 = 0, it is testing to see if a linear relationship between the variables is significant at all. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==2){
          title="One-Sample Spearman r\U209B Test"
          text_out<-HTML("The one-sample Spearman r\U209B is a nonparametric test used when the data are not interval or ratio or cannot be assumed to be linearly related, to determine of there is a significant monotonic relationship between two variables. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==3){
          title="One-Sample Kendall's \U1D70F Test"
          text_out<-HTML("The one-sample Kendall's \U1D70F nonparametric test is used with ordinal data to determine if there is a significant association bewteen two variables. It does not require that the relationship is monotonic like the Spearman r\U209B. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==4){
          title="One-Sample Pearson \U1D719 Test"
          text_out<-HTML("The one-sample Pearson \U1D719 coefficient (also known as Matthews Correlation Coefficient when it is used in predicting binary classifications) is used to determine if there is a significant association betewen two binary variables.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Phi_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==5){
          title="Two-Sample Pearson r Test"
          text_out<-HTML("The two-sample Pearson r test is used with two sets of interval or ratio data to determine if the linear correlation between the first set and the linear correlation between the second set are the same. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==6){
          title="Two-Sample Goodman and Kruskall \U1D6FE Test"
          text_out<-HTML("The two-sample Goodman and Kruskall \U1D6FE test is used with two sets of ordinal data to determine if the association between the first set and the association between the second set are the same. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Goodman_and_Kruskal%27s_gamma'>Wikipedia</a>")
        }
        if (corr_tests==7){
          title="Two-Sample Cohen \U1D73F Test"
          text_out<-HTML("The two-sample Cohen \U1D73F test is used compare two rater \U1D73F scores to determine if the two raters can be said to be equally reliable. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Cohen%27s_kappa'>Wikipedia</a>")
        }
        if (corr_tests==8){
          title="Two-Sample Dependent Pearson r Test"
          text_out<-HTML("The two-sample dependent Pearson r test is used with overlapping sets of interval or ratio data to determine if the linear correlation between the first and third variable is the same as the linear correlation between the second and third variable. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==9){
          title="Cohen \U1D73F Test"
          text_out<-HTML("The Cohen \U1D73F test is used determine the level of agreement above that of chance between two judges across the same items. It can also determine agreement with the real value for one judge.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Cohen%27s_kappa'>Wikipedia</a>")
        }
      # }
      #text_out
      sendSweetAlert(title = title,text = HTML(text_out),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
      updateCheckboxInput(inputId = "corr_more_info",value = FALSE)
    })
    
    #render corr more info text
    observeEvent(input$corr_more_info_data,{#}) output$corr_more_info_text_data<-renderUI({
      if(!input$corr_more_info_data){return()}
      corr_tests<-input$corr_tests_data
      req(corr_tests)
      
      # if(corr_more_info==F){
      #   text_out<-HTML("")
      # }
      # else{
        if (corr_tests==1){
          title="One-Sample Pearson r Test"
          text_out<-HTML("The one-sample Pearson r test is used with interval or ratio data to determine if the linear correlation between two variables could be the same as \U1D70C\U2080. If \U1D70C\U2080 = 0, it is testing to see if a linear relationship between the variables is significant at all. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==2){
          title="One-Sample Spearman r\U209B Test"
          text_out<-HTML("The one-sample Spearman r\U209B is a nonparametric test used when the data are not interval or ratio or cannot be assumed to be linearly related, to determine of there is a significant monotonic relationship between two variables. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==3){
          title="One-Sample Kendall's \U1D70F Test"
          text_out<-HTML("The one-sample Kendall's \U1D70F nonparametric test is used with ordinal data to determine if there is a significant association bewteen two variables. It does not require that the relationship is monotonic like the Spearman r\U209B. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient'>Wikipedia</a>")
        }
        
        if (corr_tests==4){
          title="One-Sample Pearson \U1D719 Test"
          text_out<-HTML("The one-sample Pearson \U1D719 coefficient is a special case of Cram\U00E9r's V when you have two nominal variables with two categories, so the more general V is used here. It is used to determine if there is a significant association betewen two nominal variables with two or more categories.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Phi_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==5){
          title="Biserial Correlation Coefficient Test"
          text_out<-HTML("The biserial correlation coefficient is used to estimate the correlation between two underlying continuous variables that have both been artificially reduced to dichotomous measures.</br></br>")#For more information see <a href='https://en.wikipedia.org/wiki/Phi_coefficient'>Wikipedia</a>
        }
        if (corr_tests==6){
          title="Point-Biserial Correlation Coefficient Test"
          text_out<-HTML("The point-biserial correlation coefficient is used to measure the relationship between one continuous variables and one genuinely dichotomous variable.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Point-biserial_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==7){
          title="Yule's Q Test"
          text_out<-HTML("Yule's Q is a special case of Goodman and Kruskal's \U1D6FE measure of rank correlation when you have a 2x2 matrix. It is used to measure the strength of association of two dichotomous variables. Yule's Q can have a slightly different interpretation than \U1D6FE since the sign depends on how the researcher sets up the matrix. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Goodman_and_Kruskal%27s_gamma'>Wikipedia</a>")
        }
        if (corr_tests==8){
          title="One-Sample Goodman and Kruskall \U1D6FE Test"
          text_out<-HTML("The one-sample Goodman and Kruskall \U1D6FE test is used to determine the strength of association between two ordinal variables based on the rank correlations. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Goodman_and_Kruskal%27s_gamma'>Wikipedia</a>")
        }
        if (corr_tests==9){
          title="Tetrachoric Correlation Coefficient Test"
          text_out<-HTML("The tetrachoric correlation coefficient is used to estimate the linear relationship between two underlying continuous normally distributed variables that have been artificially reduced to dichotomous variables. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Polychoric_correlation'>Wikipedia</a>")
        }
        if (corr_tests==10){
          title="Cohen's \U1D73F Test"
          text_out<-HTML("Cohen's \U1D73F test is used determine the level of agreement above that of chance between two judges across the same items. It can also determine agreement with the real value for one judge.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Cohen%27s_kappa'>Wikipedia</a>")
        }
        if (corr_tests==11){
          title="Kendall's Coefficient of Concordance Test"
          text_out<-HTML("Kendall's coefficient of concordance is a measure of agreement among judges' ordinal ratings. It does not measure if the judges give the same rating, rather that units assessed as high by one judge tend to be rated high by the others.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Kendall%27s_W'>Wikipedia</a>")
        }
        if (corr_tests==12){
          title="J-index of Predictive Efficiency Test"
          text_out<-HTML("The J-index of predictive efficiency is used when a dichotomous test is used to predict a dichotomous outcome, like a pass/fail test predicting failure in the field.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Youden%27s_J_statistic'>Wikipedia</a>")
        }
        if (corr_tests==13){
          title="Two-Sample Pearson r Test"
          text_out<-HTML("The two-sample Pearson r test is used with two sets of interval or ratio data to determine if the linear correlation between the first set and the linear correlation between the second set are the same. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        if (corr_tests==14){
          title="Two-Sample Goodman and Kruskall \U1D6FE Test"
          text_out<-HTML("The two-sample Goodman and Kruskall \U1D6FE test is used with two sets of ordinal data to determine if the association between the first set and the association between the second set are the same. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Goodman_and_Kruskal%27s_gamma'>Wikipedia</a>")
        }
        if (corr_tests==15){
          title="Two-Sample Cohen \U1D73F Test"
          text_out<-HTML("The two-sample Cohen \U1D73F test is used compare two rater \U1D73F scores to determine if the two raters can be said to be equally reliable. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Cohen%27s_kappa'>Wikipedia</a>")
        }
        if (corr_tests==16){
          title="Two-Sample J-index of Predictive Efficiency"
          text_out<-HTML("The two-sample J-index of predictive efficiency is used to compare how efficiently two dichotomous tests are at predicting a dichotomous outcome.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Youden%27s_J_statistic'>Wikipedia</a>")
        }
        if (corr_tests==17){
          title="Two-Sample Dependent Pearson r Test"
          text_out<-HTML("The two-sample dependent Pearson r test is used with overlapping sets of interval or ratio data to determine if the linear correlation between the first and third variable is the same as the linear correlation between the second and third variable. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Pearson_correlation_coefficient'>Wikipedia</a>")
        }
        
      # }
      #text_out
      sendSweetAlert(title = title,text = HTML(text_out),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
      updateCheckboxInput(inputId = "corr_more_info_data",value = FALSE)
    })
    
    
    #render corr data structure info text
    output$corr_data_info_text<-renderUI({
      corr_data_info<-input$corr_data_info
      corr_tests<-input$corr_tests_data
      req(corr_data_info)
      req(corr_tests)
      
      if(corr_data_info==F){
        text_out<-HTML("The data for correlation and association tests needs to be structured differently depending on the test. Check the box above to get more information about the data structure for the selected test.")
      }
      else{
        if (corr_tests==1 || corr_tests==2 || corr_tests==3 || corr_tests==5|| corr_tests==6){
          text_out<-HTML("Two columns of data, each row being a paired observation.")
        }
        
        if (corr_tests==4 || corr_tests==7 || corr_tests==8 || corr_tests==9){
          text_out<-HTML("<ul><li>Independent - Two columns of data, each row representing an observation.</li><li>Frequency - Three columns of data, one column the row identifier, one column the column identifier, and one column the weight for each combination.</li></ul>")
        }
      }
      if (corr_tests==10){
        text_out<-HTML("<ul><li>Independent - Two columns of data, one for each judge, with each line representing their rating for an item.</li><li>Frequency - Three columns of data, one column is Judge 1's assessment, one column is Judge 2's assessment, and one column the weight for each combination.</li></ul>")
      }
    
      if (corr_tests==11){
        text_out<-HTML("<ul><li>Independent - Three columns of data, one identifying the item being rated, one the rater and one for their rating for that item.</li><li>Tabular - Four or more columns of data, one column is the item being rated and each additional column is a rater and their rating for each item. Raters can be added or taken out in the Select Judges box.</li></ul>")
      }
      if (corr_tests==12){
        text_out<-HTML("<ul><li>Independent - Two columns of data, one column being the predicted result and one column being the actual result. Each row is a unique test/result pair.</li><li>Frequency - Three columns of data, one column for the predicted result, one column for the actual result, and one column the weight for each combination.</li></ul>")
      }
      if (corr_tests==13){
        text_out<-HTML("Independent - Four columns of data: a column of x and a column with their corrosponding y, a third column of the second X and a fourth of its y.")
      }
      if (corr_tests==14){
        text_out<-HTML("Four columns of data: one column the group designator, two columns of the row and column designator, and a column of the weight for each combination.")
      }
      if (corr_tests==15){
        text_out<-HTML("Three columns of data: one column the group designator, a column for each of the two judges. Each line represents a particular item.")
      }
      if (corr_tests==16){
        text_out<-HTML("<ul><li>Independent - three columns of data, one column being the group, one the predicted result and one being the actual result. Each row is a unique test/result pair within the group.</li><li>Frequency - Four columns of data, one column for the group, one for the predicted result within each group, one for the actual result within each group, and one column the weight for each combination.</li></ul>")
      }
      if (corr_tests==17){
        text_out<-HTML("Three columns of data: two columns of observations and a third column of the variable in common between them.")
      }
      
      
      text_out
    })
    
    
    #render the first reactive input field for correlation and association
    output$corrUI1 <- renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      
      if(corr_tests==1){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$r:{ }$$"),value = .5,width = "750px")
      }
      if(corr_tests==2){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$r_{s}:{ }$$"),value = .5,width = "750px")
      }
      if(corr_tests==3){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = "Concordant Pairs",value = 395,width = "750px")
      }
      if(corr_tests==4){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$n_{11}:{ }$$"),value = 6,width = "750px")
      }
      if(corr_tests==5){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$r_{12}:{ }$$"),value = .5,width = "750px")
      }
      if(corr_tests==6){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$\\gamma_{1:{ }}$$"),value = .8,width = "750px")
      }
      if(corr_tests==7){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$\\kappa_{1}:{ }$$"),value = .701,width = "750px")
      }
      if(corr_tests==8){
        corr_UI1_out<-numericInput(inputId = "stat_corr1",label = withMathJax("$$r_{13}:{ }$$"),value = .312,width = "750px")
      }
      if(corr_tests==9){
        corr_UI1_out<-HTML("<p style='text-align:center'><b>Pass 2</b></p>")
      }
      corr_UI1_out
      
    })
    
    #render the second reactive input field for correlation and association
    output$corrUI2<-renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)

      if(corr_tests==1){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$\\rho_{0}:{ }$$"),value = .5,width = "750px")
      }
      if(corr_tests==2){
        corr_UI2_out<-NULL
      }
      if(corr_tests==3){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = "Discordant Pairs",value = 40,width = "750px")
      }
      if(corr_tests==4){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$n_{21}:{ }$$"),value = 2,width = "750px")
      }
      if(corr_tests==5){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$r_{34}:{ }$$"),value = .3,width = "750px")
      }
      if(corr_tests==6){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$\\gamma_{2}:{ }$$"),value = .3,width = "750px")
      }
      if(corr_tests==7){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$\\kappa_{2:{ }}$$"),value = .469,width = "750px")
      }
      if(corr_tests==8){
        corr_UI2_out<-numericInput(inputId = "stat_corr2",label = withMathJax("$$r_{23}:{ }$$"),value = .737,width = "750px")
      }
      if(corr_tests==9){
        corr_UI2_out<-HTML("<p style='text-align:center'><b>Fail 2</b></p>")
      }
      
      corr_UI2_out
      
      
    })
    
    #render the third reactive input field for correlation and association
    output$corrUI3<-renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      
      if(corr_tests==1){
        corr_UI3_out<-NULL
      }
      if(corr_tests==2){
        corr_UI3_out<-NULL
      }
      if(corr_tests==3){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = "Count Ties X",value = 0,width = "750px")
      }
      if(corr_tests==4){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = withMathJax("$$n_{12}:{ }$$"),value = 1,width = "750px")
      }
      if(corr_tests==5){
        corr_UI3_out<-NULL
      }
      if(corr_tests==6){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = withMathJax("$$\\sigma_{SE1}:{ }$$"),value = .1,width = "750px")
      }
      if(corr_tests==7){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = withMathJax("$$se_{\\kappa1}:{ }$$"),value = .063,width = "750px")
      }
      if(corr_tests==8){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = withMathJax("$$r_{12}:{ }$$"),value = .51,width = "750px")
      }
      if(corr_tests==9){
        corr_UI3_out<-numericInput(inputId = "stat_corr3",label = "Pass 1",value = 150,min = 0,step = 1)
      }
      corr_UI3_out
      
      
    })

    #render the forth reactive input field for correlation and association
    output$corrUI4<-renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      
      if(corr_tests==1){
        corr_UI4_out<-NULL
      }
      if(corr_tests==2){
        corr_UI4_out<-NULL
      }
      if(corr_tests==3){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = "Count Ties Y",value = 0,width = "750px")
      }
      if(corr_tests==4){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = withMathJax("$$n_{22}:{ }$$"),value = 3,width = "750px")
      }
      if(corr_tests==5){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = withMathJax("$$n_{34}:{ }$$"),value = 10,width = "750px")
      }
      if(corr_tests==6){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = withMathJax("$$\\sigma_{SE2}:{ }$$"),value = .02,width = "750px")
      }
      if(corr_tests==7){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = withMathJax("$$se_{\\kappa2}:{ }$$"),value = .007,width = "750px")
      }
      if(corr_tests==8){
        corr_UI4_out<-NULL
      }
      if(corr_tests==9){
        corr_UI4_out<-numericInput(inputId = "stat_corr4",label = "Pass 1",value = 6,min = 0,step = 1)
      }
      
      corr_UI4_out
      
      
    })
    
    #render the fifth reactive input field for correlation and association
    output$corrUI5<-renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      
      if(corr_tests==1){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = withMathJax("$$n:{ }$$"),value = 10,min = 1,step = 1)
      }
      if(corr_tests==2){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = withMathJax("$$n:{ }$$"),value = 10,min = 1,step = 1)
      }
      if(corr_tests==3){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = withMathJax("$$n:{ }$$"),value = 10,min = 1,step = 1)
      }
      if(corr_tests==4){
        corr_UI5_out<-NULL
      }
      if(corr_tests==5){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = withMathJax("$$n_{12}:{ }$$"),value = 10,min = 1,step = 1)
      }
      if(corr_tests==6){
        corr_UI5_out<-NULL
      }
      if(corr_tests==7){
        corr_UI5_out<-NULL
      }
      if(corr_tests==8){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = withMathJax("$$n:{ }$$"),value = 20,min = 1,step = 1)
      }
      if(corr_tests==9){
        corr_UI5_out<-numericInput(inputId = "n_corr",label = "Fail 1",value = 14,min = 0,step = 1)
      }
      
      corr_UI5_out
      
      
    })
    
    output$corrUI6<-renderUI({
      corr_tests<-input$corr_tests
      req(corr_tests)
      output<-NULL
      if(corr_tests==9){
        output<-numericInput(inputId = "stat_corr6",label = "Fail 1",value = 30,min = 0,step = 1)
      }
      
    })
    
    #render the sample size test for the selected type of test
    output$s_size_tests<-renderUI({
      sample_size_type<-input$sample_size_type
      
      if(sample_size_type==1){
        s_size_test_out<-radioButtons(inputId = "sample_calc",label = "Select the Test",choices = choice_sample_size[c(1,3,5:8)])
      }
      if(sample_size_type==2){
        s_size_test_out<-radioButtons(inputId = "sample_calc",label = "Select the Test",choices = choice_sample_size[c(9:10)])
      }
      if(sample_size_type==3){
        s_size_test_out<-radioButtons(inputId = "sample_calc",label = "Select the Test",choices = choice_sample_size[c(12:14)])
      }
      if(sample_size_type==4){
        s_size_test_out<-radioButtons(inputId = "sample_calc",label = "Select the Test",choices = choice_sample_size[c(16,17,18)])
      }
      if(sample_size_type==5){
        s_size_test_out<-p("")
      }
      if(sample_size_type==6){
        s_size_test_out<-radioButtons(inputId = "sample_calc",label = "Select the Test",choices = choice_sample_size[c(11)])
      }
      
      
      s_size_test_out
      
    })
    
    #render the first reactive input field for sample size
    output$s_sizeUI1<-renderUI({
      sample_calc<-input$sample_calc
      sample_size_type<-input$sample_size_type
      
      req(sample_calc)
      
      if(sample_size_type==5){sample_calc<-15}
      
      if(sample_calc==1){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==2){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==3){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==4){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==5){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==6){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==7){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==8){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma_{\\bar{D}}:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==9){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma_{0}:{ }$$"),value = 1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==10){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma_{1}:{ }$$"),value = 1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==11){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\rho_{0}:{ }$$"),value = .0,min = 0,max = 1,step = .05)
      }
      if(sample_calc==12){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\pi_{0}:{ }$$"),value = .5,min = 0,max = 1,step = .05)
      }
      if(sample_calc==13){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\pi_{0}:{ }$$"),value = .5,min = 0,max = 1,step = .05)
      }
      if(sample_calc==14){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\pi_{1}:{ }$$"),value = .5,min = 0,max = 1,step = .05)
      }
      if(sample_calc==15){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\sigma_{w}:{ }$$"),value = 1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==16){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\lambda_{0}:{ }$$"),value = 10,min = 0,max = 1,step = .05)
      }
      if(sample_calc==17){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\lambda_{0}:{ }$$"),value = 10,min = 0,max = 1,step = .05)
      }
      if(sample_calc==18){
        s_size1_out<-numericInput(inputId = "s_sizeUI1",label = withMathJax("$$\\lambda_{1}:{ }$$"),value = 10,min = 0,max = 1,step = .05)
      }
      
      
      s_size1_out
    })
    
    #render the second reactive input field for sample size
    output$s_sizeUI2<-renderUI({
      sample_calc<-input$sample_calc
      sample_size_type<-input$sample_size_type
      
      req(sample_calc)
      
      if(sample_size_type==5){sample_calc<-15}
      
      if(sample_calc==1){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==2){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min > 0,max = 1)
      }
      if(sample_calc==3){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==4){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==5){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==6){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==7){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==8){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta_{\\bar{D}}:{ }$$"),value = 1,min = 0,max = 1)
      }
      if(sample_calc==9){
        s_size2_out<-NULL
      }
      if(sample_calc==10){
        s_size2_out<-NULL
      }
      if(sample_calc==11){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\rho_{1}:{ }$$"),value = .5,min = 0,max = 1,step = .05)
      }
      if(sample_calc==12){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\pi_{1}:{ }$$"),value = .1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==13){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\pi_{1}:{ }$$"),value = .1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==14){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\pi_{2}:{ }$$"),value = .1,min = 0,max = 1,step = .05)
      }
      if(sample_calc==15){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\Delta_{b}:{ }$$"),value = 1,min = 2,step = 1)
      }
      if(sample_calc==16){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\lambda_{1}:{ }$$"),value = 20,min = 2,step = 1)
      }
      if(sample_calc==17){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\lambda_{1}:{ }$$"),value = 20,min = 2,step = 1)
      }
      if(sample_calc==18){
        s_size2_out<-numericInput(inputId = "s_sizeUI2",label = withMathJax("$$\\lambda_{2}:{ }$$"),value = 20,min = 2,step = 1)
      }
      s_size2_out
    })
    
    #render the third reactive input field for sample size
    output$s_sizeUI3<-renderUI({
      sample_calc<-input$sample_calc
      power_s<-input$power_s
      sample_size_type<-input$sample_size_type
      
      req(sample_calc)
      
      if(sample_size_type==5){sample_calc<-15}
      
      if(sample_calc==1){
        s_size3_out<-NULL
      }
      if(sample_calc==2){
        s_size3_out<-NULL
      }
      if(sample_calc==3){
        s_size3_out<-NULL
      }
      if(sample_calc==4){
        s_size3_out<-NULL
      }
      if(sample_calc==5){
        s_size3_out<-NULL
      }
      if(sample_calc==6){
        if(power_s==T){
        s_size3_out<-numericInput(inputId = "s_sizeUI3",label = withMathJax("$$n_{2}:{ }$$"),value = 10,min = 1)
        } else s_size3_out<-NULL
      }
      if(sample_calc==7){
        if(power_s==T){
          s_size3_out<-numericInput(inputId = "s_sizeUI3",label = withMathJax("$$n_{2}:{ }$$"),value = 10,min = 1)
        } else s_size3_out<-NULL
      }
      if(sample_calc==8){
        s_size3_out<-NULL
      }
      if(sample_calc==9){
        s_size3_out<-NULL
      }
      if(sample_calc==10){
        if(power_s==T){
          s_size3_out<-numericInput(inputId = "s_sizeUI3",label = withMathJax("$$n_{2}:{ }$$"),value = 10,min = 1)}
        else{s_size3_out<-NULL}
      }
      if(sample_calc==11){
        s_size3_out<-NULL
      }
      if(sample_calc==12){
        s_size3_out<-NULL
      }
      if(sample_calc==13){
        s_size3_out<-NULL
      }
      if(sample_calc==14){
        s_size3_out<-NULL
      }
      if(sample_calc==15){
        s_size3_out<-NULL
      }
      if(sample_calc==16){
        s_size3_out<-NULL
      }
      
      if(sample_calc==17){
        s_size3_out<-NULL
      }
      if(sample_calc==18){
        if(power_s){
        s_size3_out<-numericInput(inputId = "s_sizeUI3",label = withMathJax("$$n_{2}:{ }$$"),value = 10,min = 1)
        } else {s_size3_out<-NULL}
      }
      
      s_size3_out
    })
    
    #render the fourth reactive input field for sample size
    output$s_sizeUI4<-renderUI({
      sample_calc<-input$sample_calc
      power_s<-input$power_s
      sample_size_type<-input$sample_size_type
      
      req(sample_calc)
      
      if(sample_size_type==5){sample_calc<-15}
      
      if(sample_calc==1){
        s_size4_out<-NULL
      }
      if(sample_calc==2){
        s_size4_out<-NULL
      }
      if(sample_calc==3){
        s_size4_out<-NULL
      }
      if(sample_calc==4){
        s_size4_out<-NULL
      }
      if(sample_calc==5){
        s_size4_out<-NULL
      }
      if(sample_calc==6){
        s_size4_out<-NULL
      }
      if(sample_calc==7){
        s_size4_out<-numericInput(inputId = "s_sizeUI4",label = withMathJax("$$\\sigma_{2}:{ }$$"),value = 10,min = 0,max = 1)
      }
      if(sample_calc==8){
        s_size4_out<-NULL
      }
      if(sample_calc==9){
        s_size4_out<-numericInput(inputId = "s_sizeUI4",label = withMathJax("$$\\sigma_{1}:{ }$$"),value = 2,min = 0,max = 1,step = .05)
      }
      if(sample_calc==10){
        s_size4_out<-numericInput(inputId = "s_sizeUI4",label = withMathJax("$$\\sigma_{2}:{ }$$"),value = 2,min = 0,max = 1,step = .05)
      }
      if(sample_calc==11){
        s_size4_out<-NULL
      }
      if(sample_calc==12){
        s_size4_out<-NULL
      }
      if(sample_calc==13){
        s_size4_out<-NULL
      }
      if(sample_calc==14){
        s_size4_out<-NULL
      }
      if(sample_calc==15){
        s_size4_out<-numericInput(inputId = "s_sizeUI4",label = withMathJax("$$\\text{Levels }:{ }$$"),value = 4,min = 2,step = 1)
      }
      if(sample_calc==16){
        s_size4_out<-NULL
      }
      if(sample_calc==17){
        s_size4_out<-NULL
      }
      if(sample_calc==18){
        s_size4_out<-NULL
      }
      
      s_size4_out
    })
    
    
    #render the sample size calculation output
    output$s_size_output<-renderPrint({
      s_size_results()
    })

    #render the column names as a choice list
    output$eda_choice_column <-renderUI({
      
      req(res_filter$filtered())
      choices<-seq(1:ncol(res_filter$filtered()))
      choices<-names(res_filter$filtered())
      
      output<-selectizeInput(inputId = "eda_data_selected_columns",
                                 label = "Analyze which column(s)?",
                             multiple=T,
                                 choices = choices)
      output
    })
    
    output$data_choice_column <-renderUI({
      
      req(res_filter$filtered())

      choices<-seq(1:ncol(res_filter$filtered()))
      names(choices)<-names(res_filter$filtered())
      
      output<-checkboxGroupInput(inputId = "md_data_selected_columns",
                         label = "Analyze which column(s)?",
                         choices = choices)
      output
    })
    
    output$data_choice_column_bi <-renderUI({
      
      req(res_filter$filtered())
      
      choices<-seq(1:ncol(res_filter$filtered()))
      names(choices)<-names(res_filter$filtered())
      
      output<-checkboxGroupInput(inputId = "bi_data_selected_columns",
                                 label = "Analyze which column(s)?",
                                 choices = choices)
      output
    })
    
    

    ###############################################
    
    #render the m_d_data_out
    output$m_d_data <- renderPrint({
      m_d_data_out()
    })
    
    #get the number of selected columns in md data into output
    #output$num_selected_columns_md_data<- num_selected_columns_md_data()

    

    
    #render the m_d data UI 1
    output$md_data_UI1<-renderUI({

      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      
      req(data,data_md_test_num)
      
      if (data_md_test_num==1){#one-sample z-test sample stat mean
        average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        label<-withMathJax("$\\bar{X} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
        
      }
      
      if(data_md_test_num==2){#one-sample t-test sample stat mean
        average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        label<-withMathJax("$\\bar{X} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==3){#one sample var test, sample stat std
        std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        label<-withMathJax("$s = $",std)
        #output<-paste(label,average)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==4){
        if(type==1){
          average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
          }
        else if (type==2){
          average<-ro(mean(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)])),decimal_m_d_d)
        }
        label<-withMathJax("$\\bar{X}_{1} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==5){
        if(type==1){
          average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        }
        else if (type==2){
          average<-ro(mean(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)])))
        }
        label<-withMathJax("$\\bar{X}_{1} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==6){
        return()
        # average<-ro(mean(x = data[,as.numeric(md_data_selected_columns[1])]),decimal_m_d_d)
        # label<-withMathJax("$\\bar{X}_{1} = $",average)
        # #output<-paste(label,average)
        # output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        
        if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          if(dep_t_type==1){
            average<-ro(mean(x = ave_data$g2-ave_data$g1),decimal_m_d_d)
            label<-withMathJax("$\\bar{D} = $",average)
          } else if(dep_t_type == 2){
            average<-ro(mean(x = ave_data$g1),decimal_m_d_d)
            label<-withMathJax("$\\bar{X}_{1} = $",average)
          }
          output<-HTML(paste(label))#paste(label,average))
        } else {
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          if(length(temp1)!= length(temp2)){
            return("Need equal length groups for dependent test")
          }
          temp<-na.omit(data.frame(temp1,temp2))
          if(dep_t_type==1){
            average<-ro(mean(temp$temp1-temp$temp2))
            label<-withMathJax("$\\bar{D} = $",average)
          } else if(dep_t_type==2){
            average<-ro(mean(temp$temp1))
            label<-withMathJax("$\\bar{X}_{1} = $",average)
          }
          
          output<-HTML(paste(label))
        }
      }
      
      
      output
      #data_md_test_num
      #p(data_md_test_num)
      
    })
    #render the m_d data UI 2
    output$md_data_UI2<-renderUI({
      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      req(data_md_test_num)
      
      if(data_md_test_num==1){#one samp z test parameter
        output<-numericInput(inputId = "md_data_UI2",label = withMathJax("$\\mu_{0}:{ }$"),value = 3)
      } 
      
      if(data_md_test_num==2){#one-samp t test parameter
        output<-numericInput(inputId = "md_data_UI2",label = withMathJax("$\\mu_{0}:{ }$"),value = 3)
      } 
      
      if(data_md_test_num==3){#one samp var test
        output<-numericInput(inputId = "md_data_UI2",label = withMathJax("$\\sigma_{0}:{ }$"),value = 3)
      } 
      if(data_md_test_num==4){
        
        if(type==1){
          average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[2])])),decimal_m_d_d)
        }
        else if (type==2){
          average<-ro(mean(x = data[,data_col][which(data[ref_col]==g2_num)]),decimal_m_d_d)
        }
        
        
        #average<-ro(mean(x = data[,as.numeric(md_data_selected_columns[2])]),decimal_m_d_d)
        label<-withMathJax("$\\bar{X}_{2} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==5){
        
        if(type==1){
          average<-ro(mean(x = na.omit(data[,as.numeric(md_data_selected_columns[2])])),decimal_m_d_d)
        }
        else if (type==2){
          average<-ro(mean(x = na.omit(data[,data_col][which(data[ref_col]==g2_num)])),decimal_m_d_d)
        }
        
        
        #average<-ro(mean(x = data[,as.numeric(md_data_selected_columns[2])]),decimal_m_d_d)
        label<-withMathJax("$\\bar{X}_{2} = $",average)
        #output<-paste(label,average)
        output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==6){
        return()
        # average<-ro(mean(x = data[,as.numeric(md_data_selected_columns[2])]),decimal_m_d_d)
        # label<-withMathJax("$\\bar{X}_{2} = $",average)
        # #output<-paste(label,average)
        # output<-HTML(paste(label))#paste(label,average))
      } 
      if(data_md_test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        if(dep_t_type==1){
          output<-numericInput(inputId = "md_data_UI2",label = withMathJax("$\\Delta:{ }$"),value = 0)
        } else if(dep_t_type==2){
          if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          average<-ro(mean(x = ave_data$g2),decimal_m_d_d)
          label<-withMathJax("$\\bar{X}_{2} = $",average)
          output<-HTML(paste(label))
        } else {
          req(data_col,ref_col,g1_num ,g2_num)
          
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          temp<-na.omit(data.frame(temp1,temp2))
          if(dep_t_type==1){
            output<-numericInput(inputId = "md_data_UI2",label = withMathJax("$\\Delta:{ }$"),value = 0)
          } else if(dep_t_type==2){
            average<-ro(mean(temp$temp2))
            label<-withMathJax("$\\bar{X}_{2} = $",average)
          }
          
          output<-HTML(paste(label))
        }
        }
        

      }
      
      
      output
    })
    
    #render the m_d data UI 3
    output$md_data_UI3<-renderUI({
      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      req(data_md_test_num)
      
      if(data_md_test_num==1){#one samp z test parameter
        output<-numericInput(inputId = "md_data_UI3",label = withMathJax("$\\sigma_{0}:{ }$"),value = ro(sd(na.omit(data[,as.numeric(md_data_selected_columns)])),decimal_m_d_d))
      } 
      
      if(data_md_test_num==2){#one-samp t test parameter
        std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        label<-withMathJax("$s = $",std)
        output<-HTML(paste(label))
      } 
      
      if(data_md_test_num==3){#one samp var test
        n<- length(na.omit(data[,as.numeric(md_data_selected_columns[1])]))
        label<-withMathJax("$n = $",n)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==4){
        
        if(type==1){
          std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        }
        else if (type==2){
          std<-ro(sd(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)])),decimal_m_d_d)
        }
        
        output<-numericInput(inputId = "md_data_UI3",label = withMathJax("$\\sigma_{1}:{ }$"),value = std)
        #output<-numericInput(inputId = "md_data_UI3",label = withMathJax("$\\sigma_{1}:{ }$"),value = ro(sd(data[,1]),decimal_m_d_d))
      } 
      if(data_md_test_num==5){
        
        if(type==1){
          std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[1])])),decimal_m_d_d)
        }
        else if (type==2){
          std<-ro(sd(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)])),decimal_m_d_d)
        }
        
        
        #std<-ro(sd(x = data[,as.numeric(md_data_selected_columns[1])]),decimal_m_d_d)
        label<-withMathJax("$s_{1} = $",std)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==6){
        return()
        # output<-numericInput(inputId = "md_data_UI3",label = withMathJax("$\\sigma_{1}:{ }$"),value = ro(sd(data[,1]),decimal_m_d_d))
        } 
      if(data_md_test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          if(dep_t_type==1){
            std<-ro(sd(x = ave_data$g1-ave_data$g2),decimal_m_d_d)
            label<-withMathJax("$s_{D} = $",std)
          } else if (dep_t_type==2){
            std<-ro(sd(x = ave_data$g1),decimal_m_d_d)
            label<-withMathJax("$s_{1} = $",std)
          }
          
          output<-HTML(paste(label))
        }
        else{
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          if(length(temp1)!= length(temp2)){
            return("Need equal length groups for dependent test")
          }
          temp<-na.omit(data.frame(temp1,temp2))
          if(dep_t_type==1){
            std<-ro(sd(x = temp$temp1-temp$temp2),decimal_m_d_d)
            label<-withMathJax("$s_{D} = $",std)
          } else if(dep_t_type==2){
            std<-ro(sd(x = temp$temp1),decimal_m_d_d)
            label<-withMathJax("$s_{2} = $",std)
          }

          output<-HTML(paste(label))
        }
      }
      
      output
    })
    
    #render the m_d data UI 4
    output$md_data_UI4<-renderUI({
      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      
      req(data_md_test_num)
      
      if(data_md_test_num==1){#one samp z test parameter
        output<-NULL
      } 
      
      if(data_md_test_num==2){#one-samp t test parameter
        output<-NULL
      } 
      
      if(data_md_test_num==3){#one samp var test
        output<-NULL
      } 
      if(data_md_test_num==4){
        
        if(type==1){
          std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[2])])),decimal_m_d_d)
        }
        else if (type==2){
          std<-ro(sd(x = na.omit(data[,data_col][which(data[ref_col]==g2_num)])),decimal_m_d_d)
        }
        output<-numericInput(inputId = "md_data_UI4",label = withMathJax("$\\sigma_{2}:{ }$"),value = std)
        
        #output<-numericInput(inputId = "md_data_UI4",label = withMathJax("$\\sigma_{2}:{ }$"),value = ro(sd(data[,2]),decimal_m_d_d))
      } 
      if(data_md_test_num==5){
        if(type==1){
          std<-ro(sd(x = na.omit(data[,as.numeric(md_data_selected_columns[2])])),decimal_m_d_d)
        }
        else if (type==2){
          std<-ro(sd(x = na.omit(data[,data_col][which(data[ref_col]==g2_num)])),decimal_m_d_d)
        }
        
        #std<-ro(sd(x = data[,as.numeric(md_data_selected_columns[2])]),decimal_m_d_d)
        label<-withMathJax("$s_{2} = $",std)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==6){
        # output<-numericInput(inputId = "md_data_UI4",label = withMathJax("$\\sigma_{2}:{ }$"),value = ro(sd(data[,2]),decimal_m_d_d))
        return()
      } 
      if(data_md_test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        if(dep_t_type==1){return(NULL)}
        if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          std<-ro(sd(x = ave_data$g2),decimal_m_d_d)
          label<-withMathJax("$s_{2} = $",std)
          output<-HTML(paste(label))
        } else{
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          temp<-na.omit(data.frame(temp1,temp2))
          std<-ro(sd(x = temp$temp2),decimal_m_d_d)
          label<-withMathJax("$s_{2} = $",std)
          output<-HTML(paste(label))
        }
        
      }
      
      output
    })
    
    #render the m_d data UI 5
    output$md_data_UI5<-renderUI({
      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      req(data_md_test_num)
      
      if(data_md_test_num==1){#one samp z test parameter
        n<- length(na.omit(data[,as.numeric(md_data_selected_columns[1])]))
        label<-withMathJax("$n = $",n)
        output<-HTML(paste(label))
      } 
      
      if(data_md_test_num==2){#one-samp t test parameter
        n<- length(na.omit(data[,as.numeric(md_data_selected_columns[1])]))
        label<-withMathJax("$n = $",n)
        output<-HTML(paste(label))
      } 
      
      if(data_md_test_num==3){#one samp var test
        output<-NULL
      } 
      if(data_md_test_num==4){
        
        if(type==1){
          n<-length(x = na.omit(data[,as.numeric(md_data_selected_columns[1])]))
        }
        else if (type==2){
          n<-length(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)]))
        }
        
        
        #n<- length(data[,as.numeric(md_data_selected_columns[1])])
        label<-withMathJax("$n_{1} = $",n)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==5){
        
        if(type==1){
          n<-length(x = na.omit(data[,as.numeric(md_data_selected_columns[1])]))
        }
        else if (type==2){
          n<-length(x = na.omit(data[,data_col][which(data[ref_col]==g1_num)]))
        }
        
        
        #n<- length(data[,as.numeric(md_data_selected_columns[1])])
        label<-withMathJax("$n_{1} = $",n)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==6){
        return()
        # n<- length(data[,as.numeric(md_data_selected_columns[1])])
        # label<-withMathJax("$n = $",n)
        # output<-HTML(paste(label))
      } 
      if(data_md_test_num==7){
        if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          n<-length(x = ave_data$g1)
          label<-withMathJax("$n = $",n)
          output<-HTML(paste(label))
        } else {
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          if(length(temp1)!= length(temp2)){
            return("Need equal length groups for dependent test")
          }
          n<-nrow(na.omit(data.frame(temp1,temp2)))
          label<-withMathJax("$n = $",n)
          output<-HTML(paste(label))
        }
        
      }
      
      output
    })
    
    #render the m_d data UI 6
    output$md_data_UI6<-renderUI({
      data_md_test_num<-data_md_test_num()
      md_data_selected_columns<-input$md_data_selected_columns
      data<-res_filter$filtered()
      decimal_m_d_d<-input$decimal_m_d_d
      
      type<-input$data_type_md
      ref_col<-as.numeric(input$data_choice_ref)
      data_col<-as.numeric(input$data_choice_data)
      g1_num<-input$data_choice_g1
      g2_num<-input$data_choice_g2
      
      
      
      req(data_md_test_num)
      
      if(data_md_test_num==1){#one samp z test parameter
        output<-NULL
      } 
      
      if(data_md_test_num==2){#one-samp t test parameter
        output<-NULL
      } 
      
      if(data_md_test_num==3){#one samp var test
        output<-NULL
      } 
      if(data_md_test_num==4){
        
        if(type==1){
          n<-length(x = na.omit(data[,as.numeric(md_data_selected_columns[2])]))
        }
        else if (type==2){
          n<-length(x = na.omit(data[,data_col][which(data[ref_col]==g2_num)]))
        }
        label<-withMathJax("$n_{2} = $",n)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==5){
        
        if(type==1){
          n<-length(x = na.omit(data[,as.numeric(md_data_selected_columns[2])]))
        }
        else if (type==2){
          n<-length(x = na.omit(data[,data_col][which(data[ref_col]==g2_num)]))
        }
        label<-withMathJax("$n_{2} = $",n)
        output<-HTML(paste(label))
      } 
      if(data_md_test_num==6){
        
          return()
          # x_y<- ro(cor(data[,as.numeric(md_data_selected_columns[1])],data[,as.numeric(md_data_selected_columns[2])]),decimal_m_d_d)
          # label<-withMathJax("$r_{12} = $",x_y)
          # output<-HTML(paste(label))
        
      } 
      if(data_md_test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        if(dep_t_type==1){return(NULL)}
        if(type==1){
          ave_data<-na.omit(data.frame(g1=data[,as.numeric(md_data_selected_columns[1])],g2=data[,as.numeric(md_data_selected_columns[2])]))
          x_y<-ro(cor(ave_data$g1,ave_data$g2),decimal_m_d_d)
          label<-withMathJax("$r_{12} = $",x_y)
          output<-HTML(paste(label))
        } else{
          req(data_col,ref_col,g1_num ,g2_num)
          temp1<-data[,data_col][which(data[ref_col]==g1_num)]
          temp2<-data[,data_col][which(data[ref_col]==g2_num)]
          temp<-na.omit(data.frame(temp1,temp2))
          
          x_y<- ro(cor(temp$temp1,temp$temp2),decimal_m_d_d)
          label<-withMathJax("$r_{12} = $",x_y)
          output<-HTML(paste(label))
        }
        
        
      }
      
      output
    })
    
    
    #render the md data dep or indep choice
    output$md_data_indep<-renderUI({
      num_columns<-num_selected_columns_md_data()
      type<-input$data_type_md#1=col 2=ref
      
      if(
        (type==1 && (num_columns==0 || num_columns>2 || num_columns==1))
        # ||
        # (type==2 && is.null(input$data_choice_ref))
      )
        {output<-NULL}
      # else if(type==1 && num_columns==1){
      #   output<-selectInput(inputId = "dep_or_indep_data",
      #               label = "One-Sample Test",
      #               choices = c("Independent"=1))
      #}
      else if(type==1 && num_columns==2){
        output<-selectInput(inputId = "dep_or_indep_data",
                    label = "Independent or Dependent Test?",
                    choices = c("Independent"=1,"Dependent"=2))
      }else if (type==2){
        # output<-selectInput(inputId = "dep_or_indep_data",
        #                     label = "Independent Data Only",
        #                     choices = c("Independent"=1))
        output<-selectInput(inputId = "dep_or_indep_data",
                            label = "Independent or Dependent Test?",
                            choices = c("Independent"=1,"Dependent"=2))
      }
      
      output
    })
      
    output$md_data_one_samp_var<-renderUI({
      num_columns<-num_selected_columns_md_data()
      sigma_known_data<-input$sigma_known_data
      type<-input$data_type_md
      req(type,num_columns,sigma_known_data)
      
      if(num_columns==1 && sigma_known_data==1 && type==1){
        output<-checkboxInput(inputId = "md_one_samp_var",
                    label = "One-sample test for variance?",
                    value = F)
        } else output<-NULL
      
      output
      
    })
    
    #render the alternative hypotheses for  md data
    output$alt_mean_data<-renderUI({
      
      
      test_num<-data_md_test_num()
      
      req(test_num)
      
      #num_col_selected<-length(md_data_selected_columns)
      

      if (test_num==1){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_1)
      }
      if (test_num==2){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_1)
      }
      if (test_num==3){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_sd_alt_1)
      }
      if (test_num==4){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_2)
      }
      if (test_num==5){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_2)
      }
      if (test_num==6){
        output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_2)
      }
      if (test_num==7){
        dep_t_type<-input$md_t_dep_type
        req(dep_t_type)
        if(dep_t_type==1){
          output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_3)
        } else if (dep_t_type==2){
          output_data_alt<-selectInput(inputId = "one_or_two_md_data",label = "Alternative Hypothesis for Means",choices = choice_mean_alt_2)
        }
        
      }
      output_data_alt
    })
    
     output$pretty_md <-renderUI({
       
       results<-mean_out()

       conf<-input$conf
       UI1<- input$md_UI1
       UI2<- input$md_UI2
       UI3<- input$md_UI3
       UI4<- input$md_UI4
       UI5<- input$md_UI5
       UI6<- input$md_UI6
       alt<-input$md_alt
       R <- input$decimal
       md_test_num<-md_test_num()
       
       req(alt,md_test_num,results)

       if(alt=="two.sided"){
         alt_num<-1
       }
           if (alt=="less"){
             alt_num<- 2
           }
               if (alt=="greater"){
                 alt_num<-3
                 }
       
       #resultsR<-ro(results,R) #rounded version for when I don't need to directly calculate something
       
       if(md_test_num==1){#one sample z statistics pretty output
       output<-HTML(c(paste("<b>",results$method,"</b>"),
               "<br><br>",
               "<table>",
                "<tr>",
                  "<td>",paste(withMathJax("$\\bar{X} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\mu_{0}=$"),results$parameter),"</td>",
                "</tr>",
                "<tr>",
                  "<td>",paste(withMathJax("$\\sigma = $"),ro(UI3,R)),"</td>",
                "</tr>",
                "<tr>",
                  "<td>",paste(withMathJax("$n = $"),UI5),"</td>",
                "</tr>",
               "</table>",
               
               "<table>",
                "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\mu :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",     
                  "<td>",results$conf.int[2],"</td>",
                "</tr>",
               "</table>",
               
               "<table>",
                "<tr>",
                  "<td>",paste("Test for ",names(choice_mean_alt_1[alt_num]),": "),"</td>",
                  "<td>",paste("z = ",results$statistic,"&emsp;"),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                "</tr>",
               "</table>",
               
               #"<br><br>",
               paste(beta_statement,100*results$estimate[4],"%")
               )
       )
       }
       if(md_test_num==2){#one sample t test pretty
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X} = $"),results$estimate[1]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{0}=$"),results$parameter),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s = $"),ro(UI3,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),UI5),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma :$")),"</td>",
                        "<td>",results$estimate[7],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$estimate[9],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("t = ",results$statistic,"&emsp;"),"</td>",
                        "<td>","df =",results$estimate[3],"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        
                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[10],"%")
                        )
         )
         }
       
       if(md_test_num==3){#one sample var statistics pretty output
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s = $"),ro(UI1,R)),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{0}=$"),ro(UI2,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\sigma :$")),"</td>",
                        "<td>",ro(results$conf.int[1]^.5,R),"</td>",#needs to use original calculation, not rounded one
                        "<td>"," to ","</td>",     
                        "<td>",ro(results$conf.int[2]^.5,R),"</td>",#needs to use original calculation, not rounded one
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_sd_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste(withMathJax("$\\chi^2 = $"),results$statistic),"</td>",
                        "<td>",paste("df = ",results$estimate[2]),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        
                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[4],"%")
         )
         )
       }
       
       if(md_test_num==4){#two sample z test pretty
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results$estimate[3]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results$estimate[7]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\sigma_{1} = $"),ro(UI3,R)),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{2} = $"),ro(UI4,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1} = $"),UI5),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2} = $"),UI6),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                        "<td>",results$estimate[4],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$estimate[5],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                        "<td>",results$estimate[8],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$estimate[9],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("z = ",results$statistic,"&emsp;"),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
                        
         )
         )
       }
       
       if(md_test_num==5){#two sample t test indepedent pretty
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results$estimate[4]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results$estimate[14]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s_{1} = $"),ro(UI3,R)),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$s_{2} = $"),ro(UI4,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1} = $"),UI5),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2} = $"),UI6),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                          "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                          "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                          "<td>",results$estimate[5],"</td>",
                          "<td>"," to ","</td>",     
                          "<td>",results$estimate[6],"</td>",
                        "</tr>",
                        "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                          "<td>",results$estimate[15],"</td>",
                          "<td>"," to ","</td>",     
                          "<td>",results$estimate[16],"</td>",
                        "</tr>",
                        "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\sigma_{1} :$")),"</td>",
                          "<td>",results$estimate[12],"</td>",
                          "<td>"," to ","</td>",     
                          "<td>",results$estimate[13],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{2} :$")),"</td>",
                        "<td>",results$estimate[22],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$estimate[23],"</td>",
                        
                        "</tr>",
                        "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                          "<td>",results$conf.int[1],"</td>",
                          "<td>"," to ","</td>",     
                          "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",withMathJax("$\\sigma_{1}^2=\\sigma_{2}^2$"),": "),"</td>",
                        "<td>",paste("F = "),results$estimate[25],"</td>",
                        "<td>","df =",results$estimate[26],"/",results$estimate[27],"</td>",
                        "<td>",paste("p = ",results$estimate[28],if(results$estimate[28]<1-conf){"*"}),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("t = ",results$statistic),"</td>",
                        "<td>","df =",results$estimate[3],"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
         )
         )
       }
       if(md_test_num==6){output<-NULL}
       
       if(md_test_num==7){#two sample t test dependent pretty
         #req(UI6<=1,UI5,conf)
         t_dep_type<-input$md_t_dep_type_stat #1=d-bar 2=meandiff
         req(t_dep_type)
         if(t_dep_type==1){#d-bar
           output<-HTML(c(paste("<b>",results$method,"</b>"),
                          "<br><br>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(withMathJax("$\\bar{D} = $"),results[["estimate"]][["sample.mean"]]),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\Delta=$"),results[["parameter"]][["null hypothesis mean"]]),"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$s_{D} = $"),results[["estimate"]][["sd"]]),"</td>",
                          "</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$n = $"),results[["estimate"]][["df"]]+1),"</td>",
                          "</td>","</tr>",
                          "</table>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                          "<td>",paste(withMathJax("$\\Delta :$")),"</td>",
                          "<td>",results[["conf.int"]][1],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results[["conf.int"]][2],"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\sigma_{D} :$")),"</td>",
                          "<td>",results[["estimate"]][["sd.lowerci"]],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results[["estimate"]][["sd.upperci"]],"</td>",
                          "</tr>",
                          "</table>",
                          "<br>",
                          
                          "<table>",
                          "<td>",paste("$\\bar{D}$ Test for ",names(choice_mean_alt_3[alt_num]),": "),"</td>",
                          "<td>",paste("t = ",results[["statistic"]][["t statistic"]]),"</td>",
                          "<td>",paste("df =",results[["estimate"]][["df"]]),"</td>",
                          "<td>",paste("p = ",results[["p.value"]],if(results[["p.value"]]<1-conf){"*"}),"</td>",
                          "</tr>",
                          "</table>"
           )
           )
         } else if (t_dep_type==2){
           req(UI4,UI5,UI6<=1)
           #slight detour to get test for correlation
           corr_test<-cor.pearson.r.onesample.simple(sample.r = UI6,sample.size = UI5,null.hypothesis.rho = 0,conf.level = conf)
           corr_test<-ro(corr_test,R)
           
           output<-HTML(c(paste("<b>",results$method,"</b>"),
                          "<br><br>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results$estimate[5]),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results$estimate[14]),"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$s_{1} = $"),ro(UI3,R)),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$s_{2} = $"),ro(UI4,R)),"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$n = $"),UI5),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$r_{xy} = $"),UI6),"</td>",
                          "</tr>",
                          "</table>",
                          
                          "<table>",
                          "<tr>",
                          "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                          "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                          "<td>",results$estimate[6],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results$estimate[7],"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                          "<td>",results$estimate[15],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results$estimate[16],"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\sigma_{1} :$")),"</td>",
                          "<td>",results$estimate[12],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results$estimate[13],"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\sigma_{2} :$")),"</td>",
                          "<td>",results$estimate[21],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results$estimate[22],"</td>",
                          
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                          "<td>",results$conf.int[1],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results$conf.int[2],"</td>",
                          "</tr>",
                          "</table>",
                          
                          "<table>",
                          "<tr>",
                          "<td>",paste("Test for ",withMathJax("$\\rho=0$"),": "),"</td>",
                          "<td>",paste("t = "),corr_test$statistic,"</td>",#rho test
                          "<td>","df =",corr_test$estimate[2],"</td>",#rho test
                          "<td>",paste("p = ",corr_test$p.value,if(corr_test$p.value<1-conf){"*"}),"</td>",#rho test
                          "</tr>",
                          "<tr>",
                          "<td>",paste("Dependent test for ",withMathJax("$\\sigma_{1}^2=\\sigma_{2}^2$"),": "),"</td>",
                          "<td>",paste("t = "),results$estimate[24],"</td>",
                          "<td>","df =",results$estimate[25],"</td>",
                          "<td>",paste("p = ",results$estimate[26],if(results$estimate[26]<1-conf){"*"}),"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste("Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                          "<td>",paste("t = ",results$statistic),"</td>",
                          "<td>","df =",results$estimate[3],"</td>",
                          "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                          "</tr>",
                          "</table>"
           )
           )
         }
         
       }
       
       output

     })
     
     
     output$pretty_md_data <-renderUI({
       
       results<-m_d_data_out()#this is already rounded
       
       conf<-input$conf_m_d_data
       UI1<- input$md_data_UI1
       UI2<- input$md_data_UI2
       UI3<- input$md_data_UI3
       UI4<- input$md_data_UI4
       UI5<- input$md_data_UI5
       UI6<- input$md_data_UI6
       alt<-input$one_or_two_md_data
       R <- input$decimal_m_d_d
       md_test_num<-data_md_test_num()
       req(alt,md_test_num)
       md_data_selected_columns<-as.numeric(input$md_data_selected_columns)
       data<-res_filter$filtered()
       type<-input$data_type_md
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       #resultsR<-ro(results,R) #rounded version for when I don't need to directly calculate something
       
       if(md_test_num==1){#one sample z statistics pretty output
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X} = $"),results$estimate[1]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{0}=$"),results$parameter),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\sigma = $"),ro(UI3,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results$estimate[2]),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("z = ",results$statistic,"&emsp;"),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        
                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[4],"%")
         )
         )
       }
       if(md_test_num==2){#one sample t test pretty
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X} = $"),results$estimate[1]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{0}=$"),results$parameter),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s = $"),results$estimate[8]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results$estimate[3]+1),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma :$")),"</td>",
                        "<td>",results$estimate[7],"</td>",
                        "<td>"," to ","</td>",     
                        "<td>",results$estimate[9],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("t = ",results$statistic,"&emsp;"),"</td>",
                        "<td>","df =",results$estimate[3],"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        
                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[10],"%")
         )
         )
       }
       
       if(md_test_num==3){#one sample var statistics pretty output
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s = $"),ro(results$estimate[1]^.5,R)),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{0}=$"),ro(UI2,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\sigma :$")),"</td>",
                        "<td>",ro(results$conf.int[1]^.5,R),"</td>",#needs to use original calculation, not rounded one
                        "<td>"," to ","</td>",     
                        "<td>",ro(results$conf.int[2]^.5,R),"</td>",#needs to use original calculation, not rounded one
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_sd_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste(withMathJax("$\\chi^2 = $"),results$statistic),"</td>",
                        "<td>",paste("df = ",results$estimate[2]),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        
                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[4],"%")
         )
         )
       }
       
       if(md_test_num==4){#two sample z test independent pretty
         #only simple data entry at this point I guess
         if (type==1){#columns
           group1_name<-names(data)[md_data_selected_columns[1]]
           group2_name<-names(data)[md_data_selected_columns[2]]
         } else{#reference
           group1_name<-paste("Group 1 = ",input$data_choice_g1)
           group2_name<-paste("Group 2 = ",input$data_choice_g2)
         }
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                        "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results$estimate[3]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results$estimate[7]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\sigma_{1} = $"),ro(UI3,R)),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{2} = $"),ro(UI4,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1} = $"),results$estimate[6]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2} = $"),results$estimate[10]),"</td>",
                        "</tr>",
                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                        "<td>",results$estimate[4],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[5],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                        "<td>",results$estimate[8],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[9],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",

                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("z = ",results$statistic,"&emsp;"),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"

         )
         )
       }
       
       if(md_test_num==5){#two sample t test independent pretty
         
         #type<-input$data_type_md
         req(data,type)
         if(type==1){
           req(md_data_selected_columns)
           g1<-na.omit(data[,md_data_selected_columns[1]])
           g2<-na.omit(data[,md_data_selected_columns[2]])
           
           g1_ada<-dispersion.ADA(g1)
           g2_ada<-dispersion.ADA(g2)
           
           levene<-t.test.twosample.independent(g1 = g1_ada,g2 = g2_ada)
           #adm_n1<-variance.test.twosample.independent(g1 = g1,g2 = g2,conf.level = conf,assume.normality = F) bug in lolcat assumes equal variance
           g1_adm<-na.omit(dispersion.ADMn1(g1))
           g2_adm<-na.omit(dispersion.ADMn1(g2))
           adm_n1<-t.test.twosample.independent(g1 = g1_adm,g2 = g2_adm,assume.equal.variances=FALSE)#should this be universal to Levene, ADM, ADMn1?
           
           adm_n1<-ro(adm_n1,R)
           group1_name<-names(data)[md_data_selected_columns[1]]
           group2_name<-names(data)[md_data_selected_columns[2]]
         } else
           
           if(type==2){
             
             ref_col<-as.numeric(input$data_choice_ref)
             data_col<-as.numeric(input$data_choice_data)
             g1_col<-input$data_choice_g1
             g2_col<-input$data_choice_g2
             req(ref_col,data_col,g1_col,g2_col)
             g1<-data[,data_col][which(data[ref_col]==g1_col)]
             g2<-data[,data_col][which(data[ref_col]==g2_col)]
             #mean_data<-na.omit(data.frame(g1,g2))
             
             g1_ada<-dispersion.ADA(x = g1)
             g2_ada<-dispersion.ADA(x = g2)
             
             g1_adm_n1<-na.omit(dispersion.ADMn1(x = g1))
             g2_adm_n1<-na.omit(dispersion.ADMn1(x = g2))
             
             levene<-t.test.twosample.independent(g1 = g1_ada,g2 = g2_ada)
             adm_n1<-t.test.twosample.independent(g1 = g1_adm_n1,g2 = g2_adm_n1)
             group1_name<-paste("Group 1 = ",input$data_choice_g1)
             group2_name<-paste("Group 2 = ",input$data_choice_g2)
           }
         
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                        "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results$estimate[4]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results$estimate[14]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s_{1} = $"),results$estimate[11]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$s_{2} = $"),results$estimate[21]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1} = $"),results$estimate[7]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2} = $"),results$estimate[17]),"</td>",
                        "</tr>",
                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                        "<td>",results$estimate[5],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[6],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                        "<td>",results$estimate[15],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[16],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{1} :$")),"</td>",
                        "<td>",results$estimate[12],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[13],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{2} :$")),"</td>",
                        "<td>",results$estimate[22],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$estimate[23],"</td>",

                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste("Tests for ",withMathJax("$\\sigma_{1}^2=\\sigma_{2}^2$"),": "),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td align='right'>","F-test","</td>",
                        "<td>",paste("F = "),results$estimate[25],"</td>",
                        "<td>","df =",results$estimate[26],"/",results$estimate[27],"</td>",
                        "<td>",paste("p = ",results$estimate[28],if(results$estimate[28]<1-conf){"*"}),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td align='right'>","Levene's Test (ADA)","</td>",
                        "<td>",paste("t = ",ro(levene$statistic,R)),"</td>",
                        "<td>",paste("df = ",ro(levene$estimate[3],R)),"</td>",
                        "<td>",paste("p = ",ro(levene$p.value,R),if(levene$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td align='right'>",paste("ADM",withMathJax("$_{n-1} $")),"</td>",
                        "<td>",paste("t = ",ro(adm_n1$statistic,R)),"</td>",
                        "<td>",paste("df = ", ro(adm_n1$estimate[3],R)),"</td>",
                        "<td>",paste("p = ", ro(adm_n1$p.value,R),if(adm_n1$p.value<1-conf){"*"}),"</td>",
                        "</tr>",

                        "<tr>",
                        "<td>",paste("Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("t = ",results$statistic),"</td>",
                        "<td>","df =",results$estimate[3],"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
         )
         )
       }
       if(md_test_num==6){output<-p("No test available")}
       
       if(md_test_num==7){#data two sample t test dependent pretty
         if(results[1]=="Need equal length groups for dependent test"){return(results)}
         t_dep_type<-input$md_t_dep_type #1=d-bar 2=meandiff
         req(t_dep_type)
         if(t_dep_type==1){#d-bar

           #type<-input$data_type_md
           req(data,type)
           
           req(data,type)
           if(type==1){
             req(md_data_selected_columns)
             g1<-data[,md_data_selected_columns[1]]
             g2<-data[,md_data_selected_columns[2]]
             mean_data<-na.omit(data.frame(g1,g2))
             group1_name<-names(data)[md_data_selected_columns[1]]
             group2_name<-names(data)[md_data_selected_columns[2]]
           } else{
             ref_col<-as.numeric(input$data_choice_ref)
             data_col<-as.numeric(input$data_choice_data)
             g1_col<-input$data_choice_g1
             g2_col<-input$data_choice_g2
             req(ref_col,data_col,g1_col,g2_col)
             g1<-data[,data_col][which(data[ref_col]==g1_col)]
             g2<-data[,data_col][which(data[ref_col]==g2_col)]
             mean_data<-na.omit(data.frame(g1,g2))
             group1_name<-"Group 1"
             group2_name<-"Group 2"
           }
           
           req(mean_data)
           
               
               mp_var_norm<-variance.test.twosample.dependent(g1 = mean_data$g1,g2 = mean_data$g2,conf.level = conf,assume.normality = "yes")
               mp_var_nonnorm<-variance.test.twosample.dependent(g1 = mean_data$g1,g2 = mean_data$g2,conf.level = conf,assume.normality = "no",non.norm.method = "dbar")
               mp_var_norm<-ro(mp_var_norm,R)
               mp_var_nonnorm<-ro(mp_var_nonnorm,R)
           
           
           dep_var<-variance.test.twosample.dependent
           output<-HTML(c(paste("<b>",results$method,"</b>"),
                          "<br>",
                          paste(withMathJax("$\\bar{D} $")," calculated from ",group2_name," - ",group1_name),
                          "<br><br>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(withMathJax("$\\bar{D} = $"),results[["estimate"]][["sample.mean"]]),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\Delta=$"),results[["parameter"]][["null hypothesis mean"]]),"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$s_{D} = $"),results[["estimate"]][["sd"]]),"</td>",
                          "</td>",
                          "</tr>",
                          "<tr>",
                          "<td>",paste(withMathJax("$n = $"),results[["estimate"]][["df"]]+1),"</td>",
                          "</td>","</tr>",
                          "</table>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                          "<td>",paste(withMathJax("$\\Delta :$")),"</td>",
                          "<td>",results[["conf.int"]][1],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results[["conf.int"]][2],"</td>",
                          "</tr>",
                          "<tr>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\sigma_{D} :$")),"</td>",
                          "<td>",results[["estimate"]][["sd.lowerci"]],"</td>",
                          "<td>"," to ","</td>",
                          "<td>",results[["estimate"]][["sd.upperci"]],"</td>",
                          "</tr>",
                          "</table>",
                          "<br>",
                          
                          "<table>",
                          "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If normal use ",mp_var_norm$method,"</i></td></tr>",
                          "<tr>",
                          "<td>",paste("Normal Dependent Test for ",withMathJax("$\\sigma_{1}^2=\\sigma_{2}^2$"),": "),"</td>",
                          "<td>",paste("t = ",mp_var_norm$statistic),"</td>",#
                          "<td>",paste("df =",mp_var_norm$estimate[5]),"</td>",#
                          "<td>",paste("p = ",mp_var_norm$p.value,if(mp_var_norm$p.value<1-conf){"*"}),"</td>",#
                          "</tr>",
                          "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If non-normal use ",mp_var_nonnorm$method,"</i></td></tr>",
                          "<tr>",
                          "<tr>",
                          "<td>",paste("Non-normal Dependent Test for ",withMathJax("$ADM_{n-1}$"),": "),"</td>",
                          "<td>",paste("t = ",mp_var_nonnorm[["statistic"]][["t statistic"]]),"</td>",#
                          "<td>",paste("df =",mp_var_nonnorm[["estimate"]][["df"]]),"</td>",#
                          "<td>",paste("p = ",mp_var_nonnorm$p.value,if(mp_var_nonnorm$p.value<1-conf){"*"}),"</td>",#
                          "</tr><tr><td></td></tr>",
                          "<td>",paste("$\\bar{D}$ Test for ",names(choice_mean_alt_3[alt_num]),": "),"</td>",
                          "<td>",paste("t = ",results[["statistic"]][["t statistic"]]),"</td>",
                          "<td>",paste("df =",results[["estimate"]][["df"]]),"</td>",
                          "<td>",paste("p = ",results[["p.value"]],if(results[["p.value"]]<1-conf){"*"}),"</td>",
                          "</tr>",
                          "</table>"
           )
           )
           
         } else if(t_dep_type==2){
           #slight detour to get test for correlation
         type<-input$data_type_md
         req(data,type)
         
         req(data,type)
         if(type==1){
           req(md_data_selected_columns)
           g1<-data[,md_data_selected_columns[1]]
           g2<-data[,md_data_selected_columns[2]]
           mean_data<-na.omit(data.frame(g1,g2))
           group1_name<-names(data)[md_data_selected_columns[1]]
           group2_name<-names(data)[md_data_selected_columns[2]]
         } else{
           ref_col<-as.numeric(input$data_choice_ref)
           data_col<-as.numeric(input$data_choice_data)
           g1_col<-input$data_choice_g1
           g2_col<-input$data_choice_g2
           req(ref_col,data_col,g1_col,g2_col)
           g1<-data[,data_col][which(data[ref_col]==g1_col)]
           g2<-data[,data_col][which(data[ref_col]==g2_col)]
           mean_data<-na.omit(data.frame(g1,g2))
           group1_name<-paste("Group 1 = ",input$data_choice_g1)
           group2_name<-paste("Group 2 = ",input$data_choice_g2)
         }
         
         req(mean_data)
         
         
         corr_test<-cor.pearson.r.onesample(x = mean_data$g1,y = mean_data$g2,null.hypothesis.rho = 0,conf.level = conf)
         corr_test<-ro(corr_test,R)
         
         #mean1<-ro(mean(data[,as.numeric(md_data_selected_columns[1])]),R)
         #mean2<-ro(mean(data[,as.numeric(md_data_selected_columns[2])]),R)
         mp_var_norm<-variance.test.twosample.dependent(g1 = mean_data$g1,g2 = mean_data$g2,conf.level = conf,assume.normality = "yes")
         mp_var_nonnorm<-variance.test.twosample.dependent(g1 = mean_data$g1,g2 = mean_data$g2,conf.level = conf,assume.normality = "no",non.norm.method = "meandiff")
         mp_var_norm<-ro(mp_var_norm,R)
         mp_var_nonnorm<-ro(mp_var_nonnorm,R)
         
         output<-HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                        "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$\\bar{X}_{1} = $"),results[["estimate"]][["g1.mean"]]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\bar{X}_{2}=$"),results[["estimate"]][["g2.mean"]]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$s_{1} = $"),results[["estimate"]][["g1.sd"]]),"</td>",
                        "</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$s_{2}=$"),results[["estimate"]][["g2.sd"]]),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results[["estimate"]][["sample.size"]]),"</td>",
                        "</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$r_{12} = $"),corr_test$estimate[1]),"</td>",
                        "</tr>",
                        "</table>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\mu_{1} :$")),"</td>",
                        "<td>",results[["estimate"]][["g1.mean.lowerci"]],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results[["estimate"]][["g1.mean.upperci"]],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{2} :$")),"</td>",
                        "<td>",results[["estimate"]][["g2.mean.lowerci"]],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results[["estimate"]][["g2.mean.upperci"]],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{1} :$")),"</td>",
                        "<td>",results[["estimate"]][["g1.sd.lowerci"]],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results[["estimate"]][["g1.sd.upperci"]],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\sigma_{2} :$")),"</td>",
                        "<td>",results[["estimate"]][["g2.sd.lowerci"]],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results[["estimate"]][["g2.sd.upperci"]],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\rho_{12} :$")),"</td>",
                        "<td>",corr_test$conf.int[1],"</td>",
                        "<td>","to","</td>",
                        "<td>",corr_test$conf.int[2],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\mu_{1}-\\mu_{2} :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        "<br>",

                        "<table>",
                        "<tr>",
                        "<td>",paste("Correlation Test ",withMathJax("$\\rho_{12}=0$")),":</td>",
                        "<td>",paste("t = ",corr_test$statistic),"</td>",
                        "<td>",paste("df = ",corr_test$estimate[2]),"</td>",
                        "<td>",paste("p = ",corr_test$p.value,if(corr_test$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If normal use ",mp_var_norm$method,"</i></td></tr>",
                        "<tr>",
                        "<td>",paste("Normal Dependent Test for ",withMathJax("$\\sigma_{1}^2=\\sigma_{2}^2$"),": "),"</td>",
                        "<td>",paste("t = ",mp_var_norm$statistic),"</td>",#
                        "<td>",paste("df =",mp_var_norm$estimate[5]),"</td>",#
                        "<td>",paste("p = ",mp_var_norm$p.value,if(mp_var_norm$p.value<1-conf){"*"}),"</td>",#
                        "</tr>",
                        "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If non-normal use ",mp_var_nonnorm$method,"</i></td></tr>",
                        "<tr>",
                        "<tr>",
                        "<td>",paste("Non-normal Dependent Test for ",withMathJax("$ADM_{n-1}$"),": "),"</td>",
                        "<td>",paste("t = ",mp_var_nonnorm[["statistic"]][["t statistic"]]),"</td>",#
                        "<td>",paste("df =",mp_var_nonnorm[["estimate"]][["df"]]),"</td>",#
                        "<td>",paste("p = ",mp_var_nonnorm$p.value,if(mp_var_nonnorm$p.value<1-conf){"*"}),"</td>",#
                        "</tr><tr><td></td></tr>",
                        "<tr>",
                        "<td>",paste("Paired Test for ",names(choice_mean_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("t = ",results$statistic),"</td>",
                        "<td>",paste("df =",results$estimate[3]),"</td>",
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
         )
         )
         }
         
         
       }
       
       output
       
     })
     
     #render UI elements for the mean dispersion statistics entry#####################
     output$onesample_md<-renderUI({
       one_or_two<-input$one_or_two
       sigma_known<-input$sigma_known
       req(one_or_two,sigma_known)
       
       if(one_or_two==1 && sigma_known==1){
       checkboxInput(inputId = "one_samp_var",
                     label = "One-sample test for variance?",
                     value = F)
       } else NULL
       
     })
     
     output$alt_md<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num>0 && md_test_num<3){
       
       output<-selectInput(inputId = "md_alt",
                   label = "Alternative Hypothesis for Means",
                   choices = choice_mean_alt_1
       )
       }
       else if(md_test_num==3){
         output<-selectInput(inputId = "md_alt",
                     label = "Alternative Hypothesis for Variance",
                     choices = choice_sd_alt_1
         )
         
       }
       else if(md_test_num>3 && md_test_num<7){
         
         output<-selectInput(inputId = "md_alt",
                     label = "Alternative Hypothesis for Means",
                     choices = choice_mean_alt_2
         )
       } else if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           output<-selectInput(inputId = "md_alt",
                               label = "Alternative Hypothesis for Means",
                               choices = choice_mean_alt_3
           )
         } else if (dep_t_type==2){
           output<-selectInput(inputId = "md_alt",
                               label = "Alternative Hypothesis for Means",
                               choices = choice_mean_alt_2
           )
         }
       }
       output
       
     })
     
     output$md_dep_or_indep<-renderUI({
       one_or_two<-input$one_or_two
       req(one_or_two)
       
       if(one_or_two==2){
         output<-selectInput(inputId = "dep_or_indep",
                     label = "Independent or Dependent Test?",
                     choices = c("Independent"=1,"Dependent"=2))
       }else output<-NULL
     })
     
     
     output$mdUI1<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num==1 || md_test_num==2){
         output<-numericInput(inputId = "md_UI1",
                               label = withMathJax("$$\\bar{X}:{ }$$"),
                               value = 10,
                               width = "150px")
       }
       if(md_test_num==3){
         output<-numericInput(inputId = "md_UI1",
                      label = withMathJax("$$s:{ }$$"),
                      value = 1,
                      min = 0,
                      step = 1,
                      width = "150px")
         }
       if(md_test_num>3 && md_test_num<7){
         output<-numericInput(inputId = "md_UI1",
                              label = withMathJax("$$\\bar{X}_{1}:{ }$$"),
                              value = 10,
                              width = "150px")
       } else if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           output<-numericInput(inputId = "md_UI1",
                                label = withMathJax("$$\\bar{D}:{ }$$"),
                                value = 1,
                                width = "150px")
           
         } else if (dep_t_type==2){
           output<-numericInput(inputId = "md_UI1",
                                label = withMathJax("$$\\bar{X}_{1}:{ }$$"),
                                value = 10,
                                width = "150px")
           
         }
     }
       
       output
     })
     
     output$mdUI2<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num==1 || md_test_num==2){
         output<-numericInput(inputId = "md_UI2",
                      label = withMathJax("$$\\mu_{0}:{ }$$"),
                      value = 12,
                      width = "150px")
       }
       
       if(md_test_num==3){
         output<-numericInput(inputId = "md_UI2",
                      label = withMathJax("$$\\sigma_{0}:{ }$$"),
                      value = 12,
                      width = "150px")
       }
       
       if(md_test_num>3 && md_test_num<7){
         output<-numericInput(inputId = "md_UI2",
                      label = withMathJax("$$\\bar{X}_{2}:{ }$$"),
                      value = 12,
                      width = "150px")
       } else if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           output<-numericInput(inputId = "md_UI2",
                                label = withMathJax("$$\\Delta:{ }$$"),
                                value = 0,
                                width = "150px")
         } else if (dep_t_type==2){
           output<-numericInput(inputId = "md_UI2",
                                label = withMathJax("$$\\bar{X}_{2}:{ }$$"),
                                value = 12,
                                width = "150px")
         }
       }
       
       output
       
     })
     
     output$mdUI3<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num==1){
         output<-numericInput(inputId = "md_UI3",
                              label = withMathJax("$$\\sigma:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num==2){
         output<-numericInput(inputId = "md_UI3",
                              label = withMathJax("$$s:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       
       if(md_test_num==3){
         output<-numericInput(inputId = "md_UI3",
                              label = withMathJax("$$n:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       
       if(md_test_num==4 || md_test_num==6){
         output<-numericInput(inputId = "md_UI3",
                              label = withMathJax("$$\\sigma_{1}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num==5){
         output<-numericInput(inputId = "md_UI3",
                              label = withMathJax("$$s_{1}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           output<-numericInput(inputId = "md_UI3",
                                label = withMathJax("$$s_{D}:{ }$$"),
                                value = 1,
                                width = "150px")
         } else if (dep_t_type==2){
           output<-numericInput(inputId = "md_UI3",
                                label = withMathJax("$$s_{1}:{ }$$"),
                                value = 12,
                                width = "150px")
         }

       }
       
       output
       
       
       
     })
     output$mdUI4<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num>0 &&md_test_num<4){
         output<-NULL
       }
       if(md_test_num==4 || md_test_num==6){
         output<-numericInput(inputId = "md_UI4",
                              label = withMathJax("$$\\sigma_{2}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num==5){
         output<-numericInput(inputId = "md_UI4",
                              label = withMathJax("$$s_{2}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           return(NULL)
         } else if(dep_t_type==2){
           output<-numericInput(inputId = "md_UI4",
                                label = withMathJax("$$s_{2}:{ }$$"),
                                value = 12,
                                width = "150px")
         }

       }
       
       output
       
       
     })
     output$mdUI5<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       if(md_test_num==1 || md_test_num==2){
         output<-output<-numericInput(inputId = "md_UI5",
                                      label = withMathJax("$$n:{ }$$"),
                                      value = 12,
                                      width = "150px")
       }
       if(md_test_num==3){
         output<-NULL
       }
       if(md_test_num>3 && md_test_num<6){
         output<-numericInput(inputId = "md_UI5",
                              label = withMathJax("$$n_{1}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num>5 && md_test_num<8){
         output<-numericInput(inputId = "md_UI5",
                              label = withMathJax("$$n:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       
       output
       
       
     })
     output$mdUI6<-renderUI({
       md_test_num<-md_test_num()
       req(md_test_num)
       
       
       if(md_test_num>0 && md_test_num<4){
         output<-NULL
       }
       
       if(md_test_num>3 && md_test_num<6){
         output<-numericInput(inputId = "md_UI6",
                              label = withMathJax("$$n_{2}:{ }$$"),
                              value = 12,
                              width = "150px")
       }
       if(md_test_num>5 && md_test_num<7){
         output<-numericInput(inputId = "md_UI6",
                              label = withMathJax("$$r_{xy}:{ }$$"),
                              value = .5,
                              width = "150px")
       }
       if(md_test_num==7){
         dep_t_type<-input$md_t_dep_type_stat
         req(dep_t_type)
         if(dep_t_type==1){
           return(NULL)
         } else if(dep_t_type==2){
           output<-numericInput(inputId = "md_UI6",
                                label = withMathJax("$$r_{xy}:{ }$$"),
                                value = .5,
                                width = "150px")
           
         }
       }
       output
       
       
       
     })
     ########################################################
     
     #pretty output for proportions with data
     output$pretty_prop_stat_data<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       #one_or_two_p<-input$one_or_two_p
       #resultsR<-prop_out()
       alt<-input$alt_p_bi
       #alt_p2<-input$alt_p2
       R <- input$decimal_bi_d
       conf<-input$conf_bi_data
       data<-res_filter$filtered()
       success1<-input$bi_data_success1
       success2<-input$bi_data_success2
       
       req(alt,R,conf,data_type,data,success1)
       
       type<-input$data_type_bi
       bi_data_selected_columns<-as.numeric(input$bi_data_selected_columns)
       
       
       if(data_type==1){
         data_columns<-as.numeric(input$bi_data_selected_columns)
         if(!isTruthy(data_columns)){return()}
         samples<-length(data_columns)
         if(samples>2){return()}
       } else{
         factor_col<-as.numeric(input$data_choice_ref_bi)
         if(!isTruthy(factor_col)){return()}
         factor_levels<-na.omit(unique(data[factor_col]))
         if(nrow(factor_levels)!=2){return("Factor needs exactly two levels")}
         data_col<-as.numeric(input$data_choice_data_bi)
         samples<-2
       }
       
       
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       # if(alt_p2=="two.sided"){
       #   alt_num_p2<-1
       # }
       # if (alt_p2=="less"){
       #   alt_num_p2<- 2
       # }
       # if (alt_p2=="greater"){
       #   alt_num_p2<-3
       # }
       
       
       if(samples==1){#one-sample prop stat
         x<-na.omit(data[[data_columns]])
         
         resultsR<-ro(proportion.test.onesample.exact(x = x,success.value = success1,null.hypothesis.proportion = input$bi_test_data_ui2,alternative = alt,conf.level = conf),R)
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$p =$"),resultsR[["statistic"]][["p"]],"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\pi_{0} =$"),resultsR[["parameter"]][["null hypothesis proportion"]]),"</td>",
                        "</tr>",
                        
                        "<tr>",
                        "<td>",paste(withMathJax("$n= $"),resultsR[["estimate"]][["sample.size"]]),"</td>",
                        "<td>","</td>",
                        "<td>","</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi: $")),"</td>",
                        "<td>",resultsR$conf.int[1],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Exact test for ",names(choice_prop_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        paste(beta_statement,100*resultsR[["estimate"]][["power"]],"%")
         )
         )
         )
       }
       
       else if(samples==2){#two-sample prop stat
         #column
         if(data_type==1){
           req(success2)
           bi_data<-data[data_columns]
           ng1<-length(na.omit(bi_data[[1]]))
           ng2<-length(na.omit(bi_data[[2]]))
           count1<-length(na.omit(bi_data[1][bi_data[1]==success1]))
           count2<-length(na.omit(bi_data[2][bi_data[2]==success2]))
           pg1<-count1/ng1
           pg2<-count2/ng2
           group1_name<-names(data)[bi_data_selected_columns[1]]
           group2_name<-names(data)[bi_data_selected_columns[2]]
         } else{#reference
           bi_data<-data.frame(ref=data[factor_col],data=data[data_col])
           names(bi_data)<-c("ref","data")
           count1<-length(na.omit(bi_data$data[which(bi_data$ref==factor_levels[1,] & bi_data$data==success1)]))
           count2<-length(na.omit(bi_data$data[which(bi_data$ref==factor_levels[2,] & bi_data$data==success1)]))
           ng1<-length(na.omit(bi_data$data[bi_data$ref==factor_levels[1,]]))
           ng2<-length(na.omit(bi_data$data[bi_data$ref==factor_levels[2,]]))
           pg1<-count1/ng1
           pg2<-count2/ng2
           group1_name<-paste("Group 1 = ",input$data_choice_g1_bi)
           group2_name<-paste("Group 2 = ",input$data_choice_g2_bi)
         }

         resultsR<-ro(proportion.test.twosample.exact.simple(sample.proportion.g1 = pg1,sample.size.g1 = ng1,sample.proportion.g2 = pg2,sample.size.g2 = ng2,alternative = alt,conf.level = conf),R)
         
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                        "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$p_{1} =$"),resultsR[["estimate"]][["sample.prop.g1"]]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$p_{2} =$"),resultsR[["estimate"]][["sample.prop.g2"]]),"</td>",
                        "</tr>",
                        
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1}= $"),resultsR[["estimate"]][["sample.size.g1"]]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2}= $"),resultsR[["estimate"]][["sample.size.g2"]]),"</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{1}: $")),"</td>",
                        "<td>",resultsR[["estimate"]][["p.g1.lowerci"]],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR[["estimate"]][["p.g1.upperci"]],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td align='right'>",paste(withMathJax("$\\pi_{2}: $")),"</td>",
                        "<td>",resultsR[["estimate"]][["p.g2.lowerci"]],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR[["estimate"]][["p.g2.upperci"]],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Exact test for ",names(choice_prop_alt_2[alt_num]),": "),"</td>",
                        "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
                        
         )
         )
         
         
       }
       
       output
     })#end prop data
     
     #pretty output for proportions with entered statistics
     output$pretty_prop_stat<-renderUI({
       one_or_two_p<-input$one_or_two_p
       resultsR<-prop_out()
       alt<-input$alt_p
       alt_p2<-input$alt_p2
       R <- input$decimal_p
       conf<-input$conf_p
       req(resultsR)
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(alt_p2=="two.sided"){
         alt_num_p2<-1
       }
       if (alt_p2=="less"){
         alt_num_p2<- 2
       }
       if (alt_p2=="greater"){
         alt_num_p2<-3
       }
       
       
       if(one_or_two_p==1){#one-sample prop stat
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                          "<td>",paste(withMathJax("$p =$"),resultsR$statistic),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$\\pi_{0} =$"),resultsR$parameter),"</td>",
                        "</tr>",
                        
                        "<tr>",
                        "<td>",paste(withMathJax("$n= $"),resultsR$estimate[2]),"</td>",
                        "<td>","</td>",
                        "<td>","</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi: $")),"</td>",
                        "<td>",resultsR$conf.int[1],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Exact test for ",names(choice_prop_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",
                        paste(beta_statement,100*resultsR$estimate[4],"%")
         )
         )
    
       }
       
       if(one_or_two_p==2){#two-sample prop stat
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                          "<br><br>",
                          "<table>",
                          "<tr>",
                          "<td>",paste(withMathJax("$p_{1} =$"),resultsR$estimate[1]),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$p_{2} =$"),resultsR$estimate[7]),"</td>",
                          "</tr>",
                          
                          "<tr>",
                          "<td>",paste(withMathJax("$n_{1}= $"),resultsR$estimate[2]),"</td>",
                          "<td>","</td>",
                          "<td>",paste(withMathJax("$n_{2}= $"),resultsR$estimate[8]),"</td>",
                          "</tr>",
                          
                          "</table>",
                          
                          "<table>",
                          "<tr>",
                          "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{1}: $")),"</td>",
                          "<td>",resultsR$estimate[5],"</td>",
                          "<td>","to","</td>",
                          "<td>",resultsR$estimate[6],"</td>",
                          "</tr>",
                        "<tr>",
                        "<td align='right'>",paste(withMathJax("$\\pi_{2}: $")),"</td>",
                        "<td>",resultsR$estimate[11],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$estimate[12],"</td>",
                        "</tr>",
                          "</table>",
                          
                          "<table>",
                          "<tr>",
                          "<td>",paste("Exact test for ",names(choice_prop_alt_2[alt_num_p2]),": "),"</td>",
                          "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                          "</tr>",
                          "</table>"
                          
           )
           )
           
           
       }
       
       output
     })
     
     
     #pretty output for Poisson with entered statistics
     output$pretty_poi_stat<-renderUI({
       one_or_two<-input$one_or_two_poi
       resultsR<- poi_out()
       alt<-input$alt_poi
       alt_p2<-input$alt_poi_2
       R <- input$decimal_poi
       conf<-input$conf_poi
       n1<-input$n_samp_poi
       n2<-input$n_samp_poi_2
       c1<-input$poi_samp
       c2<-input$poi2
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(alt_p2=="two.sided"){
         alt_num_p2<-1
       }
       if (alt_p2=="less"){
         alt_num_p2<- 2
       }
       if (alt_p2=="greater"){
         alt_num_p2<-3
       }
       
       
       if(one_or_two==1){#one-sample prop stat
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$c =$"),resultsR$statistic),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\lambda_{0} =$"),resultsR$null.value),"</td>",
                        "</tr>",
                        
                        "<tr>",
                        "<td>",paste(withMathJax("$n= $"),resultsR$parameter),"</td>",
                        "<td>","</td>",
                        "<td>","</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\lambda: $")),"</td>",
                        "<td>",resultsR$conf.int[1],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Exact test for ",names(choice_poi_alt_1[alt_num]),": "),"</td>",
                        "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
                        
         )
         )
         
       }
       
       if(one_or_two==2){#two-sample prop stat
         output<-HTML(c(paste("<b>",resultsR$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$c_{1} =$"),c1),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$c_{2} =$"),c2),"</td>",
                        "</tr>",
                        
                        "<tr>",
                        "<td>",paste(withMathJax("$n_{1}= $"),n1),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$n_{2}= $"),n2),"</td>",
                        "</tr>",
                        
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\lambda_{1}: $")),"</td>",
                        "<td>",resultsR$estimate[4],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$estimate[5],"</td>",
                        "</tr>",
                        "<tr>",
                        "<td align='right'>",paste(withMathJax("$\\lambda_{2}: $")),"</td>",
                        "<td>",resultsR$estimate[6],"</td>",
                        "<td>","to","</td>",
                        "<td>",resultsR$estimate[7],"</td>",
                        "</tr>",
                        "</table>",
                        
                        "<table>",
                        "<tr>",
                        "<td>",paste("Exact test for ",names(choice_poi_alt_2[alt_num_p2]),": "),"</td>",
                        "<td>",paste("p = ",resultsR$p.value,if(resultsR$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>"
                        
         )
         )
         
         
       }
       
       output
     })
     
     #pretty correlation/association output
     output$pretty_corr<-renderUI({
       UI1<-input$stat_corr1
       UI2<-input$stat_corr2
       UI3<-input$stat_corr3
       UI4<-input$stat_corr4
       one_or_two<-input$one_or_two_corr
       alt<-input$alt_corr
       R<-input$decimal_corr
       results<-corr_out()
       corr_tests<-input$corr_tests
       conf<-input$conf_corr
       
       req(corr_tests)
       req(alt)
       req(results)
       req(conf)
       req(R)
       req(one_or_two)
       
       
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(corr_tests==1){#one-sample Pearson
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                        "<br><br>",
                        "<table>",
                        "<tr>",
                        "<td>",paste(withMathJax("$r = $"),results$estimate[1]),"</td>",
                        "<td>","</td>",
                        "<td>",paste(withMathJax("$\\rho_{0}=$"),results$parameter),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                        "</tr>",
                        "<tr>",
                        "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                        "</tr>",
                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                        "<td>",paste(withMathJax("$\\rho :$")),"</td>",
                        "<td>",results$conf.int[1],"</td>",
                        "<td>"," to ","</td>",
                        "<td>",results$conf.int[2],"</td>",
                        "</tr>",
                        "</table>",

                        "<table>",
                        "<tr>",
                        "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},results$statistic),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
                  
                        "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                        "</tr>",
                        "</table>",

                        #"<br><br>",
                        paste(beta_statement,100*results$estimate[8],"%")
         )
         
           )
         
       }
       
       if(corr_tests==2){#one-sample Spearman
         output<-
           HTML(c(paste("<b>One-Sample ",results$method," Test</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_s = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{s}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{s}^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[2]+2),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{s} :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("t = ",results$statistic),"</td>",
                  "<td>",paste("df = ",results$estimate[2]),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                 
           )
           
           )
         
       }
       
       if(corr_tests==3){#Kendall tau
         req(UI3)
         req(UI4)
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste("Concordant Pairs: ",results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste("Discordant Pairs: ",results$estimate[4]),"</td>",
                  "</tr>","<tr>",
                  "<td>",paste("Count Ties X: ",UI3),"</td>",
                  "<td>","</td>",
                  "<td>",paste("Count Ties Y: ",UI4),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\tau = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>","</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
         
       }
       

       if(corr_tests==4){#phi/Cramer's V
         req(UI1)
         req(UI2)
         req(UI3)
         req(UI4)
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),#paste(withMathJax("$\\phi$")," or Matthews Correlation")
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{11} =$"),UI1),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{21} =$"),UI2),"</td>",
                  "</tr>","<tr>",
                  "<td>",paste(withMathJax("$n_{12} =$"),UI3),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{22} =$"),UI4),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$V = $"),results[["statistic"]][["V"]]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax(("$\\chi^2 =$")),results[["estimate"]][["chi.square"]]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "<td></td>",
                  "<td>","</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
         
       }
       
       if(corr_tests==5){#two-sample Pearson indep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{34}=$"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12}^2 = $"),results$estimate[6]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{34}^2 = $"),results$estimate[12]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{12} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{34} = $"),results$estimate[8]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{12} :$")),"</td>",
                  "<td>",results$estimate[4],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[5],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{34} :$")),"</td>",
                  "<td>",results$estimate[10],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[11],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==6){#two-sample Goodman and Kruskall gamma
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\gamma_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\gamma_{2}=$"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\sigma_{SE_{1}} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\sigma_{SE_{2}} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==7){#two-sample kappa indep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\kappa_{2}=$"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$SE_{\\kappa_{1}} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$SE_{\\kappa_{2}} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==8){#two-sample Pearson dep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{13} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{23}=$"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12} = $"),results$estimate[11]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),3+results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{13} - r_{23} = $")),results$estimate[1],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{13} - \\rho_{23}:$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{13} :$")),"</td>",
                  "<td>",results$estimate[4],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[5],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{23} :$")),"</td>",
                  "<td>",results$estimate[8],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[9],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{12} :$")),"</td>",
                  "<td>",results$estimate[12],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[13],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("t = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       if(corr_tests==9){#two-sample kappa dep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{total} = $"),results[["estimate"]][["n"]]),"</td>",
                  "</tr>",
                  
                  "<tr>",
                  "<td>",paste("Proportion Agreement =",results[["estimate"]][["p_o"]]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Proportion Chance Agreement =",results[["estimate"]][["p_c"]]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa_{max} =$"),results[["estimate"]][["kappa.max"]]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa = $"),results[["estimate"]][["kappa"]]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval"),"</td>",
                  "<td>",results$conf.int[1]," to ",results$conf.int[2],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results[["statistic"]][["z"]]),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       
       
       output
     })
     
     output$data_choice_column_np <-renderUI({
       
       req(res_filter$filtered())
       
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       
       output<-checkboxGroupInput(inputId = "np_data_selected_columns",
                                  label = "Analyze which column(s)?",
                                  choices = choices)
       output
     })
     
     output$np_tests<-renderUI({
       one_or_two_np<-input$one_or_two_np
       
       if(one_or_two_np==1){#one sample tests
         np_test_choice<-c(1,2)
         names(np_test_choice)<-c("Sign Test for Location","Wilcoxon Test for Location")
       }
       if(one_or_two_np==2){#two sample independent
         np_test_choice<-c(3, 4)
         names(np_test_choice)<-c("Wilcoxon-Mann-Whitney U","Two-Sample Median")
       }
       if(one_or_two_np==3){#two sample dependent
         np_test_choice<-c(5,6,7)
         names(np_test_choice)<-c("Dependent Sign Test","Dependent Wilcoxon Signed Ranks","McNemar's Test of Change")
       }
       radioButtons(inputId = "np_tests",label = "Select Test",choices = np_test_choice)
       
     })
     
     #render np more info text
    observeEvent(input$np_more_info,{  #output$np_more_info_text<-renderUI({
       np_more_info<-input$np_more_info
       np_tests<-input$np_tests
       req(np_more_info,np_tests)
       
       if(!np_more_info){return()}
       
       # if(np_more_info==F){
       #   text_out<-HTML("")
       # }
       # else{
         if (np_tests==1){
           title="One-Sample Sign Test for Location"
           text_out<-HTML("The one-sample sign test for location is simply a test to see if the number of observations above the location of interest is equal to the number below that location. You can get exactly the same answer by testing the proportion above or below some number against a null hypothesis of \U03c0 = 0.5. Ties are not counted. It has the same assumptions as the one-sample binomial test, namely that the samples are randomly drawn from a population with a constant probability (in this case of being above or below some location) and are independent. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Sign_test'>Wikipedia</a>")
         }
         if (np_tests==2){
           title="One-Sample Wilcoxen Signed Ranks Test"
           text_out<-HTML("The one-sample Wilcoxon Signed Ranks Test for location is an alternative to the one-sample t-test when the normality assumption of the t-test cannot be assumed. The data must be ordinal and independent. To caculate the sum of the ranks, calculate the difference of each observation from the selected location, drop any observations of zero difference, take the absolute value of the differences, and get the average rank of these for each observation. Sum the average ranks for those observations falling above and below the selected location. The smaller of the two will be used to generate a z-score and p-value. </br></br>For more information see <a href='https://nyuwinthrop.org/wp-content/uploads/2019/08/wilcoxon-sign-rank-test-one-sample.pdf'>NYU Winthrop</a>")
         }
         if (np_tests==3){
           title="Two-Sample Wilcoxon-Mann-Whitney U Test"
           text_out<-HTML("The two-sample Wilcoxon-Mann-Whitney U Test for equality of distributions with particular sensitivity to location. It is an alternative to the two-sample t-test when the normality assumption of the t-test cannot be assumed. The data must be ordinal and independent with approximately the same dispersion. To caculate the sum of the ranks for each group assign an average rank to all the observations from both groups. Sum the average ranks for each group. A U statistic is calculated for each group and the smaller one is used to generate a z-score and p-value. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test'>Wikipedia</a>")
         }
         if (np_tests==4){
           title="Tw-Sample Median Test"
           text_out<-HTML("The two-sample median test assesses whether the median of two samples are equal. It does have lower power than the Wilcoxon-Mann-Whitney test, so that test is preferred unless the dispersions are not approximately equal or if one or more observation exceeds the measurement device scale (pegs the dial). </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Median_test'>Wikipedia</a>")
         }
         if (np_tests==5){
           title="Two-Sample Dependent Sign Test"
           text_out<-HTML("The two-sample dependent sign test is based on the binomial distribution like the one-sample sign test. It only assumes the data are independent, comes from the same population, and are at least ordinal. For each paired value, the difference is either positive, negative, or equal. If there is no difference between the dependent observations, it should be a 50-50 chance that one is above the other, and that is assessed with an exact binomial test.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Sign_test'>Wikipedia</a>")
         }
         if (np_tests==6){
           title="Two-Sample Dependent Wilcoxon Signed Ranks Test"
           text_out<-HTML("The two-sample dependent Wilcoxon Signed Ranks test is an alternative to the paired t-test when the assumption of normally distributed difference cannot be assumed. To caculate the sum of the ranks, calculate the difference between each pair of observations, drop any observations of zero difference, take the absolute value of the differences, and get the average rank of these for each observation. Sum up the ranks that came from a positive difference and sum up the ranks that came from a negative difference. The negative sum will be subtracted from the positive sum to generate the W statistic which will be used to generate a z-score and p-value.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test'>Wikipedia</a>")
         }
         if (np_tests==7){
           title="McNemar's Test of Change"
           text_out<-HTML("McNemar's Test of Change is used on paired dichomous data. It is commonly used to determine if there is a difference is caused by some treatment. The same units are classified before the intervention, then afterward. The test only concerns the two cells P1F2 and F1P2 and is a binomial test to determine of the probability of these events has changed. If the probabilities are significantly different, the conclusion is that the treatment has caused a some change,for good or bad. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/McNemar%27s_test'>Wikipedia</a>")
         }
         

       #}
       #text_out
       
       sendSweetAlert(title = title,text = HTML(text_out),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
       updateCheckboxInput(inputId = "np_more_info",value = FALSE)
       
       
     })
     
     #UI for stats entered nonparametrics
     
     output$np_alt <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       choice_np_alt <-c("two.sided","less","greater")
       
       names(choice_np_alt) <-c(choice_np_alt_text[as.numeric(np_tests)*3-2],choice_np_alt_text[as.numeric(np_tests)*3-1],choice_np_alt_text[as.numeric(np_tests)*3])
       
       output<-selectInput(inputId = "choice_np_alt_stat",label = "Alternative Hypothosis",choices = choice_np_alt)
      
         output
       
     })
     
     output$npUI1 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$n_{above}:{ }$"),value = 2,min = 0,step = 1)
       }
       if (np_tests==2){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$S^{+}:{ }$"),value = 3,min = 0,step = 1)
       }
       if (np_tests==3){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$S_{1}:{ }$"),value = 32,min = 0,step = 1)
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$n_{1 \\;above}:{ }$"),value = 1,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$n^+:{ }$"),value = 8,min = 0,step = 1)
       }
       if (np_tests==6){
         output<-numericInput(inputId = "npUI1",label = withMathJax("$S^{+}:{ }$"),value = 27,min = 0,step = 1)
       }
       if (np_tests==7){
         output<-HTML("<p style='text-align:center'><b>Pass 2</b></p>")
       }
       
       
       
       output
       
     })
     output$npUI2 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-numericInput(inputId = "npUI2",label = withMathJax("$S^{-}:{ }$"),value = 150,min = 0,step = 1)
       }
       if (np_tests==3){
         output<-numericInput(inputId = "npUI2",label = withMathJax("$S_{2}:{ }$"),value = 46,min = 0,step = 1)
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI2",label = withMathJax("$n_{2 \\;above}:{ }$"),value = 5,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
       }
       if (np_tests==7){
         output<-HTML("<p style='text-align:center'><b>Fail 2</b></p>")
       }
       
       
       output
       
       
     })
     output$npUI3 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$n_{equal}:{ }$"),value = 0,min = 0,step = 1)
       }
       if (np_tests==2){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$n_{Adj.}:{ }$"),value = 17,min = 1,step = 1)
       }
       if (np_tests==3){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$n_{1}:{ }$"),value = 6,min = 0,step = 1)
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$n_{1 \\;equal}:{ }$"),value = 0,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$n^=:{ }$"),value = 0,min = 0,step = 1)
       }
       if (np_tests==6){
         output<-numericInput(inputId = "npUI3",label = withMathJax("$S^{-}:{ }$"),value = 18,min = 0,step = 1)
       }
       if (np_tests==7){
         output<-numericInput(inputId = "npUI3",label = "Pass 1",value = 56,min = 0,step = 1)
       }
       
       output
       
     })
     output$npUI4 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3){
         output<-numericInput(inputId = "npUI4",label = withMathJax("$n_{2}:{ }$"),value = 6,min = 0,step = 1)
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI4",label = withMathJax("$n_{2 \\;equal}:{ }$"),value = 0,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
       }
       if (np_tests==7){
         output<-numericInput(inputId = "npUI4",label = "Pass 1",value = 4,min = 0,step = 1)
       }
       
       
       output
       
     })
     output$npUI5 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-numericInput(inputId = "npUI5",label = withMathJax("$n_{below}:{ }$"),value = 8,min = 0,step = 1)
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3){
         output<-NULL
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI5",label = withMathJax("$n_{1 \\;below}:{ }$"),value = 5,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-numericInput(inputId = "npUI5",label = withMathJax("$n^-:{ }$"),value = 2,min = 0,step = 1)
       }
       if (np_tests==6){
         output<-numericInput(inputId = "npUI5",label = withMathJax("$n:{ }$"),value = 10,min = 1,step = 1)
       }
       if (np_tests==7){
         output<-numericInput(inputId = "npUI5",label = "Fail 1",value = 56,min = 1,step = 1)
       }
       
       
       output
       
     })
     output$npUI6 <- renderUI({
       np_tests<-input$np_tests
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3){
         output<-NULL
       }
       if (np_tests==4){
         output<-numericInput(inputId = "npUI6",label = withMathJax("$n_{2 \\;below}:{ }$"),value = 1,min = 0,step = 1)
       }
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
       }
       if (np_tests==7){
         output<-numericInput(inputId = "npUI5",label = "Fail 1",value = 4,min = 1,step = 1)
       }
       
       
       
       output
       
     })
     
     #text output for nonparametric stats entered
     np_stat_out <- reactive({
       conf<-input$conf_np
       R<-input$np_decimals
       alt<-input$choice_np_alt_stat
       np_tests<-input$np_tests
       npUI1<-input$npUI1
       npUI2<-input$npUI2
       npUI3<-input$npUI3
       npUI4<-input$npUI4
       npUI5<-input$npUI5
       npUI6<-input$npUI6
       
       req(np_tests,R,npUI1,alt)
     
      
       if(np_tests==1){#one sample sign test
         req(npUI3)
         output<-median.test.onesample.signtest.simple(n.below = npUI1,n.equal = npUI3,n.above = npUI5,alternative = alt,conf.level = conf)
       }
       if(np_tests==2){
         req(npUI2,npUI3)
         output<-wilcoxon.signed.ranks.onesample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI2,adj.sample.size = npUI3,alternative = alt)
       }
       if(np_tests==3){
         req(npUI2,npUI3,npUI4)
         output<-mann.whitney.u.test.simple(sum.ranks.g1 = npUI1,sum.ranks.g2 = npUI2,sample.size.g1 = npUI3,sample.size.g2 = npUI4,alternative = alt)
       }
       if(np_tests==4){
         req(npUI2,npUI3,npUI4,npUI5)
         output<-median.test.twosample.independent.mood.simple(n.below.g1 = npUI5,n.equal.g1 = npUI3,n.above.g1 = npUI1,n.below.g2 = npUI6,n.equal.g2 = npUI4,n.above.g2 = npUI2,alternative = alt,conf.level = conf)
       }
       if(np_tests==5){
         req(npUI3,npUI5)
         output<-median.test.twosample.dependent.signtest.simple(n.below = npUI5,n.equal = npUI3,n.above = npUI1,alternative = alt,conf.level = conf)
       }
       if(np_tests==6){
         req(npUI3,npUI5)
         output<-wilcoxon.signed.ranks.twosample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI3,sample.size = npUI5,alternative = alt)
       }
       if(np_tests==7){
         req(npUI4,npUI5)
         output<-proportion.test.mcnemar.simple(b = npUI4,c = npUI5,null.hypothesis.proportion = .5,alternative = alt,conf.level = conf,method = "Exact")
       }
       

       ro(output,R)
     })
     
     output$blog<-renderUI({
       output<-tags$iframe(src=paste0('https://www.roi-ally.com/index.php/en/component/sppagebuilder/?view=page&id=215'), title='Recent Blog Posts', height='600', width='600')
       print(output)
       output
     })
     
     output$pretty_ssize<-renderUI({
       alt<-input$one_or_two_size
       sample_calc<-input$sample_calc
       power_s<-input$power_s
       s_size_alpha<-input$s_size_alpha
       s_size_beta<-input$s_size_beta
       s_size_n<-input$s_size_n
       s_sizeUI1<-input$s_sizeUI1
       s_sizeUI2<-input$s_sizeUI2
       s_sizeUI3<-input$s_sizeUI3
       s_sizeUI4<-input$s_sizeUI4
       sample_size_type<-input$sample_size_type
       results<-s_size_results()
       
       #req(power_s)
       req(sample_calc)
       req(sample_size_type)
       
       if(sample_size_type==5){sample_calc<-15}
       #if(sample_size_type==4){sample_calc<-16}
       
       #if(one_or_two_size==1){alt="greater"}else {alt="two.sided"}
       
       if(power_s==F){#sample size
         if(sample_calc==1){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - One-Sample Mean: ",results$test," test, \U03c3 known","</b>"),"<br>",
                      if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),results$effect.size),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td><td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
         }
         if(sample_calc==3){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Independent Means: ",results$test," test, \U03c3 known","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),results$effect.size),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td><td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==5){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - One-Sample Mean: ",results$test," test, \U03c3 unknown","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),results$effect.size),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td><td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==6){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Independent Means: ",results$test," test, unknown but equal \U03c3","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),results$mean.diff),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==7){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Independent Means: ",results$test," test, unknown and unequal \U03c3","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),results$mean.diff),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==8){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Dependent Means: ",results$test," test, \U03c3 unknown","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_{\\bar{D}} = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta_{\\bar{D}} = $"),results$effect.size),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td></tr><tr>",
                    
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==9){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - One-Sample Variance: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==10){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Variance: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==11){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Correlation: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\rho_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\rho_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==12){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - One-Sample Approximate Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==13){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - One-Sample Exact Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==14){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Two-Sample Approximate Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_2 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==16){
           if(!is.na(results["error_message",])){
             output<-HTML(results["error_message",])
             return(output)
             }
           
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Exact One-Sample Poisson</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha_{actual} = $"),results["alpha",]),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta_{actual} = $"),1-results["power",]),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results["n",]),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$X_{crit L} = $"),results["crit_x_l",]),"</td><td></td>",
                    "<td>",paste(withMathJax("$X_{crit U} = $"),results["crit_x_u",]),"</td>",
                    "</tr><tr>",
                    "<td>",paste("Power = ",results["power",]),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==17){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Approximate One-Sample Poisson: ",results$test," test","</b>"),"<br>",#error not working because no rate ss calc
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )

             )

         }
         if(sample_calc==18){
           output<-
             HTML(c(paste("<b>","Sample Size Calculations - Approximate Two-Sample Poisson</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),s_size_alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),s_size_beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_2 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results["n",]),"</td>",
                    "</tr>",
                    # "<tr>",
                    # "<td>",paste(withMathJax("$X_{crit L} = $"),results["crit_x_l",]),"</td><td></td>",
                    # "<td>",paste(withMathJax("$X_{crit U} = $"),results["crit_x_u",]),"</td>",
                    # "</tr><tr>",
                    # "<td>",paste("Power = ",results["power",]),"</td>",
                    # "</tr>",
                    "</table>"
             )
             
             )
         }
         if(sample_calc==15){
           output<-
             HTML(c(paste(                    "Note that if you are interested in the power or sample size for an interaction, you can enter the effect's df + 1 in Levels above.",
                                              "<br><br>",
                                              "<b>","Analysis of Variance Sample Size Calculation","</b>"),"<br>",
                    "Assumes that two level means depart the grand mean by \U00B1 0.5\U0394",
                    "<br>","<br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$sig.level),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),1-results$power),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_w = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma^2_w = $"),results$within.var),"</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta_b = $"),s_sizeUI2),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma^2_b = $"),results$between.var),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$n),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),ceiling(results$n))," per level","</td>",
                    "<td>","</td>","<td>",paste(results$groups," levels"),
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         
         }#end sample size
       
       if(power_s==T){#power
         if(sample_calc==1){
           output<-
             HTML(c(paste("<b>","Power Calculations - One-Sample Mean: ",results$test," test, \U03c3 known","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),abs(results$effect.size)),"</td></tr>",
                    
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</table>"
             )
             
             )
         }
         if(sample_calc==3){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Independent Means: "," z test, \U03c3 known","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),s_size_alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),1-results),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),s_size_n),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",

                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),abs(s_sizeUI2)),"</td></tr>",
                    "<tr>",
                    "<td>",paste("Power = ",results),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==5){
           output<-
             HTML(c(paste("<b>","Power Calculations - One-Sample Mean: ",results$test," test, \U03c3 unknown","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),abs(results$effect.size)),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==6){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Independent Means: ",results$test," test, unknown but equal \U03c3","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),abs(results$mean.diff)),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==7){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Independent Means: ",results$test," test, unknown and unequal \U03c3","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta = $"),abs(results$mean.diff)),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==8){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Dependent Means: ",results$test," test, \U03c3 unknown","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_{\\bar{D}} = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta_{\\bar{D}} = $"),abs(results$effect.size)),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td></tr><tr>",
                    
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==9){
           output<-
             HTML(c(paste("<b>","Power Calculations - One-Sample Variance: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td>",
                    "<td></td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==10){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Variance: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma_2 = $"),s_sizeUI4),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_1 = $"),results$sample.size.g1),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_2 = $"),results$sample.size.g2),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==11){
           output<-
             HTML(c(paste("<b>","Power Calculations - Correlation: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\rho_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\rho_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==12){
           output<-
             HTML(c(paste("<b>","Power Calculations - One-Sample Approximate Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==13){
           output<-
             HTML(c(paste("<b>","Power Calculations - One-Sample Exact Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==14){
           output<-
             HTML(c(paste("<b>","Power Calculations - Two-Sample Approximate Proportion: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\pi_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\pi_2 = $"),s_sizeUI2),"</td></tr>",
                    "<tr>",
                    
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         if(sample_calc==16){
           if(!is.na(results["error_message",])){
             output<-HTML(results["error_message",])
             return(output)
           }
           output<-
             HTML(c(paste("<b>","Power Calculations - Exact One-Sample Poisson</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha_{actual} = $"),results["alpha",]),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta_{actual} = $"),1-results["power",]),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),s_size_n),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$X_{crit L} = $"),results["crit_x_l",]),"</td><td></td>",
                    "<td>",paste(withMathJax("$X_{crit U} = $"),results["crit_x_u",]),"</td>",
                    "</tr><tr>",
                    "<td>",paste("Power = ",results["power",]),"</td>",
                    "</tr>",
                    "</table>"
             )
             
             )
           
         }
         
         if(sample_calc==17){
           output<-
             HTML(c(paste("<b>","Power Calculations - Approximate One-Sample Poisson: ",results$test," test","</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$alpha),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),results$beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_0 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    #"<td>",paste(withMathJax("$n_{calc} = $"),results$actual),"</td>",
                    "</tr><tr>",
                    "<td>",paste(withMathJax("$n = $"),results$sample.size),"</td></tr><tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</tr>",
                    "</table>"
             )

             )

         }
         if(sample_calc==18){
           output<-
             HTML(c(paste("<b>","Power Calculations - Approximate Two-Sample Poisson</b>"),"<br>",
                    if(alt=="two.sided"){"<b>Two-Tail</b>"} else{"<b>One-Tail</b>"},
                    "<br><br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),s_size_alpha),"</td>",
                    "<td>","</td>",
                    #"<td>",paste(withMathJax("$\\beta = $"),s_size_beta),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\lambda_1 = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\lambda_2 = $"),s_sizeUI2),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$n_{1} = $"),s_size_n),"</td>",
                    "<td></td>",
                    "<td>",paste(withMathJax("$n_{2} = $"),s_sizeUI3),"</td>",
                    "</tr>",
                    # "<tr>",
                    # "<td>",paste(withMathJax("$X_{crit L} = $"),results["crit_x_l",]),"</td><td></td>",
                    # "<td>",paste(withMathJax("$X_{crit U} = $"),results["crit_x_u",]),"</td>",
                    # "</tr>",
                    "<tr>",
                     "<td>",paste("Power = ",results),"</td>",
                    # "</tr>",
                    "</table>"
             )
             
             )
         }
         if(sample_calc==15){
           output<-
             HTML(c(paste("Note that if you are interested in the power or sample size for an interaction, you can enter the effect's df + 1 in Levels above.",
                          "<br><br>",
                          "<b>","Analysis of Variance Power Calculation","</b>"),"<br>",
                    "Assumes that two level means depart the grand mean by \U00B1 0.5\U0394",
                    "<br>","<br>",
                    "<table>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\alpha = $"),results$sig.level),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\beta = $"),1-results$power),"</td>",
                    "</tr>",
                    "<tr>",
                    "<td>",paste(withMathJax("$\\sigma_w = $"),s_sizeUI1),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma^2_w = $"),results$within.var),"</td>",
                    "<td>","</td>",
                    "</tr>",
                    "<tr><td>",paste(withMathJax("$\\Delta_b = $"),s_sizeUI2),"</td>",
                    "<td>","</td>",
                    "<td>",paste(withMathJax("$\\sigma^2_b = $"),results$between.var),"</td>",
                    "</tr>",
                    
                    "<tr>",
                    "<td>",paste(withMathJax("$n = $"),ceiling(results$n))," per level","</td>",
                    "<td>","</td>","<td>",paste(results$groups," levels"),
                    "</tr>",
                    "<tr>",
                    "<td>",paste("Power = ",results$power),"</td>",
                    "</table>"
             )
             
             )
           
         }
         
           
         #}#end power
         
         
       }#end power
       
       output
     })
     
     output$pretty_nonparametric <- renderUI({
       conf<-input$conf_np
       R<-input$np_decimals
       alt<-input$choice_np_alt_stat
       np_tests<-input$np_tests
       npUI1<-input$npUI1
       npUI2<-input$npUI2
       npUI3<-input$npUI3
       npUI4<-input$npUI4
       npUI5<-input$npUI5
       npUI6<-input$npUI6
       results<-np_stat_out()

       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(np_tests==1){#one sample sign test
         output<-
           HTML(c(paste("<b>Sign Test for Location</b><br>","<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{above} = $"),npUI1),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{equal} = $"),npUI3),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{below} = $"),npUI5),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$p_{below} = $"),results$statistic),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{observed} = $"),npUI1+npUI3+npUI5),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{included} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for proportion below = ",results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{below} :$")),"</td>",
                  
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  
                  "<td>",paste(withMathJax("$p_{below} = $"),results$statistic),"</td>",
                  
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>","</table>",
                  "<table><tr><td>",beta_statement,results$estimate[4],"</td></tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==2){
         output<-#wilcoxon.signed.ranks.onesample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI2,adj.sample.size = npUI3,alternative = alt)
           
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S^{+} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$S^{-} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{Adj.} = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("W = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==3){
         output<-#mann.whitney.u.test.simple(sum.ranks.g1 = npUI1,sum.ranks.g2 = npUI2,sample.size.g1 = npUI3,sample.size.g2 = npUI4,alternative = alt)
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                  "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$S_{2} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("U = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==4){
         output<-#median.test.twosample.independent.mood.simple(n.below.g1 = npUI5,n.equal.g1 = npUI3,n.above.g1 = npUI1,n.below.g2 = npUI6,n.equal.g2 = npUI4,n.above.g2 = npUI2,alternative = alt,conf.level = conf)
           HTML(c(paste("<b>","Two-Sample Median Test<br>Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; above} = $"),results$estimate[3]),"</td>",
                  "<td>",paste(withMathJax("$p_{1\\; above} = $"),results$estimate[1]),"</td>",
                  "<td>",paste(withMathJax("$n_{2\\; above} = $"),results$estimate[9]),"</td>",
                  "<td>",paste(withMathJax("$p_{2\\; above} = $"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; equal} = $"),npUI3),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2\\; equal} = $"),npUI4,"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; below} = $"),results$estimate[4]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2\\; below} = $"),results$estimate[10]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; total\\; inc.} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2\\; total\\; inc.} = $"),results$estimate[8]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{1 \\;above} :$")),"</td>",
                  "<td>",results$estimate[5],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[6],"</td>",
                  "</tr>",
                  
                  "<tr>",
                  "<td align='right'>",paste(withMathJax("$\\pi_{2 \\;above} :$")),"</td>",
                  "<td>",results$estimate[11],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[12],"</td>",
                  "</tr>",
                  
                  "<tr>",
                  "<td align='right'>","Odds Ratio:","</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
           )         
       }
       if(np_tests==5){
         output<-#median.test.twosample.dependent.signtest.simple(n.below = npUI5,n.equal = npUI3,n.above = npUI1,alternative = alt,conf.level = conf)
           HTML(c(paste("<b>Two-Sample Dependent Sign Test for Location</b><br>","<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{+} = $"),npUI1),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$p^{+} = $"),results$statistic),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{=} = $"),npUI3),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{-} = $"),npUI5),"</td>",
                  
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{observed} = $"),npUI1+npUI3+npUI5),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{included} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for the probability that the difference in each pair is positive = ",results$parameter),"</td>",
                  "</tr>",
                  "</table>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi^{+} :$")),"</td>",
                  
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(withMathJax("$p^{+} = $"),results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>",
                  "<table><tr>,<td>",beta_statement,results$estimate[4],"</td></tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==6){
         output<-#wilcoxon.signed.ranks.twosample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI3,sample.size = npUI5,alternative = alt)
           HTML(c(paste("<b>","Method: Dependent ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S^{+} = $"),results$estimate[1]),"</td>",
                  "</tr>",
                  "<td>",paste(withMathJax("$S^{-} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("W = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==7){
         output<-
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$P_{1}F_{2} = $"),results$estimate[1]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p(b) = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<td>",paste(withMathJax("$F_{1}P_{2} = $"),results$estimate[3]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p(c) = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       output
     
     })
     
     
     #render nonparametric enter statistics
     output$np_text_stat <- renderPrint({
       np_stat_out()
     })
     
     
     #Selected columns for nonparametric data######################
     num_selected_columns_np_data<-reactive({
       np_data_selected_columns<-input$np_data_selected_columns
       
       length(np_data_selected_columns)
       
     })
     
     #render the dep or indep dropdown for nonparametric data UI
     output$ind_or_dep_np_data <- renderUI({
       columns<-num_selected_columns_np_data()
       type<-input$data_type_np
       
       output<-NULL
       
       if(columns==2 && type==1){
         output<-selectInput(inputId = "dep_or_indep_np_data",
                             label = "Independent or Dependent Test?"
                             ,choices = c("Independent"=1,"Dependent"=2))
       }
       if(type==2){
         output<-selectInput(inputId = "dep_or_indep_np_data",
                             label = "Independent Only"
                             ,choices = c("Independent"=1))
       }
       
       output
     })
     
     #render nonparametric test selection for data
     output$np_tests_data<-renderUI({
       #number of data vectors selected
       num_selected_columns<-num_selected_columns_np_data()
       #need independent or dependent here
       dep_or_indep<-input$dep_or_indep_np_data
       type<-input$data_type_np
       req(type,num_selected_columns)
       
       if(num_selected_columns==1 && type==1){#one sample tests column data
         np_test_choice<-c(1,2)
         names(np_test_choice)<-c("Sign Test for Location","Wilcoxon Test for Location")
       } 
       
       if(num_selected_columns==2 || type==2){
         req(dep_or_indep)
         if(dep_or_indep==1){#two sample branch for independent
           np_test_choice<-c(3, 4)
           names(np_test_choice)<-c("Wilcoxon-Mann-Whitney U","Two-Sample Median")
           }
         if(dep_or_indep==2){#two sample dependent
           np_test_choice<-c(5:7)
           names(np_test_choice)<-c("Dependent Sign Test","Dependent Wilcoxon Signed Ranks","McNemar's Test of Change")
         }
       }
      
       if((type == 1 &&(num_selected_columns<1) || (num_selected_columns >2))){output<-h3("Select one or two columns of data")}
       
       else {output<-radioButtons(inputId = "np_tests_data",
                    label = "Select Test",
                    choices = np_test_choice)}
       output
     })
     

     
     #UI for data nonparametrics
     
     output$np_alt_data <- renderUI({
       np_tests<-input$np_tests_data
       req(np_tests)
       
       choice_np_alt <-c("two.sided","less","greater")
       
       names(choice_np_alt) <-c(choice_np_alt_text[as.numeric(np_tests)*3-2],choice_np_alt_text[as.numeric(np_tests)*3-1],choice_np_alt_text[as.numeric(np_tests)*3])
       
       output<-selectInput(inputId = "choice_np_alt_stat_data",label = "Alternative Hypothesis",choices = choice_np_alt)
       
       output
       
     })
     
     #####dynamic UI for data nonparametric
     output$npUI1_data <- renderUI({
       np_tests<-input$np_tests_data
       np_data_selected_columns<-input$np_data_selected_columns
       type<-input$data_type_np
       data<-res_filter$filtered()
         
       req(np_tests,data)
        
       if (np_tests==1){
         req(np_data_selected_columns)
         x<-data[,as.numeric(np_data_selected_columns[1])]
         output<-HTML(paste(withMathJax("$\\widetilde{X}_{data} = $"),median(x)))
         
       }
      
       if (np_tests==2){
         req(np_data_selected_columns)
         x<-data[,as.numeric(np_data_selected_columns[1])]
         output<-HTML(paste(withMathJax("$\\widetilde{X}_{data} = $"),median(x)))
       }
       if (np_tests==3 || np_tests==4){
         if(type==1){
           req(np_data_selected_columns)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         } else
           if(type==2){
             ref_col<-as.numeric(input$data_choice_ref_np)
             data_col<-as.numeric(input$data_choice_data_np)
             req(ref_col,data_col)
             data<-res_filter$filtered()
             
             x1<-data[,data_col][which(data[ref_col]==input$data_choice_g1_np)]
             
           }
         
         output<-HTML(paste(withMathJax("$\\widetilde{X}_{1} =$"),median(na.omit(x1))))
           
       }
       
       if (np_tests==5){
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         temp<-median.test.twosample.dependent.signtest(g1 = x1,g2 = x2)
         temp<-temp$estimate[3]
         
         output<-HTML(paste(withMathJax("$n^{+} =$"),temp))
       }
       if (np_tests==6){
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         len<-length(x2)
         n<-seq(1:len)
         n_plus=0
         
         for(val in n){
           if(x1[val]>x2[val]){n_plus=n_plus+1}
         }
         
         
         output<-HTML(paste(withMathJax("$n^{+} =$"),n_plus))
       }
       
       if(np_tests==7){
         pass<-input$np_mc_pass
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         req(np_data_selected_columns,data,pass)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         cats<-unique(c(na.omit(unique(data[[as.numeric(np_data_selected_columns[1])]])),na.omit(unique(data[[as.numeric(np_data_selected_columns[2])]]))))
         cats<-c(cats[cats==pass],cats[cats!=pass])
         mctable<-table(factor(x1,levels = cats,labels=c("Pass","Fail")),factor(x2,levels = cats,labels=c("Pass","Fail")))
         a<-mctable[1,1]
         
         output<-HTML(paste0(withMathJax("$P_{1}P_{2}=$"),a))
       }
       
       output
       
     })
     output$npUI2_data <- renderUI({
       np_tests<-input$np_tests_data
       type<-input$data_type_np
       req(np_tests)
       
       if (np_tests==1){
         output<-numericInput(inputId = "npUI2_data",label = withMathJax("$M_0{ }$"),value = 2,min = 0,step = 1)
       }
       if (np_tests==2){
         output<-
           numericInput(inputId = "npUI2_data",label = withMathJax("$M_0:{ }$"),value = 3,min = 0,step = 1)
       }
       if (np_tests==3 || np_tests==4){
         req(type)
         
         if(type==1){
           np_data_selected_columns<-input$np_data_selected_columns
           data<-res_filter$filtered()
           req(np_data_selected_columns,data)
           x2<-data[,as.numeric(np_data_selected_columns[2])]
         } else
           if(type==2){
             ref_col<-as.numeric(input$data_choice_ref_np)
             data_col<-as.numeric(input$data_choice_data_np)
             req(ref_col,data_col)
             data<-res_filter$filtered()
             
             x2<-data[,data_col][which(data[ref_col]==input$data_choice_g2_np)]
             
           }
         
         output<- HTML(paste(withMathJax("$\\widetilde{X}_{2} =$"),median(na.omit(x2))))
       }
       
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
           
       }
       
       if(np_tests==7){
         pass<-input$np_mc_pass
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         req(np_data_selected_columns,data,pass)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         cats<-unique(c(na.omit(unique(data[[as.numeric(np_data_selected_columns[1])]])),na.omit(unique(data[[as.numeric(np_data_selected_columns[2])]]))))
         cats<-c(cats[cats==pass],cats[cats!=pass])
         mctable<-table(factor(x1,levels = cats,labels=c("Pass","Fail")),factor(x2,levels = cats,labels=c("Pass","Fail")))
         a<-mctable[1,1]
         b<-mctable[1,2]
         c<-mctable[2,1]
         d<-mctable[2,2]
         output<-HTML(paste0(withMathJax("$P_{1}F_{2}=$"),b))
       }
       
       output
       
       
     })
     output$npUI3_data <- renderUI({
       np_tests<-input$np_tests_data
       type<-input$data_type_np
       data<-res_filter$filtered()
       np_data_selected_columns<-input$np_data_selected_columns
       req(np_tests,data)
       
       if (np_tests==1){
         req(np_data_selected_columns)
         output<-HTML(paste(withMathJax("$n =$"),length(data[,as.numeric(np_data_selected_columns[1])])))
       }
       if (np_tests==2){
         req(np_data_selected_columns)
         output<-HTML(paste(withMathJax("$n =$"),length(data[,as.numeric(np_data_selected_columns[1])])))
       }
       if (np_tests==3 || np_tests==4){
         if(type==1){
           req(np_data_selected_columns)
           x1<-data[,as.numeric(np_data_selected_columns[1])]
         } else
           if(type==2){
             ref_col<-as.numeric(input$data_choice_ref_np)
             data_col<-as.numeric(input$data_choice_data_np)
             req(ref_col,data_col)
             
             data<-res_filter$filtered()
             
             x1<-data[,data_col][which(data[ref_col]==input$data_choice_g1_np)]
             
           }
         
         output<-HTML(paste(withMathJax("$n_1 =$"),length(na.omit(x1))))
       }
       
       if (np_tests==5){
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         temp<-median.test.twosample.dependent.signtest(g1 = x1,g2 = x2)
         n_incl<-temp$estimate[2]
         
         sample_s<-length(data[,as.numeric(np_data_selected_columns[2])])
         
         output<-HTML(paste(withMathJax("$n^{=} =$"),sample_s-n_incl))#(paste(sample_s))
       }
       if (np_tests==6){
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         len<-length(x2)
         n<-seq(1:len)
         n_plus=0
         
         for(val in n){
           if(x1[val]==x2[val]){n_plus=n_plus+1}
         }
         
         
         output<-HTML(paste(withMathJax("$n^{=} =$"),n_plus))
       }
       
       if(np_tests==7){
         pass<-input$np_mc_pass
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         req(np_data_selected_columns,data,pass)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         cats<-unique(c(na.omit(unique(data[[as.numeric(np_data_selected_columns[1])]])),na.omit(unique(data[[as.numeric(np_data_selected_columns[2])]]))))
         cats<-c(cats[cats==pass],cats[cats!=pass])
         mctable<-table(factor(x1,levels = cats,labels=c("Pass","Fail")),factor(x2,levels = cats,labels=c("Pass","Fail")))
         
         c<-mctable[2,1]
         
         output<-HTML(paste0(withMathJax("$F_{1}P_{2}=$"),c))
       }
       output
       
     })
     
     output$npUI4_data <- renderUI({
       np_tests<-input$np_tests_data
       type<-input$data_type_np
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3 || np_tests==4){
         
         if(type==1){
           np_data_selected_columns<-input$np_data_selected_columns
           data<-res_filter$filtered()
           x2<-data[,as.numeric(np_data_selected_columns[2])]
         } else
           if(type==2){
             ref_col<-as.numeric(input$data_choice_ref_np)
             data_col<-as.numeric(input$data_choice_data_np)
             req(ref_col,data_col)
             data<-res_filter$filtered()
             
             x2<-data[,data_col][which(data[ref_col]==input$data_choice_g2_np)]
             
           }
         
         output<-HTML(paste(withMathJax("$n_2 =$"),length(na.omit(x2))))
       }
       
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
       }
       
       if(np_tests==7){
         pass<-input$np_mc_pass
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         req(np_data_selected_columns,data,pass)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         cats<-unique(c(na.omit(unique(data[[as.numeric(np_data_selected_columns[1])]])),na.omit(unique(data[[as.numeric(np_data_selected_columns[2])]]))))
         cats<-c(cats[cats==pass],cats[cats!=pass])
         mctable<-table(factor(x1,levels = cats,labels=c("Pass","Fail")),factor(x2,levels = cats,labels=c("Pass","Fail")))
         
         d<-mctable[2,2]
         
         output<-HTML(paste0(withMathJax("$F_{1}F_{2}=$"),d))
       }
       
       output
       
     })
     output$npUI5_data <- renderUI({
       np_tests<-input$np_tests_data
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3){
         output<-NULL
       }
       if (np_tests==4){
         output<-NULL
       }
       if (np_tests==5){
         
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         temp<-median.test.twosample.dependent.signtest(g1 = x1,g2 = x2)
         n_incl<-temp$estimate[2]
         
         n_above<-temp$estimate[3]
         
         output<-HTML(paste(withMathJax("$n^{-} =$"),n_incl-n_above))#(paste(sample_s))
       }
       if (np_tests==6){
         np_data_selected_columns<-input$np_data_selected_columns
         data<-res_filter$filtered()
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         len<-length(x2)
         n<-seq(1:len)
         n_plus=0
         
         for(val in n){
           if(x1[val]<x2[val]){n_plus=n_plus+1}
         }
         
         
         output<-HTML(paste(withMathJax("$n^{-} =$"),n_plus))
       }
       if(np_tests==7){return()}
       
       output
       
     })
     output$npUI6_data <- renderUI({
       np_tests<-input$np_tests_data
       req(np_tests)
       
       if (np_tests==1){
         output<-NULL
       }
       if (np_tests==2){
         output<-NULL
       }
       if (np_tests==3){
         output<-NULL
       }
       if (np_tests==4){
         output<-NULL
       }
       if (np_tests==5){
         output<-NULL
       }
       if (np_tests==6){
         output<-NULL
       }
       if(np_tests==7){return()}
       
       output
       
     })
     
     #generate the np output for data
     np_text_data_out <- reactive({
       conf<-input$conf_np_data
       R<-input$decimal_np_data
       alt<-input$choice_np_alt_stat_data
       np_tests<-input$np_tests_data
       npUI1<-input$npUI1_data
       npUI2<-input$npUI2_data
       npUI3<-input$npUI3_data
       npUI4<-input$npUI4_data
       npUI5<-input$npUI5_data
       npUI6<-input$npUI6_data
       np_data_selected_columns<-input$np_data_selected_columns
       data<-res_filter$filtered()
       
       req(data,np_tests,alt)
       
       type<-input$data_type_np
       ref_col<-as.numeric(input$data_choice_ref_np)
       data_col<-as.numeric(input$data_choice_data_np)
       g1<-input$data_choice_g1_np
       g2<-input$data_choice_g2_np
       
       if(type==1 && length(np_data_selected_columns)>2){return("Select up to two columns")}
       
   
       if(np_tests==1){#one-sample sign test
         req(npUI2,conf,np_data_selected_columns)
         x<-data[,as.numeric(np_data_selected_columns[1])]
         output<-median.test.onesample.signtest(x = x,null.hypothesis.location = npUI2,alternative = alt,conf.level = conf)
       }
       if(np_tests==2){
         req(npUI2,conf,np_data_selected_columns)
         x<-data[,as.numeric(np_data_selected_columns[1])]
         output<-wilcoxon.signed.ranks.onesample.test(x = x,null.hypothesis.location = npUI2,alternative = alt)
       }
       if(np_tests==3){
         req(input$np_data_u_go>mann_whitney_test_count,type)
         mann_whitney_test_count<<-input$np_data_u_go
         if(type==1){
           req(np_data_selected_columns)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         } else
           if(type==2){
             req(data_col,ref_col,g1,g2)
             x1<-data[,data_col][which(data[ref_col]==g1)]
             x2<-data[,data_col][which(data[ref_col]==g2)]
           }
         
         output<-median.test.twosample.independent.mann.whitney(g1 = x1,g2 = x2,alternative = alt)
       }
       if(np_tests==4){
         req(conf,type)
         if(type==1){
           req(np_data_selected_columns)
           x1<-data[,as.numeric(np_data_selected_columns[1])]
           x2<-data[,as.numeric(np_data_selected_columns[2])]
         } else
           if(type==2){
             req(data_col,ref_col,g1,g2)
             x1<-data[,data_col][which(data[ref_col]==g1)]
             x2<-data[,data_col][which(data[ref_col]==g2)]
           }
         output<-median.test.twosample.independent.mood(g1 = x1,g2 = x2,alternative = alt,conf.level = conf)
       }
       if(np_tests==5){
         req(conf,np_data_selected_columns)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         output<-median.test.twosample.dependent.signtest(g1 = x1,g2 = x2,alternative = alt,conf.level = conf)
       }
       if(np_tests==6){
         req(np_data_selected_columns)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         
         output<-wilcoxon.signed.ranks.twosample.test(g1 = x1,g2 = x2,alternative = alt)
       }
       
       if(np_tests==7){
         pass<-input$np_mc_pass
         req(pass,np_data_selected_columns)
         x1<-data[,as.numeric(np_data_selected_columns[1])]
         x2<-data[,as.numeric(np_data_selected_columns[2])]
         if(length(x1)!=length(x2)){return("Columns need to be equal length")}
         
         cats<-unique(c(na.omit(unique(data[[as.numeric(np_data_selected_columns[1])]])),na.omit(unique(data[[as.numeric(np_data_selected_columns[2])]]))))
         cats<-c(cats[cats==pass],cats[cats!=pass])
         mctable<-table(factor(x1,levels = cats,labels=c("Pass","Fail")),factor(x2,levels = cats,labels=c("Pass","Fail")))
         b<-mctable[1,2]
         c<-mctable[2,1]
         output<-proportion.test.mcnemar.simple(b = b,c = c,alternative = alt,conf.level = conf)
       }
       
       ro(output,R)
     })
     
     #render the text version of the np data output
     output$np_text_data <-renderPrint(
       np_text_data_out()
     )
     
     #add an output about which data vectors are selected for the data versions? I think there only needs to be one function for each vector? an if inside to select if it is column or reference
     
     output$pretty_nonparametric_data <- renderUI({
       conf<-input$conf_np_data
       R<-input$decimal_np_data
       alt<-input$choice_np_alt_stat_data
       np_tests<-input$np_tests_data
       npUI1<-input$npUI1_data
       npUI2<-input$npUI2_data
       npUI3<-input$npUI3_data
       npUI4<-input$npUI4_data
       npUI5<-input$npUI5_data
       npUI6<-input$npUI6_data
       np_data_selected_columns<-input$np_data_selected_columns
       data<-res_filter$filtered()
       results<-np_text_data_out()
       req(alt,results,np_tests,conf)
       
       data_type<-input$data_type_np
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(np_tests==1){#one sample sign test
         len=length(data[,as.numeric(np_data_selected_columns[1])])
         output<-
           HTML(c(paste("<b>Sign Test for Location</b><br>","<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{above} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$p_{above} = $"),results$statistic),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{equal} = $"), len-results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{below} = $"),results$estimate[2]-results$estimate[3]),"</td>",
                  
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{observed} = $"),len),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{included} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for proportion above = ",results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{above} :$")),"</td>",
                  
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(withMathJax("$p_{above} = $"),results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>","</table></br>",
                  "<table><tr><td>",beta_statement,results$estimate[4],"</td></tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==2){
         len=length(data[,as.numeric(np_data_selected_columns[1])])
         
         output<-#wilcoxon.signed.ranks.onesample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI2,adj.sample.size = npUI3,alternative = alt)
           
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S^{+} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$S^{-} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{observed} = $"),len),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{Adj.} = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("W = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==3){
         
         if (data_type==1){#columns
           group1_name<-names(data)[as.numeric(np_data_selected_columns)[1]]
           group2_name<-names(data)[as.numeric(np_data_selected_columns)[2]]
         } else{#reference
           group1_name<-paste("Group 1 = ",input$data_choice_g1_np)
           group2_name<-paste("Group 2 = ",input$data_choice_g2_np)
         }
         output<-#mann.whitney.u.test.simple(sum.ranks.g1 = npUI1,sum.ranks.g2 = npUI2,sample.size.g1 = npUI3,sample.size.g2 = npUI4,alternative = alt)
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                  "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$S_{2} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence selected"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("U = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==4){
         
         #type<-input$data_type_np
         req(data_type)
         
         if(data_type==1){
           req(np_data_selected_columns)
           len1=length(na.omit(data[,as.numeric(np_data_selected_columns[1])]))
           len2=length(na.omit(data[,as.numeric(np_data_selected_columns[2])]))
           group1_name<-names(data)[as.numeric(np_data_selected_columns)[1]]
           group2_name<-names(data)[as.numeric(np_data_selected_columns)[2]]
         } else
           if(data_type==2){
             ref_col<-as.numeric(input$data_choice_ref_np)
             data_col<-as.numeric(input$data_choice_data_np)
             req(ref_col,data_col)
             # g1<-as.numeric(input$data_choice_g1_np)
             # g2<-as.numeric(input$data_choice_g2_np)
             data<-res_filter$filtered()
             # req(ref_col,data_col,g1,g2)
             
             # len1<-length(data[,data_col][which(data[ref_col]==g1)])
             # len2<-length(data[,data_col][which(data[ref_col]==g2)])
             
             len1<-length(na.omit(data[,data_col][which(data[ref_col]==input$data_choice_g1_np)]))
             len2<-length(na.omit(data[,data_col][which(data[ref_col]==input$data_choice_g2_np)]))
             group1_name<-paste("Group 1 = ",input$data_choice_g1_np)
             group2_name<-paste("Group 2 = ",input$data_choice_g2_np)
             }
         
         output<-#median.test.twosample.independent.mood.simple(n.below.g1 = npUI5,n.equal.g1 = npUI3,n.above.g1 = npUI1,n.below.g2 = npUI6,n.equal.g2 = npUI4,n.above.g2 = npUI2,alternative = alt,conf.level = conf)
           HTML(c(paste("<b>","Two-Sample Median Test<br>Method: ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr><td style='border-bottom:1px solid #000'>",group1_name,"</td><td style='border-bottom:1px solid #000'></td>",
                  "<td style='border-bottom:1px solid #000'>",group2_name,"</td></tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; above} = $"),results$estimate[3]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p_{1\\; above} = $"),results$estimate[1]),"</td>",
                  "<td>",paste(withMathJax("$n_{2\\; above} = $"),results$estimate[9]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p_{2\\; above} = $"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1\\; equal} = $"),len1-results$estimate[2]),"</td><td></td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2\\; equal} = $"),len2-results$estimate[8],"</td><td></td>",
                               "</tr>",
                               "<tr>",
                               "<td>",paste(withMathJax("$n_{1\\; below} = $"),results$estimate[4]),"</td><td></td>",
                               "<td>","</td>",
                               "<td>",paste(withMathJax("$n_{2\\; below} = $"),results$estimate[10]),"</td><td></td>",
                               "</tr>",
                               "<tr>",
                               "<td>",paste(withMathJax("$n_{1\\; total\\; inc.} = $"),results$estimate[2]),"</td><td></td>",
                               "<td>","</td>",
                               "<td>",paste(withMathJax("$n_{2\\; total\\; inc.} = $"),results$estimate[8]),"</td><td></td>",
                               "</tr>",
                               "</table>",
                               
                               "<table>",
                               "<tr>",
                               "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi_{1 \\;above} :$")),"</td>",
                               "<td>",results$estimate[5],"</td>",
                               "<td>"," to ","</td>",
                               "<td>",results$estimate[6],"</td>",
                               "</tr>",
                               
                               "<tr>",
                               "<td align='right'>",paste(withMathJax("$\\pi_{2 \\;above} :$")),"</td>",
                               "<td>",results$estimate[11],"</td>",
                               "<td>"," to ","</td>",
                               "<td>",results$estimate[12],"</td>",
                               "</tr>",
                               
                               "<tr>",
                               "<td align='right'>","Odds Ratio:","</td>",
                               "<td>",results$conf.int[1],"</td>",
                               "<td>"," to ","</td>",
                               "<td>",results$conf.int[2],"</td>",
                               "</tr>",
                               "</table>",
                               
                               "<table>",
                               "<tr>",
                               "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                               "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                               "</tr>",
                               "</table>"
                               
                  )
                  
           )
           )         
       }
       if(np_tests==5){
         req(np_data_selected_columns)
         len2=length(data[,as.numeric(np_data_selected_columns[2])])
         group1_name<-names(data)[as.numeric(np_data_selected_columns)[1]]
         group2_name<-names(data)[as.numeric(np_data_selected_columns)[2]]
         
         output<-#median.test.twosample.dependent.signtest.simple(n.below = npUI5,n.equal = npUI3,n.above = npUI1,alternative = alt,conf.level = conf)
           HTML(c(paste("<b>Two-Sample Dependent Sign Test for Location</b><br>","<b>","Method: ",results$method,"</b>"),
                  "<br>",
                  paste("Direction assessed by subtracting ",group2_name," from ",group1_name),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{+} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$p^{+} = $"),results$statistic),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{=} = $"),len2-results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n^{-} = $"),results$estimate[2]-results$estimate[3]),"</td>",
                  
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{observed} = $"),len2),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{included} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for the probability that the difference in each pair is positive = ",results$parameter),"</td>",
                  "</tr>",
                  "</table>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for",withMathJax("$\\pi^{+} :$")),"</td>",
                  
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(withMathJax("$p^{+} = $"),results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>",
                  "<table><tr>,<td>",beta_statement,results$estimate[4],"</td></tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==6){
         group1_name<-names(data)[as.numeric(np_data_selected_columns)[1]]
         group2_name<-names(data)[as.numeric(np_data_selected_columns)[2]]
         
         output<-#wilcoxon.signed.ranks.twosample.test.simple(sum.ranks.positive = npUI1,sum.ranks.negative = npUI3,sample.size = npUI5,alternative = alt)
           HTML(c(paste("<b>","Method: Dependent ",results$method,"</b>"),
                  "<br>",
                  paste("Direction assessed by subtracting ",group2_name," from ",group1_name),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$S^{+} = $"),results$estimate[1]),"</td>",
                  "</tr>",
                  "<td>",paste(withMathJax("$S^{-} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("W = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       if(np_tests==7){
         output<-
           HTML(c(paste("<b>","Method: ",results$method,"</b>"),
                  "<br>Test 1 is column ",names(data)[as.numeric(np_data_selected_columns[1])],"<br>",
                  "Test 2 is column ",names(data)[as.numeric(np_data_selected_columns[2])],"<br>",
                  "Pass is indicated by",input$np_mc_pass,"<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$P_{1}F_{2} = $"),results$estimate[1]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p(b) = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<td>",paste(withMathJax("$F_{1}P_{2} = $"),results$estimate[3]),"</td><td></td>",
                  "<td>",paste(withMathJax("$p(c) = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_np_alt_text[3*(as.numeric(np_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
       }
       
       output
       
     })
     
     #render np more info text
     observeEvent(input$np_more_info_data,{# output$np_more_info_text_data<-renderUI({
       np_more_info<-input$np_more_info_data
       np_tests<-input$np_tests_data
       if(!np_more_info){return()}
       req(np_tests)
       
       # if(np_more_info==F){
       #   text_out<-HTML("")
       # }
       # else{
         if (np_tests==1){
           title="One-Sample Sign Test for Location"
           text_out<-HTML("The one-sample sign test for location is simply a test to see if the number of observations above the location of interest is equal to the number below that location. You can get exactly the same answer by testing the proportion above or below some number against a null hypothesis of \U03c0 = 0.5. Ties are not counted. It has the same assumptions as the one-sample binomial test, namely that the samples are randomly drawn from a population with a constant probability (in this case of being above or below some location) and are independent. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Sign_test'>Wikipedia</a>")
         }
         if (np_tests==2){
           title="One-Sample Wilcoxon Signed Ranks Test"
           text_out<-HTML("The one-sample Wilcoxon Signed Ranks Test for location is an alternative to the one-sample t-test when the normality assumption of the t-test cannot be assumed. The data must be ordinal and independent. To caculate the sum of the ranks, calculate the difference of each observation from the selected location, drop any observations of zero difference, take the absolute value of the differences, and get the average rank of these for each observation. Sum the average ranks for those observations falling above and below the selected location. The smaller of the two will be used to generate a z-score and p-value. </br></br>For more information see <a href='https://nyuwinthrop.org/wp-content/uploads/2019/08/wilcoxon-sign-rank-test-one-sample.pdf'>NYU Winthrop</a>")
         }
         if (np_tests==3){
           title="Two-Sample Wilcoxon-Mann-Whitney U Test"
           text_out<-HTML("The two-sample Wilcoxon-Mann-Whitney U Test for equality of distributions with particular sensitivity to location. It is an alternative to the two-sample t-test when the normality assumption of the t-test cannot be assumed. The data must be ordinal and independent with approximately the same dispersion. To caculate the sum of the ranks for each group assign an average rank to all the observations from both groups. Sum the average ranks for each group. A U statistic is calculated for each group and the smaller one is used to generate a z-score and p-value. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test'>Wikipedia</a>")
         }
         if (np_tests==4){
           title="Two-Sample Median Test"
           text_out<-HTML("The two-sample median test assesses whether the median of two samples are equal. It does have lower power than the Wilcoxon-Mann-Whitney test, so that test is preferred unless the dispersions are not approximately equal or if one or more observation exceeds the measurement device scale (pegs the dial). </br></br>For more information see <a href='https://en.wikipedia.org/wiki/Median_test'>Wikipedia</a>")
         }
         if (np_tests==5){
           title="Two-Sample Dependent Sign Test"
           text_out<-HTML("The two-sample dependent sign test is based on the binomial distribution like the one-sample sign test. It only assumes the data are independent, comes from the same population, and are at least ordinal. For each paired value, the difference is either positive, negative, or equal. If there is no difference between the dependent observations, it should be a 50-50 chance that one is above the other, and that is assessed with an exact binomial test.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Sign_test'>Wikipedia</a>")
         }
         if (np_tests==6){
           title="Two-Sample Dependent Wilcoxon Signed Ranks Test"
           text_out<-HTML("The two-sample dependent Wilcoxon Signed Ranks test is an alternative to the paired t-test when the assumption of normally distributed difference cannot be assumed. To caculate the sum of the ranks, calculate the difference between each pair of observations, drop any observations of zero difference, take the absolute value of the differences, and get the average rank of these for each observation. Sum up the ranks that came from a positive difference and sum up the ranks that came from a negative difference. The negative sum will be subtracted from the positive sum to generate the W statistic which will be used to generate a z-score and p-value.</br></br>For more information see <a href='https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test'>Wikipedia</a>")
         }
       if (np_tests==7){
         title="McNemar's Test of Change"
         text_out<-HTML("McNemar's Test of Change is used on paired dichomous data. It is commonly used to determine if there is a difference is caused by some treatment. The same units are classified before the intervention, then afterward. The test only concerns the two cells P1F2 and F1P2 and is a binomial test to determine of the probability of these events has changed. If the probabilities are significantly different, the conclusion is that the treatment has caused a some change,for good or bad. </br></br>For more information see <a href='https://en.wikipedia.org/wiki/McNemar%27s_test'>Wikipedia</a>")
       }
         
       # }
       #text_out
       sendSweetAlert(title = title,text = HTML(text_out),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
       updateCheckboxInput(inputId = "np_more_info_data",value = FALSE)
       
     })
     #Render the correlation test radio buttons
     output$corr_tests_data<-renderUI({
       one_or_two_corr<-input$one_or_two_corr_data
       
       if(one_or_two_corr==1){#one sample test
         corr_test_choice<-c(1:12)
         names(corr_test_choice)<-c("Pearson r","Spearman Rank r\U209B","Kendall's \U1D70F","\U1D719 / Cram\U00E9r's V","Biserial","Point Biserial","Yule's Q","Goodman and Kruskal's \U1D6FE","Tetrachroric Correlation","Cohen's \U1D73F","Kendall's Concordance","J-Index of Predictive Efficiency")
       }
       if(one_or_two_corr==2){#two sample independent
         corr_test_choice<-c(13:16)#ERROR need to add tests and increment numbers
         names(corr_test_choice)<-c("Pearson r","Goodman and Kruskal's \U1D6FE","Cohen's \U1D73F","J-Index of Predictive Efficiency")
       }
       if(one_or_two_corr==3){#two sample dependent
         corr_test_choice<-c(17)
         names(corr_test_choice)<-c("Pearson r")
       }
       radioButtons(inputId = "corr_tests_data",label = "Select Test",choices = corr_test_choice)
     })
     
     #render the correlation data vectors 1
     output$data_choice_column_corr_1 <-renderUI({
       
       req(res_filter$filtered())
       
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       test<-input$corr_tests_data
       req(test)
       #data_type<-input$corr_data_type
       
       if (test==1){
       output<-selectInput(inputId = "corr_data_selected_columns_1",
                                  label = "X Data",
                                  choices = choices)
       }
       if (test==2){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "X\U2081 Data",
                             choices = choices)
       }
       if (test==3){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "X\U2081 Data",
                             choices = choices)
       }
     #add other tests by data type
       if (test==4 || test==7 || test==8 || test==9){
         output<-selectInput(inputId = "corr_data_selected_columns_1",label = "Row Data",choices = choices)
       }
       if (test==5){
         output<-selectInput(inputId = "corr_data_selected_columns_1",label = "Dichotomized Data",choices = choices)
       }
       if (test==6){
         output<-selectInput(inputId = "corr_data_selected_columns_1",label = "Dichotomous Data",choices = choices)
       }
       if (test==10){
         output<-selectInput(inputId = "corr_data_selected_columns_1",label = "Rater 1",choices = choices)
       }
       
       if (test==11){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Items Being Ranked",
                             choices = choices)
       }
       if (test==12){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Actual",
                             choices = choices)
       }
       
       if (test==13){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "X\U2081",
                             choices = choices)
       }
       if (test==14){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "Group",
                             choices = choices)
       }
       if (test==15){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "Group",
                             choices = choices)
       }
       if (test==16){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "Group",
                             choices = choices)
       }
       if (test==17){
         output<-selectInput(inputId = "corr_data_selected_columns_1",
                             label = "X\U2081",
                             choices = choices)
       }
       
       
       output
     })
     #render the correlation data vectors 2
     output$data_choice_column_corr_2 <-renderUI({
       
       req(res_filter$filtered())
       
       
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       test<-input$corr_tests_data
       req(test)
       data_type<-input$corr_data_type
       

       if (test==1){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Y Data",
                             choices = choices)
       }
       if (test==2){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "X\U2082 Data",
                             choices = choices)
       }
       if (test==3){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "X\U2082 Data",
                             choices = choices)
       }
       if (test==4 || test==7 || test==8 || test==9){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Column Data",
                             choices = choices)
       }
       if (test==5 || test==6){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Continuous Data",
                             choices = choices)
       }
       if (test==10){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Rater 2",
                             choices = choices)
       }
       if (test==11){
         if(data_type==1){#error need to select data type
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Judges",
                             choices = choices)
         }
         if(data_type==2){
           output<-selectizeInput(inputId = "corr_data_selected_columns_2",
                               label = "Select Judges",
                               multiple = T,
                               choices = choices)
         }
         
       }
       if (test==12){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Predicted",
                             choices = choices)
       }
       if (test==13){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Y\U2081",
                             choices = choices)
       }
       if (test==14){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Ordinal Data 1",
                             choices = choices)
       }
       if (test==15){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Judge 1",
                             choices = choices)
       }
       if (test==16){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "Predicted",
                             choices = choices)
       }
       if (test==17){
         output<-selectInput(inputId = "corr_data_selected_columns_2",
                             label = "X\U2082",
                             choices = choices)
       }
       
       
       output
     })
     
     #render the correlation data vectors 3
     output$data_choice_column_corr_3 <-renderUI({
       test<-input$corr_tests_data
       data_type<-input$corr_data_type
       
       req(res_filter$filtered(),test)
       
       if(is.null(data_type)){data_type<-0}
       
       output=NULL
       
       #if(test==5 || test==6){output=NULL}
       
       if((test>3) && (data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                           label = "Weight",
                           choices = choices)
       } 
       if((test==10 && data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Weight",
                             choices = choices)
       }
       if((test==11)){
         if(data_type==1){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Ratings",
                             choices = choices)
         }
         if(data_type==2){output<-NULL}
         
       }
       if((test==12) && (data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Weight",
                             choices = choices)
       } 
       if((test==13)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "X\U2082",
                             choices = choices)
       } 
       if((test==14)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Ordinal Data 2",
                             choices = choices)
       } 
       if((test==15)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Judge 2",
                             choices = choices)
       } 
       if((test==16)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "Actual",
                             choices = choices)
       } 
       if((test==17)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_3",
                             label = "X\U2083 (Common variable)",
                             choices = choices)
       } 
       
         
      
       
       
       #else {output<-NULL}
     
       output
     })
     #render the correlation data vectors 4
     output$data_choice_column_corr_4 <-renderUI({
       #one_or_two_corr<-input$one_or_two_corr_data
       test<-input$corr_tests_data
       data_type<-input$corr_data_type
       
       req(res_filter$filtered(),test)
       output<-NULL
       
       if((test==13)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_4",
                             label = "Y\U2082",
                             choices = choices)
       } 
       if((test==14)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_4",
                             label = "Weight",
                             choices = choices)
       } 
       
       if((test==14)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_4",
                             label = "Weight",
                             choices = choices)
       } 
       # if((test==15)){
       #   choices<-seq(1:ncol(res_filter$filtered()))
       #   names(choices)<-names(res_filter$filtered())
       #   output<-selectInput(inputId = "corr_data_selected_columns_4",
       #                       label = "Weight",
       #                       choices = choices)
       # } 
       
       if((test==16 && data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-selectInput(inputId = "corr_data_selected_columns_4",
                             label = "Weight",
                             choices = choices)
       } 
       
       
       
       output
     })
     
     #render corrUI_for data
     output$corrUI1_data <- renderUI({
       corr_tests<-input$corr_tests_data
       corr_data_1<-input$corr_data_selected_columns_1
       corr_data_2<-input$corr_data_selected_columns_2
       corr_data_3<-input$corr_data_selected_columns_3
       corr_data_4<-input$corr_data_selected_columns_4
       data<-res_filter$filtered()
       R<-input$decimal_corr_data
       
       x1<-data[,as.numeric(corr_data_1)]
       x2<-data[,as.numeric(corr_data_2)]
       x3<-data[,as.numeric(corr_data_3)]
       x4<-data[,as.numeric(corr_data_4)]
       
       req(res_filter$filtered,corr_tests)
       
       output<-NULL
       
       if(corr_tests==1){
         output<-numericInput(inputId = "corr_UI1_data",label = withMathJax("$$\\rho_{0}:{ }$$"),value = 0,width = "750px")
       }
       if(corr_tests==2){
         #temp<-cor.spearman.rank(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$r_{S12} =$"),ro(temp$estimate[1],R)))#NULL#numericInput(inputId = "stat_corr1",label = withMathJax("$$r_{s}:{ }$$"),value = .5,width = "750px")
       }
       if(corr_tests==3){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$t_{12} =$"),ro(temp$estimate[1],R)))#numericInput(inputId = "stat_corr1",label = "Concordant Pairs",value = 395,width = "750px")
       }
       if(corr_tests==4){
         
         output<-NULL
         
       }
       if(corr_tests==5){
         #temp<-cor.biserial(discrete_var = x1,continuous_var = x2)
         output<-NULL#HTML(paste(withMathJax("$r_{bi} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==6){
         #temp<-cor.point.biserial(discrete_var = x1,continuous_var = x2)
         output<-NULL#HTML(paste(withMathJax("$r_{pbi} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==7){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==8){
         output<-numericInput(inputId = "corr_UI1_data",label = withMathJax("$$\\gamma_{0}:{ }$$"),value = 0,width = "750px")
       }
       if(corr_tests==9){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==10){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==11){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==12){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       if(corr_tests==13){
         #temp<-cor.kendall.tau(x1 = x1,x2 = x2)
         output<-NULL#HTML(paste(withMathJax("$\\tau_{12} =$"),ro(temp$estimate[1],R)))
       }
       
       
       output
       
     })
     
     output$corrUI2_data <- renderUI({
       corr_tests<-input$corr_tests_data
       
       
       req(res_filter$filtered)
       
       output<-NULL
       
       output
       
     })
     
     #generate the text for the non-pretty output
     output$corr_text_data<-renderPrint({
       corr_data_out()
     })
     
     #generate the non-pretty output
     corr_data_out<-reactive ({ #output$renderPrint({
       
       
       UI1<-input$corr_UI1_data
       UI2<-input$corr_UI2_data
       UI3<-input$corr_UI3_data
       UI4<-input$corr_UI4_data
       UI5<-input$corr_UI5_data
       UI6<-input$corr_UI6_data
       alt<-input$alt_corr_data
       conf<-input$conf_corr_data
       
       corr_tests<-input$corr_tests_data
       corr_data_1<-input$corr_data_selected_columns_1
       corr_data_2<-input$corr_data_selected_columns_2
       corr_data_3<-input$corr_data_selected_columns_3
       corr_data_4<-input$corr_data_selected_columns_4
       data<-res_filter$filtered()
       R<-input$decimal_corr_data
       
       data_type<-input$corr_data_type
       req(corr_tests,data,alt)
       
       x1<-data[,as.numeric(corr_data_1)]
       x2<-data[,as.numeric(corr_data_2)]
       x3<-data[,as.numeric(corr_data_3)]
       x4<-data[,as.numeric(corr_data_4)]
       #xtab<-crosstab_corr_data() #this causes the non xtab ones to not display until you click on one of them - no idea why - it is not even entering corr_data_out until one of the xtab ones is clicked
       
        if(corr_tests==1){
          req(UI1,corr_data_1!=corr_data_2)
          output<-cor.pearson.r.onesample(x = x1,y = x2,null.hypothesis.rho = UI1,alternative = alt,conf.level = conf)   #(x = x1,y = x2,null.hypothesis.rho = UI2)#,alternative = alt,conf.level = conf)
        }
       if(corr_tests==2){
         req(corr_data_1!=corr_data_2)
         output<-cor.spearman.rank(x1 = x1,x2 = x2,conf.level = conf,alternative = alt)
       }
       if(corr_tests==3){
         req(corr_data_1!=corr_data_2)
         output<-cor.kendall.tau(x1 = x1,x2 = x2,alternative = alt,conf.level = conf)
       }
       if(corr_tests==4){
         xtab<-crosstab_corr_data()
         output<-cor.cramer.v(xtab)
       }
       if(corr_tests==5){
         temp<-data.frame(x1,x2)
         temp<-na.omit(temp)#filters out lines with missing data
         output<-cor.biserial(discrete_var = temp$x1,continuous_var = temp$x2,alternative = alt,conf.level = conf)
       }
       
       if(corr_tests==6){
         temp<-data.frame(x1,x2)
         temp<-na.omit(temp)#filters out lines with missing data
         output<-cor.point.biserial(discrete_var = temp$x1,continuous_var = temp$x2,alternative = alt,conf.level = conf)
       }
       if(corr_tests==7){
         xtab<-crosstab_corr_data()
         output<-cor.yule.q(x = xtab,alternative = alt)
       }
       if(corr_tests==8){
         xtab<-crosstab_corr_data()
         output<-cor.goodman.kruskal.gamma.onesample(x = xtab,null.hypothesis.gamma = UI1,alternative = alt,conf.level = conf)
       }
       if(corr_tests==9){
         xtab<-crosstab_corr_data()
         output<-cor.tetrachoric(x = xtab,alternative = alt,conf.level = conf)
       }
       if(corr_tests==10){
         xtab<-crosstab_corr_data()
         output<-cor.cohen.kappa.onesample(xtab,alternative = alt,conf.level = conf)#paste("test ",corr_tests," ","data type ",input$corr_data_type)
       }
       if(corr_tests==11){
         xtab<-crosstab_corr_data()
         output<-cor.kendall.coefficient.concordance(x = xtab,alternative = alt,conf.level = conf)
       }
       if(corr_tests==12){
         xtab<-crosstab_corr_data()
         output<-cor.j.index.onesample(x = xtab,conf.level = conf,alternative = alt)
       }
       if(corr_tests==13){
         #create two independent data sets
         set1<-na.omit(data.frame(x1,x2))
         set2<-na.omit(data.frame(x3,x4))
         output<-cor.pearson.r.twosample.independent(x1 = set1$x1,x2 = set1$x2,x3 = set2$x3,x4 = set2$x4,alternative = alt,conf.level = conf)
       }
       if(corr_tests==14){
         #A little work first since there isn't a two sample gamma for data
         data1<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==1 ), ])
         data2<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==2 ), ])
         

         xtab1<-transform.independent.format.to.xt(x_row = data1[,as.numeric(corr_data_2)],x_col = data1[,as.numeric(corr_data_3)],weight = data1[,as.numeric(corr_data_4)])
         xtab2<-transform.independent.format.to.xt(x_row = data2[,as.numeric(corr_data_2)],x_col = data2[,as.numeric(corr_data_3)],weight = data2[,as.numeric(corr_data_4)])
         
         

         gamma_out1<-cor.goodman.kruskal.gamma.onesample(x = xtab1,null.hypothesis.gamma = 0,alternative = alt,conf.level = conf)
         gamma_out2<-cor.goodman.kruskal.gamma.onesample(x = xtab2,null.hypothesis.gamma = 0,alternative = alt,conf.level = conf)
         gamma1<-gamma_out1$estimate[1]
         gamma1_se<-gamma_out1$estimate[2]
         gamma2<-gamma_out2$estimate[1]
         gamma2_se<-gamma_out2$estimate[2]
         
         output<-cor.goodman.kruskal.gamma.twosample.independent.simple(gamma.g1 = gamma1,se.est.gamma.g1 = gamma1_se,gamma.g2 = gamma2,se.est.gamma.g2 = gamma2_se,alternative = alt,conf.level = conf)

       }
       
       if(corr_tests==15){
         #A little work first since there isn't a two sample kappa for data
         data1<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==1 ), ])
         data2<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==2 ), ])
         
         
         xtab1<-transform.independent.format.to.xt(x_row = data1[,as.numeric(corr_data_2)],x_col = data1[,as.numeric(corr_data_3)])
         xtab2<-transform.independent.format.to.xt(x_row = data2[,as.numeric(corr_data_2)],x_col = data2[,as.numeric(corr_data_3)])
         
         
         
         kappa_out1<-cor.cohen.kappa.onesample(xtab1,alternative = alt,conf.level = conf)
         kappa_out2<-cor.cohen.kappa.onesample(xtab2,alternative = alt,conf.level = conf)
         kappa1<-kappa_out1$estimate[1]
         kappa1_se<-kappa_out1$estimate[2]
         kappa2<-kappa_out2$estimate[1]
         kappa2_se<-kappa_out2$estimate[2]
         
         output<-cor.cohen.kappa.twosample.independent.simple(kappa.g1 = kappa1,se.kappa.g1 = kappa1_se,kappa.g2 = kappa2,se.kappa.g2 = kappa2_se,alternative = alt,conf.level = conf)
         
       }
       if(corr_tests==16){
         #A little work first
         data1<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==1 ), ])
         data2<-as.data.frame(data[ which( data[,as.numeric(corr_data_1)]==2 ), ])
         
         if(data_type==1){
         xtab1<-transform.independent.format.to.xt(x_row = data1[,as.numeric(corr_data_2)],x_col = data1[,as.numeric(corr_data_3)])
         xtab2<-transform.independent.format.to.xt(x_row = data2[,as.numeric(corr_data_2)],x_col = data2[,as.numeric(corr_data_3)])
         }
         
         if(data_type==2){
           xtab1<-transform.independent.format.to.xt(x_row = data1[,as.numeric(corr_data_2)],x_col = data1[,as.numeric(corr_data_3)],weight = data1[,as.numeric(corr_data_4)])
           xtab2<-transform.independent.format.to.xt(x_row = data2[,as.numeric(corr_data_2)],x_col = data2[,as.numeric(corr_data_3)],weight = data2[,as.numeric(corr_data_4)])
         }
         
         
         output<-cor.j.index.twosample(x1 = xtab1,x2 = xtab2,alternative = alt,conf.level = conf)
       }
       
       if(corr_tests==17){
         
         output<-cor.pearson.r.twosample.dependent(x1 = x1,x2 = x2,x3 = x3,alternative = alt,conf.level = conf)
       }
       
       ro(output,R)
       
     })
     
     #make a crosstabs from the data
     crosstab_corr_data <- reactive({
       req(res_filter$filtered())
       
       data_type<-input$corr_data_type
       req(data_type)
       
       corr_tests<-input$corr_tests_data
       corr_data_1<-input$corr_data_selected_columns_1
       corr_data_2<-input$corr_data_selected_columns_2
       corr_data_3<-input$corr_data_selected_columns_3
       corr_data_4<-input$corr_data_selected_columns_4
       data<-res_filter$filtered()
       R<-input$decimal_corr_data
       
       x1<-data[,as.numeric(corr_data_1)]
       x2<-data[,as.numeric(corr_data_2)]
       x3<-data[,as.numeric(corr_data_3)]
       x4<-data[,as.numeric(corr_data_4)]
       
       
       choices<-seq(1:ncol(res_filter$filtered()))
       
       output<-NULL
       
     
       
       #if independent format
       if(data_type==1 && corr_tests!=11){
         output<-transform.independent.format.to.xt(x_row = x1,x_col = x2,na.rm = T,x_row_name =names(data[as.numeric(corr_data_1)]),x_col_name = names(data[as.numeric(corr_data_2)]) )
       }

       #if weighted format
       if((data_type==2 && corr_tests!=11) || (corr_tests==11 && data_type==1) ){ 
         output<-transform.independent.format.to.xt(x_row = x1,x_col = x2,weight = x3,na.rm = T,x_row_name =names(data[as.numeric(corr_data_1)]),x_col_name = names(data[as.numeric(corr_data_2)]) )
       }

       #if tabular
       if(data_type==2 && corr_tests==11){
         selected_judges<-as.numeric(unlist(strsplit (x = corr_data_2,split = "\\s+")))
         items<-as.numeric(corr_data_1)
         
         output<-data[,c(selected_judges)]
         
       }

       output

     })
     
     #render crosstabs for corr
     output$corr_xtab<-renderPrint({
       crosstab_corr_data()
     })
     
     #Render the alternative hypothesis for the correlation association page with data
     output$corr_alt_data <- renderUI({
       corr_tests<-input$corr_tests_data
       req(corr_tests)
       
       choice_corr_alt <-c("two.sided","less","greater")
       if(corr_tests==4){choice_corr_alt <-c("two.sided","","")}
       index=(3*(as.numeric(corr_tests)-1))+1
       
       names(choice_corr_alt) <-choice_corr_alt_text_data[c(seq(index,index+2))]
       
       selectInput(inputId = "alt_corr_data",label = "Alternative Hypothesis",choices = choice_corr_alt)
     })
     
     #generate the UI for data configuration for corr with data
     output$data_config<-renderUI({
       test<-input$corr_tests_data
       
       req(res_filter$filtered(),test)
       
       output<-NULL
       
       if((test==4) || (test==7) || (test==8) || (test==9) || (test==10)|| (test==12) || (test==16)){
         output<-radioButtons(inputId = "corr_data_type",label = "How is your data configured?",choices = c("Independent"=1,"Frequency"=2),inline = T)
       }
       if(test==11){#kendall's concordance
         output<-radioButtons(inputId = "corr_data_type",label = "How is your data configured?",choices = c("Independent"=1,"Tabular"=2),inline = T)
       }
       output
     })
     
     #corr_data_out
     
     #pretty output for correlation with data
     output$pretty_corr_data<-renderUI({
       conf<-input$conf_corr_data
       R<-input$decimal_corr_data
       alt<-input$alt_corr_data
       corr_tests<-input$corr_tests_data
       UI1<-input$corr_UI1_data
       UI2<-input$corr_UI2_data
       UI3<-input$corr_UI3_data
       UI4<-input$corr_UI4_data
       UI5<-input$corr_UI5_data
       UI6<-input$corr_UI9_data
       corr_data_selected_columns<-input$corr_data_selected_columns
       data<-res_filter$filtered()
       
       corr_data_1<-input$corr_data_selected_columns_1
       corr_data_2<-input$corr_data_selected_columns_2
       corr_data_3<-input$corr_data_selected_columns_3
       corr_data_4<-input$corr_data_selected_columns_4
       
       #xtab<-crosstab_corr_data()
       
       #req(corr_data_out())
       results<-corr_data_out()
       req(results,alt,corr_tests)
       
       if(alt=="two.sided"){
         alt_num<-1
       }
       if (alt=="less"){
         alt_num<- 2
       }
       if (alt=="greater"){
         alt_num<-3
       }
       
       if(corr_tests==1){#one-sample Pearson
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{0}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},results$statistic),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>",
                  
                  #"<br><br>",
                  paste(beta_statement,100*results$estimate[8],"%")
           )
           
           )
         
       }
       
       if(corr_tests==2){#one-sample Spearman
         output<-
           HTML(c(paste("<b>One-Sample ",results$method," Test</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_s = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{s}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{s}^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[2]+2),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{s} :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("t = ",results$statistic),"</td>",
                  "<td>",paste("df = ",results$estimate[2]),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
         
       }
       
       if(corr_tests==3){#Kendall tau
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste("Concordant Pairs: ",results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste("Discordant Pairs: ",results$estimate[4]),"</td>",
                  "</tr>","<tr>",
                  "<td>",paste("Count Ties X: ",UI3),"</td>",
                  "<td>","</td>",
                  "<td>",paste("Count Ties Y: ",UI4),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\tau = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>","</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
         
       }
       
       
       if(corr_tests==4){#phi/Cramers V
         xtab<-crosstab_corr_data()
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),#paste(withMathJax("$\\phi$"),"/ Cram\U00E9r's V")
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$V =$"),results$statistic),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$E_{min} =$"),results$estimate[3]),"</td>",
                  "<td>",if(results$estimate[3]<5){paste("<p style='color:red;'> ***Warning ",withMathJax("$E_{min}<5$"),"***</p>")},"</td>",
                  "</tr>",
                  
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(withMathJax(("$\\chi^2 =$")),results$estimate[1]),"</td>",
                 "<td>",paste("df = ",(nrow(xtab)-1)*(ncol(xtab)-1)),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
           )
           
           )
         
       }
       if(corr_tests==5){#biserial
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{bi} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{bi0}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{bi}^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
                  
                  
           )
           
           )
         
       }
       if(corr_tests==6){#point biserial
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{pbi} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{pbi0}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{pbi}^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{1} = $"),results$estimate[5]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{2} = $"),results$estimate[8]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{pbi} :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("t = ",results$statistic),"</td>",
                  "<td>",paste("df = ",results$estimate[2]),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==7){#Yule's
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$Q = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==8){#one-sample Goodman and Kruskall gamma
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$G = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\gamma_{0}=$"),UI1),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{subj} = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{con} = $"),results$estimate[4]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{dis} = $"),results$estimate[5]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\gamma :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       if(corr_tests==9){#tetrachoric
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{t} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{t0}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),results$estimate[5]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==10){#one-sample kappa
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\kappa_{0}=$"),results$parameter),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa_{max} = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{agree} = $"),results$estimate[6]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{disagree}=$"),results$estimate[7]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\kappa :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==11){#one-sample kendall's concordance
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$W = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$W'=$"),UI1),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{subj} = $"),results$estimate[2]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{raters} = $"),results$estimate[3]),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste(withMathJax("$\\chi^2=$"),results$statistic),"</td>",
                  "<td>",paste("df = ",results$estimate[2]-1),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==12){#one-sample J-Index
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$J = $"),results$statistic),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$J'=0$")),"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$J :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("J = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       
       if(corr_tests==13){#two-sample Pearson indep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{34}=$"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12}^2 = $"),results$estimate[6]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{34}^2 = $"),results$estimate[12]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n_{12} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$n_{34} = $"),results$estimate[8]),"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{12} :$")),"</td>",
                  "<td>",results$estimate[4],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[5],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{34} :$")),"</td>",
                  "<td>",results$estimate[10],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[11],"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )

           )

       }

       if(corr_tests==14){#two-sample Goodman and Kruskall gamma
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$G_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$G_{2}=$"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\sigma_{SE_{1}} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\sigma_{SE_{2}} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )

           )

       }

       if(corr_tests==15){#two-sample kappa
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$\\kappa_{1} = $"),results$estimate[1]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\kappa_{2}=$"),results$estimate[3]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$SE_{\\kappa_{1}} = $"),results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$SE_{\\kappa_{2}} = $"),results$estimate[4]),"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence"),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )

           )

       }

       if(corr_tests==16){#one-sample J-Index
         output<-
           HTML(c(paste("<b> Two-Sample ",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$J_{1} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$J_{2} = $"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$J_{diff} = $"),results$estimate[1]),"</td>",
                  
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$J_{diff} :$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$J_{1} :$")),"</td>",
                  "<td>",results$estimate[5],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[6],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$J_{2} :$")),"</td>",
                  "<td>",results$estimate[9],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[10],"</td>",
                  "</tr>",
                  "</table>",
                  
                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("z = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )
           
           )
         
       }
       
       if(corr_tests==17){#two-sample Pearson dep
         output<-
           HTML(c(paste("<b>",results$method,"</b>"),
                  "<br><br>",
                  "<table>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{13} = $"),results$estimate[3]),"</td>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$r_{23}=$"),results$estimate[7]),"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{12} = $"),results$estimate[11]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$n = $"),3+results$estimate[2]),"</td>",
                  "<td>","</td>",
                  "<td>","</td>",
                  "</tr>",
                  "<tr>",
                  "<td>",paste(withMathJax("$r_{13} - r_{23} = $")),results$estimate[1],"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste(conf*100,"% confidence interval for"),"</td>",
                  "<td>",paste(withMathJax("$\\rho_{13} - \\rho_{23}:$")),"</td>",
                  "<td>",results$conf.int[1],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$conf.int[2],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{13} :$")),"</td>",
                  "<td>",results$estimate[4],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[5],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{23} :$")),"</td>",
                  "<td>",results$estimate[8],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[9],"</td>",
                  "</tr>",
                  "<tr>",
                  "<td>","</td>",
                  "<td>",paste(withMathJax("$\\rho_{12} :$")),"</td>",
                  "<td>",results$estimate[12],"</td>",
                  "<td>"," to ","</td>",
                  "<td>",results$estimate[13],"</td>",
                  "</tr>",
                  "</table>",

                  "<table>",
                  "<tr>",
                  "<td>",paste("Test for ",choice_corr_alt_text_data[3*(as.numeric(corr_tests)-1)+alt_num],": "),"</td>",
                  "<td>",paste("t = ",results$statistic),"</td>",
                  "<td>",paste("p = ",results$p.value,if(results$p.value<1-conf){"*"}),"</td>",
                  "</tr>",
                  "</table>"
           )

           )

       }
       
       
       output
       
       
     })
     
     #First UI element of the EDA data selection, used either for selecting columns or the factor
     output$eda_UI1<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$eda_data_type
       
       if((data_type==1)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "eda_UI1",
                             label = "Select Columns",
                             multiple=T,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       if((data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "eda_UI1",
                                label = "Select Factor(s)",
                                multiple=T,
                                options=list(`actions-box` = TRUE),
                                choices = choices)
       } 
       
       output
       
     })
     
     #Second UI element of the EDA data selection used for selecting the data columns
     output$eda_UI2<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$eda_data_type
       UI1<-input$eda_UI1
       req(UI1)
       
       output<-NULL
       
       if(data_type==1){
         output<-NULL
       } else
         if(data_type==2){
           #take out those already selected
           fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-choices[temp]
           
           output<-pickerInput(inputId = "eda_UI2",
                                  label = "Select Data",
                                  multiple=T,
                               options=list(`actions-box` = TRUE),
                                  choices = choices)
         } 
       
       output
       
     })
     
     eda_data<-reactive({#returns the data selected in the EDA UI
       req(res_filter$filtered())
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#selected  columns or factors
       req(UI1)
       UI2<-input$eda_UI2#selected data if factors
       if(data_type==2){req(UI2)}
       data<-res_filter$filtered()
       
       output<-NULL
       first<-NULL
       second<-NULL
       selected<-NULL
       
       if(data_type==1){
       first<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
       selected<-c(first)
       } else
      if(data_type==2){
        first<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
        second<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
        selected<-c(first,second)
        }
       
       output<-data[,selected]#add names
       as.data.frame(output)
       
     })
     
     output$eda_selected_data<-renderDataTable({
       output<-eda_data()
       req(output)
       
       DT::datatable(output,options=list(lengthMenu=c(5,10,50)))
       
     })
     
     output$eda_desc_out<-renderDT({#this creates the DT summary table for the Normality Tests tab and formats the columns ending in .p if less than alpha
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-input$eda_UI2#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_desc
       data_col<-input$data_list_for_eda#column number of selected dependent in original data
       conf<-input$conf_eda
       auto<-input$auto_norm
       desc_stats<-input$norm_test
       
       req(data)
       
       names(data)<-make.names(names(data))
       
       if(data_type==1){
         if(auto == TRUE){
         output<-summary.all.variables(data = data[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))],stat.sd=T)#error this breaks when one of the selected columns has NA
         }
         if(auto==FALSE){
           #make the text of the stats
           stats_sel<-paste(desc_stats,collapse=",")
           if(grepl("stat.ad.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.ad.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.sw.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.sw.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.skew.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.skew.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.kurt.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.kurt.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           
           stats_sel<-paste(stats_sel,collapse = "")
           norm_dat<-data[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))]
           output<-eval(parse(text=paste("summary.all.variables(data = norm_dat,stat.sd=T,",stats_sel,")")))
         }
       }
       if(data_type==2){
         if(auto==TRUE){
         req(data_col)
         dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
         indep<-colnames(data)[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))]
         indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
         model_text<-formula(paste(dep_name," ~ ",indep_names))
         output<-summary.continuous(fx=model_text, data = data,stat.sd=T)
         }
         if(auto==FALSE){
           req(data_col)
           dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
           indep<-colnames(data)[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))]
           indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
           model_text<-formula(paste(dep_name," ~ ",indep_names))
           
           #make the text of the stats
           stats_sel<-paste(desc_stats,collapse=",")
           if(grepl("stat.ad.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.ad.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.sw.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.sw.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.skew.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.skew.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           if(grepl("stat.kurt.test=2",stats_sel)!=T){
             stats_sel<-c(stats_sel,",stat.kurt.test=0")
             stats_sel<-paste(stats_sel,collapse = "")
           }
           
           stats_sel<-paste(stats_sel,collapse = "")
           
           output<-eval(parse(text=paste("summary.continuous(fx=model_text, data = data,stat.sd=T,",stats_sel,")")))
           
         }
       }
       output<-ro(output,R)
       
       p_col<-colnames(output)[grep(pattern = "(.p)$",x=colnames(output))]
       
       datatable(output,options=list(paging=F)) %>% formatStyle(p_col,backgroundColor = styleInterval (cuts = 1-conf,values = c('yellow','lightgray')))
     })
     output$hist_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       #mult_data_choice<-input$mult_data_choice
       
       if(data_type==1){
         # if(is.null(mult_data_choice)){output<-return(NULL)}
         # select<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
         # names(UI1)<-names(data)[select]
         # if(mult_data_choice==T){
         #   output<-checkboxGroupInput(inputId = "data_list_for_hist",label = "Select data:",choices = UI1)
         #   }
         # if(mult_data_choice==F){
         #   output<-radioButtons(inputId = "data_list_for_hist",label = "Select data:",choices = UI1)
         # }
         output<-NULL
       }
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_hist",label = "Select data:",choices = UI2)
         #output<-NULL
       }
       
       output
     })
     
     output$eda_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
      
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_eda",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     
     output$box_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         #select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         select<-as.numeric(UI2)
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_box",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     ###Allows downloading of boxplots - don't change the order!
     output$box_plot<-renderPlot(box_plot(),width=box_width, height=box_height)
     box_height<-reactive(3*input$box_height)
     box_width<-reactive(3*input$box_width)
     downloadServer("boxplot", box_plot,width = box_width,height = box_height)
     ###
     
     #boxplot with ggplot
     box_plot<-reactive({
       data<-res_filter$filtered()
       type<-input$eda_data_type#column =1  factor =2
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       data_col<-as.numeric(input$data_list_for_box)#column number of selected dependent in original data
       use_notch<-input$notch_box
       title<-input$box_title
       x_lab<-input$box_x_lab
       y_lab<-input$box_y_lab
       big<-input$box_big
       violin<-input$box_violin
       
       req(data)
       req(UI1)
       
       factors<-as.numeric(input$eda_UI1)#if factors selected, column numbers from data
       
       if(type==1){#one or more columns to plot, reform data
         plot_data<-data.frame(transform.dependent.format.to.independent.format(data = data[UI1]))
         names(plot_data)<-c("ID","Data")
         plot_data$Data<-as.numeric(plot_data$Data)
         combo<-"ID"
         dataname<-"Data"
         if(isTruthy(x_lab)){combo<-x_lab}
         if(isTruthy(y_lab)){dataname<-y_lab}
         if(violin){
           comboname<-paste0("Violin Plot of ",dataname," by ",combo)
         } else {
           comboname<-paste0("Boxplot of ",dataname," by ",combo)
         }
         
         if(isTruthy(title)){comboname<-title}
       }
       else{#selected column and one or more factors to plot
         req(UI2,data_col)#,input$indep_list_hist)
         #sel_combos<-data.frame(input$indep_list_hist)
         #names(sel_combos)<-"ID"
         combo<-paste0(names(data)[UI1],collapse = ", ")
         if(isTruthy(x_lab)){combo<-x_lab}
         dataname<-names(data)[data_col]
         if(isTruthy(y_lab)){dataname<-y_lab}
         comboname<-paste0("Boxplot of ",dataname," by ",combo)
         if(isTruthy(title)){comboname<-title}
         plot_data<-data.frame(data[data_col])
         ID<-interaction(data[factors], sep = ", ")
         plot_data<-cbind(ID,plot_data)
         #plot_data<-merge(x = plot_data,y = sel_combos)
         names(plot_data)<-c("ID","Data")
       }
       #at this point plot_data is in long form and only what is needed for plots
       plot_data<-plot_data[which(!is.na(plot_data$Data)),]#remove NA from data
       
       wild_outliers<-plot_data%>%
         group_by(ID) %>%
         filter(Data<quantile(Data,probs=.25)-3*IQR(Data) |
         Data>quantile(Data,probs=.75)+3*IQR(Data))
       
       outliers<-plot_data %>%
         group_by(ID) %>%
         filter(Data<quantile(Data,probs=.25)-1.5*IQR(Data) |
                  Data>quantile(Data,probs=.75)+1.5*IQR(Data)) |>
         anti_join(wild_outliers, by = c("ID", "Data"))
       
       p<-ggplot(data=plot_data,aes(x = ID,y = Data))+
         ggtitle(comboname)+
         scale_x_discrete()+
         geom_point(data=outliers,shape=16,size=2)+
         geom_point(data=wild_outliers,shape="*",size=8,color=color[2])+
         theme(axis.text.x = element_text(angle = 45,hjust=1))+
         labs(x=combo,y=dataname)
       
       if(violin){
         p<-p+
           geom_violin(fill=color[5],alpha=0.5,bw="sj")+
           stat_summary(fun="mean", geom="point", size=4)
       } else {
         p<-p+
           stat_boxplot(geom="errorbar",width=0.5)+ #inner fences
           geom_boxplot(notch=use_notch,fill=color[5],outlier.color=NA)
       }
       
         
       
       if(big){
         p<-p+
           theme(axis.title = element_text(size=rel(1.5)),
                 axis.text = element_text(size=rel(1.5)),
                 plot.title = element_text(size=rel(1.5))
                 )
       }
       p#final output
       
     })
     
     ######reference data UI for proportion tests
     
     output$data_choice_ref_bi <- renderUI({ #Column with reference
       req(res_filter$filtered())
       data<- res_filter$filtered()
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       output<-selectInput(inputId = "data_choice_ref_bi",
                           label = "Select Factor",
                           multiple=F,
                           choices = choices)
       output
     })
     
     output$data_choice_data_bi <- renderUI({ #Column with data
       req(res_filter$filtered())
       data<- res_filter$filtered()
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       factor<-input$data_choice_ref_bi
       req(factor,choices)
       
       #take out the one already selected
       fact_selected<-as.numeric(unlist(strsplit (x = factor,split = "\\s+")))
       temp<-seq(1:length(choices))
       temp<-temp[-fact_selected]
       choices<-choices[temp]
       
       output<-selectInput(inputId = "data_choice_data_bi",
                           label = "Select Data",
                           multiple=F,
                           choices = choices)
       output
       
     })
     
     output$data_choice_g1_bi <- renderUI({ #the number identifying group 1#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref_bi
       
       
       factor<-unique(data[as.numeric(ref)])
       
       output<-selectInput(inputId = "data_choice_g1_bi",label = "Group 1",choices = factor)
       
       output
       
     })
     
     output$data_choice_g2_bi <- renderUI({ #the number identifying group 2#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref_bi
       factor_g1<-input$data_choice_g1_bi
       
       factor<-unique(data[as.numeric(ref)])
       
       #take out the one already selected
       #fact_selected<-as.numeric(factor_g1)
       temp<-factor[-which(x = factor==factor_g1),]
       
       #choices<-choices[temp]
       
       
       output<-selectInput(inputId = "data_choice_g2_bi",label = "Group 2",choices = temp)
       
       output
     })
     #####
     
     #####proportion dynamic UI
     output$alt_bi_data<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       req(data_type)
       
       if(data_type==1){
         data_columns<-input$bi_data_selected_columns
         if(!isTruthy(data_columns)){return("Select at least one data column")}
         samples<-length(data_columns)
       } else{
           factor_col<-input$data_choice_ref_bi
           if(!isTruthy(factor_col)){return("Select factor column")}
           samples<-2
         }
       
         if(samples>2){return("Select at most two columns")}
         if(samples==1){
           selectInput(inputId = "alt_p_bi",
                     label = "Alternative hypothesis for proportions",
                     choices = choice_prop_alt_1
         )
         } else if(samples==2) {
           selectInput(inputId = "alt_p_bi",
                       label = "Alternative hypothesis for proportions",
                       choices = choice_prop_alt_2
           )
         }
     })
     
     output$data_bi_success1<-renderUI({#dropdown to select "success" for binomial test - group 1
       data<- res_filter$filtered()
       data_type<-input$data_type_bi#columns=1 ref=2
       req(data,data_type)
       
       if(data_type==1){#columns
         data_columns<-as.numeric(input$bi_data_selected_columns)
         if(length(data_columns)>2 || !isTruthy(data_columns)){return()}
         options<-na.omit(unique(data[data_columns[1]]))
         if(nrow(options)==1){
           options<-rbind(options,paste0("Not ",options))
         }
         col_name<-names(data)[data_columns[1]]
       } else{#reference
         #factor_col<-as.numeric(input$data_choice_ref_bi)
         data_col<-as.numeric(input$data_choice_data_bi)
         options<-na.omit(unique(data[data_col]))
         if(nrow(options)==1){
           options<-rbind(options,paste0("Not ",options))
         }
         col_name<-names(data[data_col])
       }
       selectInput(inputId = "bi_data_success1",label = paste0("What Indicates 'Success' in ",col_name,"?"),choices = options,multiple = FALSE)
     })
     
     output$data_bi_success2<-renderUI({#dropdown to select "success" for binomial test - group 1
       data<- res_filter$filtered()
       data_type<-input$data_type_bi#columns=1 ref=2
       req(data,data_type)
       
       if(data_type==1){#columns
         data_columns<-as.numeric(input$bi_data_selected_columns)
         if(length(data_columns)>2 || !isTruthy(data_columns) || length(data_columns)==1){return()}
         options<-na.omit(unique(data[data_columns[2]]))
         if(nrow(options)==1){
           options<-rbind(options,paste0("Not ",options))
         }
         col_name<-names(data)[data_columns[2]]
       } else{#reference
         return()
       }
       selectInput(inputId = "bi_data_success2",label = paste0("What Indicates 'Success' in ",col_name,"?"),choices = options,multiple = FALSE)
     })
     
     output$bi_test_data_ui1<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       data<- res_filter$filtered()
       success1<-input$bi_data_success1
       R<-input$decimal_bi_d
       
       req(data,data_type,success1,R)
       
       if (data_type==1){
         sel_col<-as.numeric(input$bi_data_selected_columns)
         samples<-length(sel_col)
         if(samples>2 || !isTruthy(sel_col)) {return()}
         bi_data<-data[sel_col]
         count<-length(na.omit(bi_data[1][bi_data[1]==success1]))
         n<-nrow(na.omit(bi_data[1]))
         if(samples==2){output<-HTML(paste0(withMathJax("$np_1=$"),count))}
         else {output<-HTML(paste0(withMathJax("$np=$"),count))}
         
       } else{#end columns, start ref
         ref_col<-as.numeric(input$data_choice_ref_bi)
         data_col<-as.numeric(input$data_choice_data_bi)
         g1_id<-input$data_choice_g1_bi
         req(data_col,ref_col,g1_id)
         bi_data<-data.frame(group=data[ref_col][data[ref_col]==g1_id],count=data[data_col][data[ref_col]==g1_id])
         names(bi_data)<-c("Group","Count")
         #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
         #names(bi_data)<-c("g1","g2")
         count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
         n<-length(na.omit(bi_data$Count))
         output<-HTML(paste0(withMathJax("$np_1=$"),count))
       }
       output
     })#end UI1
     
     output$bi_test_data_ui3<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       data<- res_filter$filtered()
       success1<-input$bi_data_success1
       R<-input$decimal_bi_d
       
       req(data,data_type,success1,R)
       
       if (data_type==1){
         sel_col<-as.numeric(input$bi_data_selected_columns)
         samples<-length(sel_col)
         if(samples>2 || !isTruthy(sel_col)) {return()}
         bi_data<-data[sel_col]
         #count<-length(na.omit(bi_data[1][bi_data[1]==success1]))
         n<-nrow(na.omit(bi_data[1]))
         if(samples==2){output<-HTML(paste0(withMathJax("$n_1=$"),n))}
         else {output<-HTML(paste0(withMathJax("$n=$"),n))}
         
       } else{#end columns, start ref
         ref_col<-as.numeric(input$data_choice_ref_bi)
         data_col<-as.numeric(input$data_choice_data_bi)
         g1_id<-input$data_choice_g1_bi
         req(data_col,ref_col,g1_id)
         bi_data<-data.frame(group=data[ref_col][data[ref_col]==g1_id],count=data[data_col][data[ref_col]==g1_id])
         names(bi_data)<-c("Group","Count")
         #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
         #names(bi_data)<-c("g1","g2")
         #count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
         n<-length(na.omit(bi_data$Count))
         output<-HTML(paste0(withMathJax("$n_1=$"),n))
       }
       output
     })#end UI3
     
     output$bi_test_data_ui2<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       data<- res_filter$filtered()
       success2<-input$bi_data_success2
       success1<-input$bi_data_success1
       R<-input$decimal_bi_d
       
       req(data,data_type,R)
       
       if (data_type==1){
         sel_col<-as.numeric(input$bi_data_selected_columns)
         samples<-length(sel_col)
         if(samples>2 || !isTruthy(sel_col)) {return()}
         if(samples==1){return(tags$div(id="inline1", class="inline",numericInput(inputId = "bi_test_data_ui2",label = "$\\pi_{0}=$",value = .5,min = 0,max = 1,width = "75px")))}
         req(success2)
         bi_data<-data[sel_col]
         count<-length(na.omit(bi_data[2][bi_data[2]==success2]))
         n<-nrow(na.omit(bi_data[2]))
         if(samples==2){output<-HTML(paste0(withMathJax("$np_2=$"),count))}
         #else {output<-HTML(paste0(withMathJax("$p=$"),ro(count/n,R)))}
         
       } else{#end columns, start ref
         ref_col<-as.numeric(input$data_choice_ref_bi)
         data_col<-as.numeric(input$data_choice_data_bi)
         g2_id<-input$data_choice_g2_bi
         req(data_col,ref_col,g2_id,success1)
         bi_data<-data.frame(group=data[ref_col][data[ref_col]==g2_id],count=data[data_col][data[ref_col]==g2_id])
         names(bi_data)<-c("Group","Count")
         #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
         #names(bi_data)<-c("g1","g2")
         count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
         n<-length(na.omit(bi_data$Count))
         output<-HTML(paste0(withMathJax("$np_2=$"),count))
       }
       output
     })#end UI2
     
     output$bi_test_data_ui4<-renderUI({
       data_type<-input$data_type_bi#columns=1 ref=2
       data<- res_filter$filtered()
       success2<-input$bi_data_success2
       success1<-input$bi_data_success1
       R<-input$decimal_bi_d
       
       req(data,data_type,R)
       
       if (data_type==1){
         sel_col<-as.numeric(input$bi_data_selected_columns)
         samples<-length(sel_col)
         if(samples>2 || !isTruthy(sel_col)) {return()}
         if(samples==1){return()}
         req(success2)
         bi_data<-data[sel_col]
         #count<-length(na.omit(bi_data[2][bi_data[2]==success2]))
         n<-nrow(na.omit(bi_data[2]))
         if(samples==2){output<-HTML(paste0(withMathJax("$n_2=$"),n))}
         #else {output<-HTML(paste0(withMathJax("$p=$"),ro(count/n,R)))}
         
       } else{#end columns, start ref
         ref_col<-as.numeric(input$data_choice_ref_bi)
         data_col<-as.numeric(input$data_choice_data_bi)
         g2_id<-input$data_choice_g2_bi
         req(data_col,ref_col,g2_id,success1)
         bi_data<-data.frame(group=data[ref_col][data[ref_col]==g2_id],count=data[data_col][data[ref_col]==g2_id])
         names(bi_data)<-c("Group","Count")
         #bi_data<-transform.independent.format.to.dependent.format(fx = Count~Group,data = bi_data)
         #names(bi_data)<-c("g1","g2")
         #count<-length(na.omit(bi_data$Count[bi_data$Count==success1]))
         n<-length(na.omit(bi_data$Count))
         output<-HTML(paste0(withMathJax("$n_2=$"),n))
       }
       output
     })#end UI4
     

     
     #####
     
 
     ######reference data UI for mean and dispersion
     
     output$md_data_test_selection <- renderUI({#shows the choice about knowing sigma for determining if the t-type choice is to be shown
       data<- res_filter$filtered()
       type<-input$data_type_md
       req(data,type)
       
       ref_col<-input$data_choice_ref
       data_col<-input$data_choice_data
       dep_col<-input$md_data_selected_columns
       dep_or_indep<-input$dep_or_indep_data
       
       if(type==1){#column
         #two sample dependent no UI
         if(length(dep_col)==1){
           return(radioButtons(inputId = "sigma_known_data",
                                label = "Is \U03C3 definitively known?",
                                choices = c("No, use t"=1,"Yes, use z"=2)))
         } else{
           req(dep_or_indep)
           if(dep_or_indep==2){
             return()
           }
           }
         return(radioButtons(inputId = "sigma_known_data",
                                label = "Is \U03C3 definitively known?",
                                choices = c("No, use t"=1,"Yes, use z"=2)))
         
       } else{#reference
         req(dep_or_indep)
         if(dep_or_indep==2){
           return()
         }else{
           return(radioButtons(inputId = "sigma_known_data",
                                label = "Is \U03C3 definitively known?",
                                choices = c("No, use t"=1,"Yes, use z"=2)))
         }
       }
       #output
     })
     
     output$data_choice_ref <- renderUI({ #Column with reference
       req(res_filter$filtered())
       data<- res_filter$filtered()
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       output<-selectInput(inputId = "data_choice_ref",
                           label = "Select Factor",
                           multiple=F,
                           choices = choices)
       output
     })
     
     output$data_choice_data <- renderUI({ #Column with data
       req(res_filter$filtered())
       data<- res_filter$filtered()
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       factor<-input$data_choice_ref
       req(factor,choices)
       
       #take out the one already selected
       fact_selected<-as.numeric(unlist(strsplit (x = factor,split = "\\s+")))
       temp<-seq(1:length(choices))
       temp<-temp[-fact_selected]
       choices<-choices[temp]
       
       output<-selectInput(inputId = "data_choice_data",
                              label = "Select Data",
                              multiple=F,
                              choices = choices)
       output
     
     })
     
     output$data_choice_g1 <- renderUI({ #the number identifying group 1#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref
       
       
       factor<-unique(data[as.numeric(ref)])
       
       output<-selectInput(inputId = "data_choice_g1",label = "Group 1",choices = factor)
       
       output
       
     })
     
     output$data_choice_g2 <- renderUI({ #the number identifying group 2#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref
       factor_g1<-input$data_choice_g1
       
       factor<-unique(data[as.numeric(ref)])
       
       #take out the one already selected
       #fact_selected<-as.numeric(factor_g1)
       temp<-factor[-which(x = factor==factor_g1),]
       
       #choices<-choices[temp]
       
       
       output<-selectInput(inputId = "data_choice_g2",label = "Group 2",choices = temp)
       
       output
     })
     #####
     
     ######reference data UI for nonparametric
     
     output$data_choice_ref_np <- renderUI({ #Column with reference
       req(res_filter$filtered())
       data<- res_filter$filtered()
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       output<-selectInput(inputId = "data_choice_ref_np",
                           label = "Select Factor",
                           multiple=F,
                           choices = choices)
       output
     })
     
     output$data_choice_data_np <- renderUI({ #Column with data
       data<- res_filter$filtered()
       req(data)
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       factor<-input$data_choice_ref_np
       req(factor)
       
       #take out the one already selected
       fact_selected<-as.numeric(unlist(strsplit (x = factor,split = "\\s+")))
       temp<-seq(1:length(choices))
       temp<-temp[-fact_selected]
       choices<-choices[temp]
       
       output<-selectInput(inputId = "data_choice_data_np",
                           label = "Select Data",
                           multiple=F,
                           choices = choices)
       output
       
     })
     
     output$data_choice_g1_np <- renderUI({ #the number identifying group 1#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref_np
       
       
       factor<-unique(data[as.numeric(ref)])
       
       output<-selectInput(inputId = "data_choice_g1_np",label = "Group 1",choices = factor)
       
       output
       
     })
     
     output$data_choice_g2_np <- renderUI({ #the number identifying group 2#get unique numbers from choice_ref
       req(res_filter$filtered())
       data<- res_filter$filtered()
       ref<-input$data_choice_ref_np
       factor_g1<-input$data_choice_g1_np
       
       factor<-unique(data[as.numeric(ref)])
       
       #take out the one already selected
       #fact_selected<-as.numeric(factor_g1)
       temp<-factor[-which(x = factor==factor_g1),]
       
       #choices<-choices[temp]
       
       
       output<-selectInput(inputId = "data_choice_g2_np",label = "Group 2",choices = temp)
       
       output
     })
     
     output$np_mc_pass<-renderUI({
       test<-input$np_tests_data
       req(test)
       if(test!=7){return()}
       columns<-as.numeric(input$np_data_selected_columns)
       data<- res_filter$filtered()
       req(columns,data,test)
       
       if (length(columns)>2 || !isTruthy(columns)){return("Select one or two columns")}
       
       cats<-unique(c(na.omit(unique(data[[columns[1]]])),na.omit(unique(data[[columns[2]]]))))
       num_cat<-length(cats)
       
       if(num_cat>2){return("Needs binomial data")}
       
       return(selectInput(inputId = "np_mc_pass",label = "Pass Indicated by",choices = cats))
       
     })
     
     output$sel_data_name <- renderUI({
       data<- res_filter$filtered()
       data_col<-input$data_list_for_eda
       

       output<-names(data[as.numeric(data_col)])
       h3(output)
     })
     
     #Create the descriptives table
     descriptives <- reactive({
       data<- res_filter$filtered()
       req(data)
       type<-input$eda_data_type#column =1  factor =2
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       data_col<-as.numeric(input$data_list_for_eda)#column number of selected dependent in original data
       
       if (type==1){
         
       }
       if(type==2){
         
       }
       output
     })
     
     ###Allows downloading of histograms - don't change the order!
     output$histo_plot<-renderPlot(histo_plot(),width = hist_width,height = hist_height)
     
     hist_height<-reactive(3*input$hist_height)
     hist_width<-reactive(3*input$hist_width)
     
     downloadServer("histoplot", histo_plot, width=hist_width,height = hist_height)#, height = 3*hist_height())
     ###
     
     ###Selector for frequency diagram
     
     output$hist_panel_select<-renderUI({
       type<-input$eda_data_type#column =1  factor =2
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       data<-res_filter$filtered()
       req(UI1,type,data)
       
       if(type==1){#one or more columns to plot
         panel_list<-seq(1,length(UI1))
         names(panel_list)<-names(data)[UI1]
         }
       
       else{#selected column and one or more factors to plot
         data_col<-as.numeric(input$data_list_for_hist)
         x_lab<-input$hist_x_lab
         factors<-as.numeric(input$eda_UI1)#if factors selected, column numbers from data
         req(data_col,input$indep_list_hist)
         sel_combos<-data.frame(input$indep_list_hist)
         names(sel_combos)<-"ID"
         comboname<-paste0(names(data)[UI1],collapse = ", ")
         dataname<-names(data)[data_col]
         if(isTruthy(x_lab)){dataname<-x_lab}
         comboname<-paste0(dataname," by ",comboname)
         #plot_data<-data.frame(data[data_col])
         ID<-interaction(data[factors], sep = ", ")
         #plot_data<-cbind(ID,plot_data)
         #plot_data<-merge(x = plot_data,y = sel_combos)
         #names(plot_data)<-c("ID","Data")
         panel_list<-seq(1,nrow(sel_combos))
         names(panel_list)<-input$indep_list_hist
       }
       
       output<-selectInput(inputId = "hist_panel_filter",label = "Select Panel to View",choices = panel_list)
         
         
       
     })
     
     ###
     
     #plot histograms
     histo_plot<-reactive({#with ggplot
       data<-res_filter$filtered()
       type<-input$eda_data_type#column =1  factor =2
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       req(type,data,UI1)
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       data_col<-as.numeric(input$data_list_for_hist)#column number of selected dependent in original data change to radio button for histogram
       if(type==2){req(data_col)}
       #hist_axis<-input$hist_axis#common axis flag
       hist_type<-input$hist_type#"Histogram"=1,"Frequency Polygon"=2,"Density"=3
       norm_curve<-input$norm_curve#draw normal curve flag
       hist_specs<-input$hist_specs#draw hist specifications?
       hist_USL<-input$hist_USL
       hist_target<-input$hist_target
       hist_LSL<-input$hist_LSL
       mult_data<-input$mult_data_choice#if multiple columns of data, put them on one axis?
       bins<-input$hist_bins
       if(is.na(bins)){bins<-15}
       if(is.null(mult_data)){mult_data<-TRUE}
       extend<-input$hist_extend_d
       width<-input$hist_width
       height<-input$hist_height
       center<-input$hist_center
       if(!is.numeric(center)){center<-NULL}
       title<-input$hist_title
       x_lab<-input$hist_x_lab
       #y_lab<-input$hist_y_lab
       big<-input$hist_big
       bin_w<-input$hist_bin_w
       if(!isTruthy(bin_w)){bin_w<-NULL}
       
      factors<-as.numeric(input$eda_UI1)#if factors selected, column numbers from data
       
       if(type==1){#one or more columns to plot, reform data
         plot_data<-data.frame(transform.dependent.format.to.independent.format(data = data[UI1]))
         names(plot_data)<-c("ID","Data")
         plot_data$Data<-as.numeric(plot_data$Data)
         comboname<-"Histogram"
         dataname<-"Data"
       }
       
       else{#selected column and one or more factors to plot
         req(data_col,input$indep_list_hist)
         sel_combos<-data.frame(input$indep_list_hist)
         names(sel_combos)<-"ID"
         comboname<-paste0(names(data)[UI1],collapse = ", ")
         dataname<-names(data)[data_col]
         if(isTruthy(x_lab)){dataname<-x_lab}
         comboname<-paste0(dataname," by ",comboname)
         plot_data<-data.frame(data[data_col])
         ID<-interaction(data[factors], sep = ", ")
         plot_data<-cbind(ID,plot_data)
         plot_data<-merge(x = plot_data,y = sel_combos)
         names(plot_data)<-c("ID","Data")
       }
       
       #at this point plot_data is in long form and only what is needed for plots
       plot_data<-plot_data[which(!is.na(plot_data$Data)),]#remove NA from data
       
       if(isTruthy(title)){comboname<-title}
       
       if(isTruthy(x_lab)){dataname<-x_lab}
       
       leg_names<-c("Data"=color[5])

       p<-ggplot(plot_data,aes(x=Data))+
         scale_fill_manual(values=leg_names)
       
       if(hist_type==1){
         if(norm_curve){
           p<-p+
             geom_histogram(aes(fill="Data",y=after_stat(density)),binwidth=bin_w,bins = bins,center=center,color=color[1])
         }
         else{
           p<-p+
             geom_histogram(aes(fill="Data"),binwidth=bin_w,bins = bins,center=center,color=color[1])+
             labs(y="Count")
         }
         }
       else if(hist_type==2){
         if(norm_curve){
           p<-p+
             geom_freqpoly(aes(color="Data",y=after_stat(density)),binwidth=bin_w,bins = bins,center=center,color=color[5])+
             labs(y="Count")
           }
         else{
           p<-p+
             geom_freqpoly(aes(color="Data"),binwidth=bin_w,bins = bins,center=center)+
             labs(y="Count")
           }
       }
       else if(hist_type==3){
         rug<-input$hist_rug
         if(extend){
           #generate base R density
           dense_dat<-by(data = plot_data$Data,INDICES = plot_data$ID,FUN = density,bw="sj")
           #rip apart list and format for ggplot
           newplot_dat<-data.frame("ID"=NA,"x"=NA,"y"=NA)
           for(name in names(dense_dat)){
             temp<-merge(name,dense_dat[[name]][["x"]])
             names(temp)<-c("ID","x")
             temp<-cbind(temp,y=dense_dat[[name]][["y"]])
             newplot_dat<-rbind(newplot_dat,temp)
           }
           
           newplot_dat<-na.omit(newplot_dat)
           
           p<-p+
             geom_area(data=newplot_dat,aes(x=x,y=y,fill="Data"),color=color[1])+
             labs(y="Density")
           if(rug){
             p<-p+
               geom_rug(color=color[6],alpha=0.5)
           }
         }
         else{
         p<-p+
           geom_density(aes(fill="Data"),outline.type = "full",bw="sj",trim=F)+
           labs(y="Density")
         if(rug){
           p<-p+
             geom_rug(color=color[6],alpha=0.35)
         }
         }
       }
         
       if(norm_curve){
         leg_names<-c("Normal"=color[4])
         p <- p+
           scale_color_manual(values=leg_names)+
           stat_theodensity(aes(color="Normal"),distri = "norm",size=1)+
           labs(y="Density")
       }
       
       if(hist_specs){
         if(!is.na(hist_USL)){
           p<-p+
           geom_vline(xintercept = hist_USL,color=color[2],linetype=2)
         }
         if(!is.na(hist_LSL)){
           p<-p+
             geom_vline(xintercept = hist_LSL,color=color[2],linetype=2)
         }
         if(!is.na(hist_target)){
           p<-p+
             geom_vline(xintercept = hist_target,color=color[3])
         }
           
       }
       
       #same axis or no
       if(mult_data){
         p<-p+
           facet_wrap(facets=vars(ID))
       } else{
         p<-p+
           facet_wrap(facets=vars(ID),scales = "free")
       }
       
       #add n, title, and remove default label for legend
       temp_n<-count(plot_data,ID)
       p<-p+
         ggtitle(comboname)+
         geom_label(data = temp_n,aes(x=-Inf,y=Inf,label=paste0("n = ",n)),hjust=0,vjust="top")+
         theme(axis.text.x = element_text(angle=45))+
         labs(color="",fill="")+
         xlab(dataname)
       
       if(big){
         p<-p+
           theme(axis.title = element_text(size=rel(1.5)),
                 axis.text = element_text(size=rel(1.5)),
                 plot.title = element_text(size=rel(1.5))
           )
       }
       
       p#final output
       
     })
     
     output$freq_dist<-renderDT({
       data<-res_filter$filtered()
       type<-input$eda_data_type#column =1  factor =2
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       req(type,data,UI1)
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       data_col<-as.numeric(input$data_list_for_hist)#column number of selected dependent in original data change to radio button for histogram
       if(type==2){req(data_col)}
       hist_type<-input$hist_type#"Histogram"=1,"Frequency Polygon"=2,"Density"=3
       if(hist_type==3){return()}
       mult_data<-input$mult_data_choice#if multiple columns of data, put them on one axis?
       bins<-input$hist_bins
       if(is.na(bins)){bins<-15}
       if(is.null(mult_data)){mult_data<-TRUE}
       center<-input$hist_center
       if(!is.numeric(center)){center<-NULL}
       R<-input$freq_dist_dec
       bin_w<-input$hist_bin_w
       if(!isTruthy(bin_w)){bin_w<-NULL}
       filter<-input$hist_panel_filter

       factors<-as.numeric(input$eda_UI1)#if factors selected, column numbers from data
       
       if(type==1){#one or more columns to plot, reform data
         plot_data<-data.frame(transform.dependent.format.to.independent.format(data = data[UI1]))
         names(plot_data)<-c("ID","Data")
         plot_data$Data<-as.numeric(plot_data$Data)
       }
       
       else{#selected column and one or more factors to plot
         req(data_col,input$indep_list_hist)
         sel_combos<-data.frame(input$indep_list_hist)
         names(sel_combos)<-"ID"
         dataname<-names(data)[data_col]
         plot_data<-data.frame(data[data_col])
         ID<-interaction(data[factors], sep = ", ")
         plot_data<-cbind(ID,plot_data)
         plot_data<-merge(x = plot_data,y = sel_combos)
         names(plot_data)<-c("ID","Data")
       }
       
       #at this point plot_data is in long form and only what is needed for plots
       plot_data<-plot_data[which(!is.na(plot_data$Data)),]#remove NA from data
       
       leg_names<-c("Data"=color[5])
       
       p<-ggplot(plot_data,aes(x=Data))+
         scale_fill_manual(values=leg_names)
       
       if(hist_type==1){
           p<-p+
             geom_histogram(aes(fill="Data"),binwidth=bin_w,bins = bins,center=center,color=color[1])+
             labs(y="Count")
         
       }
       else if(hist_type==2){
         
           p<-p+
             geom_freqpoly(aes(color="Data"),binwidth=bin_w,bins = bins,center=center)+
             labs(y="Count")
        
       }
       
       #same axis or no
       if(mult_data){
         p<-p+
           facet_wrap(facets=vars(ID))
       } else{
         p<-p+
           facet_wrap(facets=vars(ID),scales = "free")
       }
       
       graph_info<-ggplot_build(p)
       
       table<-data.frame(graph_info[["data"]][[1]][["PANEL"]],graph_info[["data"]][[1]][["xmin"]],graph_info[["data"]][[1]][["x"]],graph_info[["data"]][[1]][["xmax"]],graph_info[["data"]][[1]][["y"]])
       
       names(table)<-c("Panel","xmin","Center","xmax","Count")
       
       temp<-table %>% group_by(Panel) %>% reframe("Rf" = Count/sum(Count))
       
       table<-ro(cbind(table,temp[2]),R)
       
       
         req(filter)
         table<-table[table$Panel==filter,]
       
       
       output<-DT::datatable(table,options=list(lengthMenu=list(c(100,-1),c(100,"All"))))
       
     })
     
     output$mult_data <-renderUI({
       #if column data and only one column, NULL if two column "How do you want to display the data? if on same chart, hist_data_list checkboxes otherwise radio
       type<-input$eda_data_type
       UI1<-input$eda_UI1
       
       req(UI1)
       
       if(type==1){
         if(length(UI1)==1){output<-NULL}
         else{
           output<-checkboxInput(inputId = "mult_data_choice",label = "Display on same axis?",value = T)
         }
       }
       
       if(type==2){
         UI2<-input$indep_list_hist
         req(UI2)
         if(length(UI2)==1){
         output<-NULL
         } else {output<-checkboxInput(inputId = "mult_data_choice",label = "Display on same axis?",value = T)}
       }
       
       output
     })
     
     output$swatch<-renderPlot({#choose a palette
       pal<-input$color_pal
       
       pal_col<<-pal
       
       #plot a demo
       
       fake_data<-data.frame(x1=rnorm(50),x2=rnorm(50),x3=rnorm(50),x4=rnorm(50),x5=rnorm(50),x6=rnorm(50),x7=rnorm(50),x8=rnorm(50))
       boxplot(x = fake_data,col=palette.colors(n = 8,palette = pal_col))
       
       color<<-unname(palette.colors(n = 8,palette = pal_col))
       col_mean_line<<-color[3]
       col_plot_line<<-color[1]
       col_point_of_interest_line<<-color[6]
       col_fill_highlight<<-color[2]
       col_fill<<-color[5]
       col_line_control_chart<<-color[4]
       
       
     })
     
     output$hist_indep_list<-renderUI({#render the UI for choosing the combination of independent factors for histograms
       type<-input$eda_data_type
       UI1<-as.numeric(input$eda_UI1)
       data<-res_filter$filtered()
       
       indep<-colnames(data)[as.numeric(unlist(strsplit (x = as.character(UI1),split = "\\s+")))]
       #indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
       
       factor_combos<-unique(data[,UI1])#unique combinations of all selected factors
       num_factors<-length(UI1)
       if(num_factors==1){num_combos=length(factor_combos)}
       else{num_combos<-length(factor_combos[,1])}
       seq_combos<-seq(1,num_combos)
       
       choices<-NULL
       
       if(num_factors == 1){
         choices<-factor_combos
       }
       else{
         for(val in seq_combos){
           choices<-c(choices,paste(factor_combos[val,],collapse=", "))
         }
       }
       
       if(type==1){output<-NULL}
       
       if(type==2){
         output<-pickerInput(inputId = "indep_list_hist",label = "Select Factor Combination to Display",choices = choices,multiple = TRUE,options=list(`actions-box` = TRUE),selected =choices )
       }
       output
     }
     )
     
     #Create table output for descriptive stats in EDA
     output$desc_out<-renderDT({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-input$eda_UI2#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_desc2
       data_col<-input$data_list_for_desc#column number of selected dependent in original data
       desc_stats<-input$desc_stats#a long text list of parameters for summary()
       
       req(res_filter$filtered())
       #validate(need(!is.null(desc_stats)),"Select at least one statistic")
       names(data)<-make.names(names(data))
       
       #make the text of the stats
       stats_sel<-paste(desc_stats,collapse=",")
       if(grepl("stat.mean=T",stats_sel)!=T){
         stats_sel<-c(stats_sel,",stat.mean=F")
         stats_sel<-paste(stats_sel,collapse = "")
         }
       if(grepl("stat.var=T",stats_sel)!=T){
         stats_sel<-c(stats_sel,",stat.var=F")
         stats_sel<-paste(stats_sel,collapse = "")
         }
       if(grepl("stat.miss=T",stats_sel)!=T){
         stats_sel<-c(stats_sel,",stat.miss=F")
         stats_sel<-paste(stats_sel,collapse = "")
       }
       if(grepl("stat.skew.test=T",stats_sel)!=T){
         stats_sel<-c(stats_sel,",stat.skew.test=0")
         stats_sel<-paste(stats_sel,collapse = "")
       }
       if(grepl("stat.kurt.test=T",stats_sel)!=T){
         stats_sel<-c(stats_sel,",stat.kurt.test=0")
         stats_sel<-paste(stats_sel,collapse = "")
       }
       
       
       stats_sel<-c(stats_sel,",stat.ad.test   = 0,stat.sw.test   = 0,stat.dago.test = 0")
       stats_sel<-paste(stats_sel,collapse = "")
       
       if(data_type==1){
         desc_dat<-data[as.numeric(unlist(strsplit (x = UI1,split = '\\s+')))]
         output<-eval(parse(text=paste("summary.all.variables(data = desc_dat,",stats_sel,")")))#error this breaks when one of the selected columns has NA
       }
       if(data_type==2){
         req(data_col)
         dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
         indep<-colnames(data)[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))]
         indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
         model_text<-formula(paste(dep_name," ~ ",indep_names))
         
         output<-eval(parse(text=paste("summary.continuous(fx=model_text, data = data,",stats_sel,")")))
         
       }
       output<-ro(output,R)
       
       #output
       p_col<-colnames(output)[grep(pattern = "(.p)$",x=colnames(output))]
       
       datatable(output,options=list(paging=F)) %>% formatStyle(p_col,backgroundColor = styleInterval (cuts = 0.05,values = c('yellow','lightgray')))
       

     })
     
     
     output$desc_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_desc",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     output$quant_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_quant",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     output$quant_out<-renderDT({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-input$eda_UI2#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_quant
       data_col<-input$data_list_for_quant#column number of selected dependent in original data
       quant<-as.numeric(input$quant_sel)
       custom<-as.numeric(input$quant_cust)
       
       req(res_filter$filtered())
       names(data)<-make.names(names(data))

       if(quant==1){quant=custom}
       quantiles<-c(seq(from=0,to=1,by=(1/quant)))
       
       
       if(data_type==1){
         quant_dat<-data[as.numeric(unlist(strsplit (x = UI1,split = '\\s+')))]
         output<-summary.all.variables(data = quant_dat,stat.mean=F,stat.var=F,stat.ad.test   = 0,stat.sw.test   = 0,stat.skew.test = 0,stat.kurt.test = 0,stat.dago.test = 0,stat.quantiles=quantiles)
           #eval(parse(text=paste("summary.all.variables(data = desc_dat,",stats_sel,")")))#error this breaks when one of the selected columns has NA
       }
       if(data_type==2){
         req(data_col)
         dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
         indep<-colnames(data)[as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))]
         indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
         model_text<-formula(paste(dep_name," ~ ",indep_names))
         
         output<-summary.continuous(fx=model_text, data = data,stat.mean=F,stat.var=F,stat.ad.test   = 0,stat.sw.test   = 0,stat.skew.test = 0,stat.kurt.test = 0,stat.dago.test = 0,stat.quantiles=quantiles)
         
       }
       output<-t(ro(output,R))
       
       output
       
       
     })
     
     output$scat_y<-renderUI({
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       
       pickerInput(inputId = "scat_y_sel",label = "Select y",choices = choices,options = list(title="Select y"))
     })
     
     output$scat_x<-renderUI({
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       
       pickerInput(inputId = "scat_x_sel",label = "Select x",choices = choices,options = list(title="Select x"))
     })
     
     
     
     output$hover_info_scat <- renderUI({
       req(input$scat_x_sel)
       req(input$scat_y_sel)
       R<-input$decimal_scat
       hover <- input$scat_hover
       if(is.null(hover)){return()}
       data<-scat_dat()
       
       point<-nearPoints(df = data,coordinfo = hover,xvar = names(data)[which(names(data)==names(res_filter$filtered())[as.numeric(input$scat_x_sel)])],yvar = names(data)[which(names(data)==names(res_filter$filtered())[as.numeric(input$scat_y_sel)])])
       
       #point <- nearPoints(scat_dat(), hover, threshold = 5, maxpoints = 1, addDist = TRUE)
       if (nrow(point) == 0) return(NULL)
       
       
       # calculate distance from left and bottom side of the picture in pixels
       left_px <- hover$coords_css$x
       top_px <- hover$coords_css$y
       
       
       # create style property for tooltip
       # background color is set so tooltip is a bit transparent
       # z-index is set so we are sure are tooltip will be on top
       style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
                       "left:", left_px + 2, "px; top:", top_px + 2, "px;")
       
       # actual tooltip created as wellPanel
       wellPanel(
         style = style,
         p(HTML(paste0(
           "<span style='display:block; text-transform:capitalize; text-align:center'>",point$facet,"</span>",
           "<b> ",names(point)[1],": </b>", ro(point[1],R), "<br/>",
           "<b> ",names(point)[2],": </b>", ro(point[2],R), "<br/>"
         )))
       )
     })
     
     output$scatterplot<-renderPlot({scatter_plot()})
     scat_width<-reactive(400*4)
     scat_height<-reactive(400*4)
     downloadServer('scatterplot', scatter_plot,height = scat_height,width = scat_width)
     
    scatter_plot<-reactive({
      #req(input$scat_y_sel,input$scat_x_sel)
       y<-as.numeric(input$scat_y_sel)
       x<-as.numeric(input$scat_x_sel)
       # y<-data[,y]
       # x<-data[,x]
       curve_fit<-input$curve_fit
       data<- res_filter$filtered()
       conf=input$conf_scatter
       ci<-input$scat_ci
       p_ci<-input$point_ci
       y_x<-input$y_x_line
       R<-input$decimal_scat
       font_size<-as.numeric(input$scat_font_size)
       
       validate(need(!is.na(x) && !is.na(y),"Need to enter x and y data vectors"))
       
       names(data)<-make.names(names(data))
       
       x_dat=data[[x]]
       y_dat=data[[y]]
       scat_dat<<-reactive(as.data.frame(cbind(data[x],data[y])))
       #names(scat_dat)<-c(names(data)[x],names(data)[y])
       a=1
       b=1
       steps<-50#number of data points to use for prediction data
       
       p<-ggplot(data,aes(x=.data[[names(data)[x]]],y=.data[[names(data)[y]]]))+
         geom_point(data=data,color=col_line_control_chart,size=3)#base plot
       
       if(curve_fit==0 || curve_fit == ""){
         output<-p
         }
       
       else if(curve_fit==1){
         req(!is.null(p_ci),!is.null(ci))
         model<-lm(formula = y_dat~x_dat)
         model_text<-paste0("Model: y = ",ro(model[["coefficients"]][["(Intercept)"]],R)," + ",ro(model[["coefficients"]][["x_dat"]],R),"x")
         p<-p+labs(title = model_text)
         if(ci && !p_ci){
           output<-p+stat_smooth(method=lm, formula=y~x,level=conf,color=color[1])+
             geom_point(color=color[4],size=3)
         }
         if(!ci && !p_ci){
           output<-p+stat_smooth(method=lm, formula=y~x,level=0,color=color[1])+
             geom_point(color=color[4],size=3)
         }
         if(ci && p_ci){
           model<-lm(y_dat~x_dat)
           newdata<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
           pred<-data.frame(newdata,predict(model, newdata = newdata,interval="prediction",level=conf))
           output<-p+stat_smooth(method=lm, formula=y~x,level=conf,color=color[1])+
             geom_line(data=pred,aes(x=x_dat,y=lwr),linetype="dashed",color=col_fill_highlight)+
             geom_line(data=pred,aes(x=x_dat,y=upr),linetype="dashed",color=col_fill_highlight)+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){
           model<-lm(y_dat~x_dat)
           newdata<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
           pred<-data.frame(newdata,predict(model, newdata = newdata,interval="prediction",level=conf))
           output<-p+stat_smooth(method=lm, formula=y~x,level=0,color=color[1])+
             geom_line(data=pred,aes(x=x_dat,y=lwr),linetype="dashed",color=col_fill_highlight)+
             geom_line(data=pred,aes(x=x_dat,y=upr),linetype="dashed",color=col_fill_highlight)+
             geom_point(color=color[4],size=3)
         }
       }
       
       
       else if(curve_fit==2){
         #model<-nls(formula = y_dat~x_dat)
         #model_text<-paste0("Model: y = ",ro(model[["coefficients"]][["x_dat"]],R),"x + ",ro(model[["coefficients"]][["(Intercept)"]],R))
         req(!is.null(p_ci),!is.null(ci))
         form_1<-as.formula(paste("log(",names(data)[y],")~log(a)+b*",names(data)[x]))
         form_2<-as.formula(paste(names(data)[y],"~a*exp(b*",names(data)[x],")"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         fm0<-nls(formula = form_1,start = list(a=1,b=1),data=data)
         
         nls_m<-nls(formula=form_2,start=coef(fm0),data=data)
         #model_text<-paste0("y = ",ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][["a"]],R)," exp(",ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][["b"]],R),"x)")
         #p<-p+labs(caption = model_text)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~"e"^{.(B_const)~"x"})))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         #pred_pred<-data.frame(x_dat=new_dat,predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F))
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"

         if(!ci && !p_ci){
           output<-p+stat_smooth(method=nls, formula = y~a*exp(b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(ci && p_ci){

           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(data=data,method=nls, formula = y~a*exp(b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){

           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~a*exp(b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(ci && !p_ci){

           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             stat_smooth(method=nls, formula = y~a*exp(b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         
       }
       
       else if(curve_fit==3){
         req(!is.null(p_ci),!is.null(ci))
         form_2<-as.formula(paste(names(data)[y],"~a+b*log(",names(data)[x],")"))
         #new_dat<-as.data.frame(data[,x])
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         nls_m<-nls(formula=form_2,start=list(a=1,b=1),data=data)
         
         model_text<-paste0("y = ",ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)," + ",ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)," ln x")
         p<-p+labs(title = model_text)
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         if(ci && !p_ci){
         #output<-p+stat_smooth(method=lm, formula = y ~ log(x) ,level=conf,color=color[1])
           output<-p+
             stat_smooth(method=lm, formula = y ~ log(x) ,level=conf,color=color[1])+
             geom_point(color=color[4],size=3)+
             geom_point(color=color[4],size=3)
         }
         if(ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula = y ~ log(x) ,level=conf,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
         
         if(!ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula = y ~ log(x) ,se=F,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
         if(!ci && !p_ci){
           output<-p+
             stat_smooth(method=lm, formula = y ~ log(x) ,se=F,color=color[1])+
             geom_point(color=color[4],size=3)
         }
         
       }
       
       else if(curve_fit==4){
         req(!is.null(p_ci),!is.null(ci))
         form_2<-as.formula(paste(names(data)[y],"~a*(",names(data)[x],")+0"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         nls_m<-nls(formula=form_2,start=list(a=1),data=data)
         
         model_text<-paste0("Model: y = ",ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)," x")
         p<-p+labs(title =model_text)
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         if(ci && !p_ci){
         output<-p+stat_smooth(method=lm, formula=y~x+0,level=conf,color=color[1])
         }
         if(ci && p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=lm, formula = y ~ x+0 ,level=conf,color=color[1])+
             geom_point(data=data,color=col_line_control_chart,size=3)
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=lm, formula = y ~ x+0 ,se=F,color=color[1])+
             geom_point(data=data,color=col_line_control_chart,size=3)
         }
         if(!ci && !p_ci){
           output<-p+stat_smooth(method=lm, formula=y~x+0,se=F,color=color[1])
         }
       }
       
       else if(curve_fit==5){
         req(!is.null(p_ci),!is.null(ci))
         form_1<-as.formula(paste("log(",names(data)[y],")~log(",(names(data)[x]),")"))
         form_2<-as.formula(paste(names(data)[y],"~a*",names(data)[x],"^b"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         fm0<-lm(formula = form_1,data=data)
         nls_m<-nls(formula=form_2,start=list(a=exp(coef(fm0)[1]),b=coef(fm0)[2]),data=data)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~"x"^.(B_const))))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         if(!ci && !p_ci){
         output<-p+stat_smooth(method=nls, formula = y ~ a*x^b,method.args=list(start=list(a=exp(coef(fm0)[1]),b=coef(fm0)[2])),color=color[1],se=F)
         }
         if(ci && p_ci){
           output<-p+
             # geom_ribbon(aes(ymin=unlist(pred_conf$summary[5]),ymax=unlist(pred_conf$summary[6])),fill="grey80")+
             # geom_line(aes(x=x_dat,y=unlist(pred_pred$summary[5])),linetype="dashed",color=col_fill_highlight)+
             # geom_line(aes(x=x_dat,y=unlist(pred_pred$summary[6])),linetype="dashed",color=col_fill_highlight)+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y ~ a*x^b,method.args=list(start=list(a=exp(coef(fm0)[1]),b=coef(fm0)[2])),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y ~ a*x^b,method.args=list(start=list(a=exp(coef(fm0)[1]),b=coef(fm0)[2])),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(ci && !p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             stat_smooth(method=nls, formula = y ~ a*x^b,method.args=list(start=list(a=exp(coef(fm0)[1]),b=coef(fm0)[2])),color=color[1],se=F)+
             geom_point(color=col_line_control_chart,size=3)
         }
       }
      
       else if(curve_fit==6){
         req(!is.null(p_ci),!is.null(ci))
         #form_1<-as.formula(paste("log(",names(data)[y],")~b*log(a*",names(data)[x],")"))
         form_2<-as.formula(paste(names(data)[y],"~a+b/(",names(data)[x],")"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         #fm0<-nls(formula = form_1,start = list(a=1,b=2),data=data)
         nls_m<-nls(formula=form_2,start=list(a=1,b=1),data=data)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~"+"~.(B_const)~"/x")))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         
         if(!ci && !p_ci){
         output<-p+stat_smooth(method=nls, formula=y~a+(b/x),method.args=list(start=list(a=1,b=1)),color=color[1],se=F)
         }
         if(ci && p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~a+(b/x),method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~a+(b/x),method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         if(ci && !p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             stat_smooth(method=nls, formula = y~a+(b/x),method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         
       }
       
       else if(curve_fit==7){#compound, S is later
         req(!is.null(p_ci),!is.null(ci))
         form_2<-as.formula(paste(names(data)[y],"~a*b^(",names(data)[x],")"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         nls_m<-nls(formula=form_2,start=list(a=1,b=1),data=data)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~" * "~.(B_const)^"x")))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         if(!ci && !p_ci){
         output<-p+stat_smooth(method=nls, formula=y~a*b^x,method.args=list(start=list(a=1,b=1)),color=color[1],se=F)
         }
         if(ci && p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~a*b^x,method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~a*b^x,method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(ci && !p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             stat_smooth(method=nls, formula = y~a*b^x,method.args=list(start=list(a=1,b=1)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         
       }
       
       else if(curve_fit==8){
         req(!is.null(p_ci),!is.null(ci))
         fm0<-nls(formula = log(y_dat)~ a + b*x_dat,start = list(a=1,b=1),data=data)
         form_2<-as.formula(paste(names(data)[y],"~exp(a+b*",names(data)[x],")"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         nls_m<-nls(formula=form_2,start=coef(fm0),data=data)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = e"^{.(A_const)~" + "~.(B_const)~"x"})))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
         
         if(!ci && !p_ci){
         output<-p+stat_smooth(method=nls, formula = y ~ exp(a + b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)
         }
         if(ci && p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y ~ exp(a + b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y ~ exp(a + b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         if(ci && !p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             stat_smooth(method=nls, formula = y ~ exp(a + b*x),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
           
         }
         
       }
       
       else if(curve_fit==9){#no point cis needed
         output<-p+stat_smooth(method="loess", formula = y ~ x ,level=conf,color=color[1])
       }
       
       else if(curve_fit==10){
         req(!is.null(p_ci),!is.null(ci))
         model<-lm(y_dat~x_dat+I(x_dat^2))
         new_dat<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
         
         pred_pred<-predict(model,interval="prediction",newdata=new_dat,level=conf)
         pred_pred_data<-data.frame(new_dat,pred_pred)
         
         A_const<-ro(model[["coefficients"]][["(Intercept)"]],R)
         B_const<-ro(model[["coefficients"]][["x_dat"]],R)
         C_const<-ro(model[["coefficients"]][["I(x_dat^2)"]],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~" + "~.(B_const)~"x + "~.(C_const)~"x"^2)))

         if(ci && !p_ci){
         output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2) ,level=conf,color=color[1])
         }
         if(!ci && !p_ci){
           output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2) ,se=F,color=color[1])
         }
         if(ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2),level=conf,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2),se=F,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
         
       }
       
       else if(curve_fit==11){
         req(!is.null(p_ci),!is.null(ci))
         model<-lm(y_dat~x_dat+I(x_dat^2)+I(x_dat^3))
         new_dat<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
         
         pred_pred<-predict(model,interval="prediction",newdata=new_dat,level=conf)
         pred_pred_data<-data.frame(new_dat,pred_pred)
         
         A_const<-ro(model[["coefficients"]][["(Intercept)"]],R)
         B_const<-ro(model[["coefficients"]][["x_dat"]],R)
         C_const<-ro(model[["coefficients"]][["I(x_dat^2)"]],R)
         D_const<-ro(model[["coefficients"]][["I(x_dat^3)"]],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~" + "~.(B_const)~"x + "~.(C_const)~"x"^2~" + "~.(D_const)~"x"^3)))
         
         if(ci && !p_ci){
         output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3) ,level=conf,color=color[1])
         }
         if(!ci && !p_ci){
           output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3) ,se=F,color=color[1])
         }
         if(ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3),level=conf,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
           
         }
         if(!ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3),se=F,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
         
       }
       
       else if(curve_fit==12){
         req(!is.null(p_ci),!is.null(ci))
         model<-lm(y_dat~x_dat+I(x_dat^2)+I(x_dat^3)+I(x_dat^4))
         new_dat<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
         
         pred_pred<-predict(model,interval="prediction",newdata=new_dat,level=conf)
         pred_pred_data<-data.frame(new_dat,pred_pred)
         
         A_const<-ro(model[["coefficients"]][["(Intercept)"]],R)
         B_const<-ro(model[["coefficients"]][["x_dat"]],R)
         C_const<-ro(model[["coefficients"]][["I(x_dat^2)"]],R)
         D_const<-ro(model[["coefficients"]][["I(x_dat^3)"]],R)
         E_const<-ro(model[["coefficients"]][["I(x_dat^4)"]],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~" + "~.(B_const)~"x + "~.(C_const)~"x"^2~" + "~.(D_const)~"x"^3~" + "~.(E_const)~"x"^4)))
         
         
         if(ci && !p_ci){
         output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3)+ I(x^4) ,level=conf,color=color[1])
         }
         if(!ci && !p_ci){
           output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3)+ I(x^4) ,se=F,color=color[1])
         }
         if(ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3)+I(x^4),level=conf,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
           
         }
         if(!ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3)+I(x^4),se=F,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
           
         }
         
       }
       
       else if(curve_fit==13){
         req(!is.null(p_ci),!is.null(ci))
         model<-lm(y_dat~x_dat+I(x_dat^2)+I(x_dat^3)+I(x_dat^4)+I(x_dat^5))
         new_dat<-data.frame(x_dat=seq(from=(min(x_dat)), to=max(x_dat), length.out=steps))
         
         pred_pred<-predict(model,interval="prediction",newdata=new_dat,level=conf)
         pred_pred_data<-data.frame(new_dat,pred_pred)
         
         A_const<-ro(model[["coefficients"]][["(Intercept)"]],R)
         B_const<-ro(model[["coefficients"]][["x_dat"]],R)
         C_const<-ro(model[["coefficients"]][["I(x_dat^2)"]],R)
         D_const<-ro(model[["coefficients"]][["I(x_dat^3)"]],R)
         E_const<-ro(model[["coefficients"]][["I(x_dat^4)"]],R)
         F_const<-ro(model[["coefficients"]][["I(x_dat^5)"]],R)
         p<-p+labs(title = as.expression(bquote("Model: y = "~.(A_const)~" + "~.(B_const)~"x + "~.(C_const)~"x"^2~" + "~.(D_const)~"x"^3~" + "~.(E_const)~"x"^4~" + "~.(F_const)~"x"^5)))
         
         
         if(ci && !p_ci){
         output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3)+ I(x^4)+ I(x^5) ,level=conf,color=color[1])
         }
       
       if(!ci && !p_ci){
         output<-p+stat_smooth(method="lm", formula = y ~ x + I(x^2)+ I(x^3)+ I(x^4)+ I(x^5) ,se=F,color=color[1])
       }
         if(ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3)+I(x^4)+I(x^5),level=conf,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
           
         }
         if(!ci && p_ci){
           output<-p+
             stat_smooth(method=lm, formula =  y ~ x + I(x^2)+I(x^3)+I(x^4)+I(x^5),se=F,color=color[1])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x_dat,y=upr),linetype="dashed",color=color[2])+
             geom_point(color=color[4],size=3)
         }
           
     }
       
       else if(curve_fit==14){#S
         req(!is.null(p_ci),!is.null(ci))
         form_1<-as.formula(paste("log(",names(data)[y],")~a+b/",names(data)[x]))
         form_2<-as.formula(paste(names(data)[y],"~exp(a+b/",names(data)[x],")"))
         new_dat<-data.frame(seq(from=min(data[,x]),to=max(data[,x]),length.out=steps))
         names(new_dat)<-names(data)[x]
         
         fm0<-nls(formula = form_1,start = list(a=1,b=1),data=data)
         nls_m<-nls(formula=form_2,start=coef(fm0),data=data)
         
         A_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][1],R)
         B_const<-ro(environment(nls_m[["m"]][["formula"]])[["internalPars"]][2],R)
         p<-p+labs(title = as.expression(bquote("Model: y = e"^{.(A_const)~" + "~.(B_const)~"/x"})))
         
         pred_conf<-predictNLS(model=nls_m,interval = "confidence",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_conf_data<-data.frame(new_dat,pred_conf$summary)
         names(pred_conf_data)[6]<-"lwr"
         names(pred_conf_data)[7]<-"upr"
         names(pred_conf_data)[1]<-"x"
         
         pred_pred<-predictNLS(model=nls_m,interval = "prediction",newdata = new_dat,alpha = (1-conf),do.sim=F)
         pred_pred_data<-data.frame(new_dat,pred_pred$summary)
         names(pred_pred_data)[6]<-"lwr"
         names(pred_pred_data)[7]<-"upr"
         names(pred_pred_data)[1]<-"x"
         
        if(!ci && !p_ci){ 
         output<-p+stat_smooth(method=nls, formula=y~exp(a+(b/x)),method.args=list(start=coef(fm0)),color=color[1],se=F)
        }
         if(ci && p_ci){
           output<-p+
             geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~exp(a+(b/x)),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
         if(!ci && p_ci){
           output<-p+
             geom_line(data=pred_pred_data,aes(x=x,y=lwr),linetype="dashed",color=color[2])+
             geom_line(data=pred_pred_data,aes(x=x,y=upr),linetype="dashed",color=color[2])+
             stat_smooth(method=nls, formula = y~exp(a+(b/x)),method.args=list(start=coef(fm0)),color=color[1],se=F)+
             geom_point(color=color[4],size=3)
         }
           
           if(ci && !p_ci){
             output<-p+
               geom_ribbon(data=pred_conf_data,aes(x=x,ymin=lwr, ymax= upr),fill="grey80",inherit.aes = FALSE)+
               stat_smooth(method=nls, formula = y~exp(a+(b/x)),method.args=list(start=coef(fm0)),color=color[1],se=F)+
               geom_point(color=color[4],size=3)
           }
             
       }
       
       output<-output+
         theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
       
       if(y_x){
         output<-output+geom_line(aes(x=x_dat,y=x_dat),color=color[6])
         #ggsave(paste("spc_plot.",input$download_scat_format,sep=""),output)
         output
         }
       else{
         #ggsave(paste("spc_plot.",input$download_scat_format,sep=""),output)
         output}
     })
     
     output$scatter_plot_stats<-renderUI({
       y<-as.numeric(input$scat_y_sel)
       x<-as.numeric(input$scat_x_sel)
       curve_fit<-input$curve_fit
       data<- res_filter$filtered()
       conf<-input$conf_scatter
       R<-input$decimal_scat
       corr_tests=1
       
       validate(need(!is.na(x) && !is.na(y),"Need to enter x and y data vectors"))
       output<-NULL
       
       if(curve_fit==1){#linear
         stats<-lm(data[,y]~data[,x])
         results=cor.pearson.r.onesample(x = data[,x],y = data[,y],null.hypothesis.rho = 0,conf.level = conf)
         output<-HTML(c(#paste(
         # "<b>Model: </b>y = ",
         # ro(stats$coefficients[1],R),
         # " + ",
         # ro(stats$coefficients[2],R),
         # "x"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         )
         )
       }#end 1
       
       if(curve_fit==2){
         y=log(data[,y])
         x=data[,x]
         stats<-lm(y~x)
         results=cor.pearson.r.onesample(x = x,y = y,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro(exp(stats$coefficients[1]),R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "x"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==3){
         y=data[,y]
         x=log(data[,x])
         stats<-lm(y~x)
         results=cor.pearson.r.onesample(x = x,y = y,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro(stats$coefficients[1],R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "ln(x)"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==4){
         y=data[,y]
         x=data[,x]
         stats<-lm(y~x+0)
         results=cor.pearson.r.onesample(x = x,y = y,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
           # "<b>Model: </b>y = ",
           # ro(stats$coefficients[1],R)," x"),"</br>","</br>",
         paste("<b>",results$method,"</b>"),
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==5){
         y=log(data[,y])
         x=log(data[,x])
         stats<-lm(y~x)
         results=cor.pearson.r.onesample(x = x,y = y,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro(exp(stats$coefficients[1]),R),
         #   "x<sup>",
         #   ro((stats$coefficients[2]),R),
         #   "</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==6){
         y=data[,y]
         x=data[,x]
         stats<-nls(formula = y~a+(b/x),start = list(a=1,b=1))
         sum_stats<-summary(stats)
         results=cor.pearson.r.onesample(x = 1/x,y = y,null.hypothesis.rho = 0,conf.level = conf)
         
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro(sum_stats$coefficients[1],R),
         #   " + ",
         #   ro(sum_stats$coefficients[2],R),
         #   " / x"),
         # "</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==7){
         y=log(data[,y])
         x=data[,x]
         stats<-lm(y~x)
         results=cor.pearson.r.onesample(x = x,y = log(y),null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro(exp(stats$coefficients[1]),R),
         #   " + ",
         #   ro(exp(stats$coefficients[2]),R),
         #   "<sup>x</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       
       if(curve_fit==8){
         y=log(data[,y])
         x=data[,x]
         stats<-lm(y~x)
         results=cor.pearson.r.onesample(x = x,y = log(y),null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = e<sup>",
         #   ro((stats$coefficients[1]),R),
         #   " + ",
         #   ro((stats$coefficients[2]),R),
         #   "x</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==9){
         output<-HTML("Loess is only used for exploratory analysis to identify patterns. No r<sup>2</sup> should be calculated.")
       }
       
       if(curve_fit==10){
         y=data[,y]
         x=data[,x]
         stats<-lm(y~x + I(x^2))
         r_sq<-as.numeric(summary(stats)[8])
         n_samp<-length(unlist(summary(stats)[3]))
         results=cor.pearson.r.onesample.simple(sample.r = (r_sq)^.5,sample.size = n_samp,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro((stats$coefficients[1]),R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "x + ",
         #   ro(stats$coefficients[3],R),
         #   "x<sup>2</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==11){
         y=data[,y]
         x=data[,x]
         stats<-lm(y~x + I(x^2)+I(x^3))
         r_sq<-as.numeric(summary(stats)[8])
         n_samp<-length(unlist(summary(stats)[3]))
         results=cor.pearson.r.onesample.simple(sample.r = (r_sq)^.5,sample.size = n_samp,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro((stats$coefficients[1]),R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "x + ",
         #   ro(stats$coefficients[3],R),
         #   "x<sup>2</sup> + ",
         #   ro(stats$coefficients[4],R),
         #   "x<sup>3</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==12){
         y=data[,y]
         x=data[,x]
         stats<-lm(y~x + I(x^2)+I(x^3)+I(x^4))
         r_sq<-as.numeric(summary(stats)[8])
         n_samp<-length(unlist(summary(stats)[3]))
         results=cor.pearson.r.onesample.simple(sample.r = (r_sq)^.5,sample.size = n_samp,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro((stats$coefficients[1]),R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "x + ",
         #   ro(stats$coefficients[3],R),
         #   "x<sup>2</sup> + ",
         #   ro(stats$coefficients[4],R),
         #   "x<sup>3</sup> + ",
         #   ro(stats$coefficients[5],R),
         #   "x<sup>4</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }

       if(curve_fit==13){
         y=data[,y]
         x=data[,x]
         stats<-lm(y~x + I(x^2)+I(x^3)+I(x^4)+I(x^5))
         r_sq<-as.numeric(summary(stats)[8])
         n_samp<-length(unlist(summary(stats)[3]))
         results=cor.pearson.r.onesample.simple(sample.r = (r_sq)^.5,sample.size = n_samp,null.hypothesis.rho = 0,conf.level = conf)
         #output<-p(stats$coefficients[1])
         output<-HTML(c(#paste(
         #   "<b>Model: </b>y = ",
         #   ro((stats$coefficients[1]),R),
         #   " + ",
         #   ro(stats$coefficients[2],R),
         #   "x + ",
         #   ro(stats$coefficients[3],R),
         #   "x<sup>2</sup> + ",
         #   ro(stats$coefficients[4],R),
         #   "x<sup>3</sup> + ",
         #   ro(stats$coefficients[5],R),
         #   "x<sup>4</sup> + ",
         #   ro(stats$coefficients[6],R),
         #   "x<sup>5</sup>"
         # ),"</br>","</br>",
         paste("<b>",results$method,"</b>"),"</br>Transformed Data",
         "<br><br>",
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
         "<td>","</td>",
         "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste(conf*100,"% confidence interval for"),"</td>",
         "<td>",paste(withMathJax("$\\rho :$")),"</td>",
         "<td>",ro(results$conf.int[1],R),"</td>",
         "<td>"," to ","</td>",
         "<td>",ro(results$conf.int[2],R),"</td>",
         "</tr>",
         "</table>",
         
         "<table>",
         "<tr>",
         "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
         "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
         
         "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
         "</tr>",
         "</table>",
         
         #"<br><br>",
         paste(beta_statement,100*ro(results$estimate[8],R),"%")
         
         ))
       }
       
       if(curve_fit==14){
         y=data[,y]
         x=data[,x]
         fm0<-nls(formula = log(y)~a+(b/x),start = list(a=1,b=1))
         stats<-nls(formula = y~exp(a+(b/x)),start = coef(fm0))
         sum_stats<-summary(stats)
         
         results=cor.pearson.r.onesample(x = (1/x),y = log(y),null.hypothesis.rho = 0,conf.level = conf)
         
         output<-HTML(c(#paste(
           # "<b>Model: </b>y = e<sup>",
           # ro(sum_stats$coefficients[1],R),
           # " + ",
           # ro(sum_stats$coefficients[2],R),
           # "/x</sup>"),
           # "</br>","</br>",
           paste("<b>",results$method,"</b>"),"</br>Transformed Data",
           "<br><br>",
           "<table>",
           "<tr>",
           "<td>",paste(withMathJax("$r = $"),ro(results$estimate[1],R)),"</td>",
           "<td>","</td>",
           "<td>",paste(withMathJax("$\\rho_{0}=$"),ro(results$parameter,R)),"</td>",
           "</tr>",
           "<tr>",
           "<td>",paste(withMathJax("$r^2 = $"),ro(results$estimate[1]^2,R)),"</td>",
           "</tr>",
           "<tr>",
           "<td>",paste(withMathJax("$n = $"),ro(results$estimate[3],R)),"</td>",
           "</tr>",
           "</table>",
           
           "<table>",
           "<tr>",
           "<td>",paste(conf*100,"% confidence interval for"),"</td>",
           "<td>",paste(withMathJax("$\\rho :$")),"</td>",
           "<td>",ro(results$conf.int[1],R),"</td>",
           "<td>"," to ","</td>",
           "<td>",ro(results$conf.int[2],R),"</td>",
           "</tr>",
           "</table>",
           
           "<table>",
           "<tr>",
           "<td>",paste("Test for ",choice_corr_alt_text[3*(as.numeric(corr_tests)-1)+1],": "),"</td>",
           "<td>",paste(if(results$parameter==0){"t = "}else{"z = "},ro(results$statistic,R)),if(results$parameter==0){paste("df = ",results$estimate[2])}else{""},"</td>",
           
           "<td>",paste("p = ",ro(results$p.value,R),if(results$p.value<1-conf){"*"}),"</td>",
           "</tr>",
           "</table>",
           
           #"<br><br>",
           paste(beta_statement,100*ro(results$estimate[8],R),"%")
           
         ))
       }
       
       
       output
     })
     
     #mode calculation
     # Mode <- function(x, method = "one", na.rm = FALSE) {#https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode
     #   x <- unlist(x)
     #   if (na.rm) {
     #     x <- x[!is.na(x)]
     #   }
     #   
     #   # Get unique values
     #   ux <- unique(x)
     #   n <- length(ux)
     #   
     #   # Get frequencies of all unique values
     #   frequencies <- tabulate(match(x, ux))
     #   modes <- frequencies == max(frequencies)
     #   
     #   # Determine number of modes
     #   nmodes <- sum(modes)
     #   nmodes <- ifelse(nmodes==n, 0L, nmodes)
     #   
     #   if (method %in% c("one", "mode", "") | is.na(method)) {
     #     # Return NA if not exactly one mode, else return the mode
     #     if (nmodes != 1) {
     #       return(NA)
     #     } else {
     #       return(ux[which(modes)])
     #     }
     #   } else if (method %in% c("n", "nmodes")) {
     #     # Return the number of modes
     #     return(nmodes)
     #   } else if (method %in% c("all", "modes")) {
     #     # Return NA if no modes exist, else return all modes
     #     if (nmodes > 0) {
     #       return(ux[which(modes)])
     #     } else {
     #       return(NA)
     #     }
     #   }
     #   warning("Warning: method not recognised.  Valid methods are 'one'/'mode' [default], 'n'/'nmodes' and 'all'/'modes'")
     # }

     
     output$model_ci<-renderUI({
       fit<-input$curve_fit
       
       if(fit==0 || fit==""){
         output<-NULL
       } else {
         output<-prettySwitch(inputId = "scat_ci",label = "CI for Model",value = T,status="success",fill=T)
         }
       output
     })
     
     output$point_ci<-renderUI({
       fit<-input$curve_fit
       
       if(fit==0 || fit==""){
         output<-NULL
       } else {
         output<-prettySwitch(inputId = "point_ci",label = "CI for Points",value = T,status="success",fill=T)
       }
       output
     })
     
     output$ci_out<-renderDT({
       data<- res_filter$filtered()
       type<-input$eda_data_type#1=columns 2=factor
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_ci
       data_col<-input$data_list_for_ci#column number of selected dependent in original data
       conf<-input$conf_ci
       
       req(data,type)
      
       names(data)<-make.names(names(data))
       
       if (type==1){#columns
         sum_out<-summary.all.variables(data[UI1])
         #t_out<-t.test.onesample.simple(sample.mean = sum_out$mean,sample.variance = sum_out$var,sample.size = sum_out$n,conf.level = conf)
         len<-length(UI1)
         loop<-seq(from=1,to=len)
         mean_ci_l<-NULL
         mean_ci_u<-NULL
         samp_size<-NULL
         means<-NULL
         stdev<-NULL
         stdev_l<-NULL
         stdev_u<-NULL
         
         for (int in loop){
           
           t_out<-t.test.onesample.simple(sample.mean = sum_out$mean[int],sample.variance = sum_out$var[int],sample.size = sum_out$n[int],conf.level = conf)
           mean_ci_l<-c(mean_ci_l,t_out[["conf.int"]][1])
           mean_ci_u<-c(mean_ci_u,t_out[["conf.int"]][2])
           df_<-t_out[["estimate"]][["df"]]
           samp_size<-c(samp_size,1+df_)
           means<-c(means,t_out[["estimate"]][["sample.mean"]])
           s_<-t_out[["estimate"]][["sd"]]
           stdev<-c(stdev,s_)
           stdev_l<-c(stdev_l,t_out[["estimate"]][["sd.lowerci"]])
           stdev_u<-c(stdev_u,t_out[["estimate"]][["sd.upperci"]])
           
         }
         output<-cbind(Column=unname(sum_out[1]),n=unname(samp_size),Mean_L=unname(mean_ci_l),Mean=unname(means),Mean_U=unname(mean_ci_u),SD_L=unname(stdev_l),SD=unname(stdev),SD_U=unname(stdev_u))
         
       }
       if(type==2){#reference
         req(data_col)
         #create summary, then t-test, then extract numbers
         dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
         indep<-colnames(data)[as.numeric(unlist(strsplit (x = as.character(UI1),split = "\\s+")))]
         indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
         model_text<-formula(paste(dep_name," ~ ",indep_names))
         sum_out<-summary.continuous(fx = model_text,data = data)
         #t_out<-t.test.onesample.simple(sample.mean = sum_out$mean,sample.variance = sum_out$var,sample.size = sum_out$n,conf.level = conf)
         #assemble the table
         len<-nrow(unique(data[UI1]))
         combos<-seq(from=1,to=len)
         mean_ci_l<-NULL
         mean_ci_u<-NULL
         samp_size<-NULL
         means<-NULL
         stdev<-NULL
         stdev_l<-NULL
         stdev_u<-NULL
         for (int in combos){
           
           t_out<-t.test.onesample.simple(sample.mean = sum_out$mean[int],sample.variance = sum_out$var[int],sample.size = sum_out$n[int],conf.level = conf)
           mean_ci_l<-c(mean_ci_l,t_out[["conf.int"]][1])
           mean_ci_u<-c(mean_ci_u,t_out[["conf.int"]][2])
           df_<-t_out[["estimate"]][["df"]]
           samp_size<-c(samp_size,1+df_)
           means<-c(means,t_out[["estimate"]][["sample.mean"]])
           s_<-t_out[["estimate"]][["sd"]]
           stdev<-c(stdev,s_)
           stdev_l<-c(stdev_l,t_out[["estimate"]][["sd.lowerci"]])
           stdev_u<-c(stdev_u,t_out[["estimate"]][["sd.upperci"]])
           
         }
         output<-cbind(sum_out[seq(1,length(UI1))],n=unname(samp_size),Mean_L=unname(mean_ci_l),Mean=unname(means),Mean_U=unname(mean_ci_u),SD_L=unname(stdev_l),SD=unname(stdev),SD_U=unname(stdev_u))
         
         
   
       }
       ro(output,R)
     }#end brace
     )#end ci_out
     
     output$ci_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_ci",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     output$nt_out_simple<-renderDT({
       #data<- res_filter$filtered()
       #type<-input$eda_data_type#1=columns 2=factor
       #UI1<-input$eda_UI1#columns if column data, factors if factor data, the column number from res_filter$filtered
       #UI2<-input$eda_UI2#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_nt
       #data_col<-input$data_list_for_nt#column number of selected dependent in original data, used in type=2
       distr<-input$dist_nt
       #conf<-input$conf_nt
       UI1_nt<-as.numeric(input$UI1_nt)
       UI2_nt<-as.numeric(input$UI2_nt)
       
       #req(res_filter$filtered())
       validate(need(!is.null(UI1_nt && !is.null(UI2_nt) && !is.null(distr)),"Select a distribution and enter the parameters"))
       
         if(distr==1){
           output<-natural.tolerance.normal.simple(mean = UI1_nt,variance = UI2_nt^2)
           }
       if(distr==2){
         output<-natural.tolerance.exp.low.simple(rate = 1/(UI1_nt - UI2_nt),low = UI2_nt)
       }
       if(distr==3){
         output<-natural.tolerance.binom.simple(size = UI1_nt,prob = UI2_nt)
       }
       if(distr==4){
         output<-natural.tolerance.poisson.simple(lambda = UI1_nt)
       }
       if(distr==5){
         output<-natural.tolerance.chisquare.simple(df = UI1_nt,ncp = UI2_nt)
       }
       
       ro(output,R)
       
       
     })#end nt_out_simple
     
     output$nt_out_data<-renderDT({
       data<- res_filter$filtered()
       type<-input$eda_data_type#1=columns 2=factor
       UI1<-as.numeric(input$eda_UI1)#columns if column data, factors if factor data, the column number from res_filter$filtered
       UI2<-as.numeric(input$eda_UI2)#selected dependent data if factors, the column number from res_filter$filtered
       R<-input$decimals_nt_data
       data_col<-input$data_list_for_nt#column number of selected dependent in original data, used in type=2
       distr<-input$dist_nt_data
       conf<-input$conf_nt
       #UI1_nt<-as.numeric(input$UI1_nt)
       #UI2_nt<-as.numeric(input$UI2_nt)
       
       req(data)
       validate(need(!is.null(UI1),"Set up data first"))
       
       if(type==1){
         len=length(UI1)
         if(len==1){
           if(distr==1){
           output<-natural.tolerance.normal(x = na.omit(data[[UI1[1]]]))
           }
           if(distr==2){
             output<-natural.tolerance.exp.low(x = na.omit(data[[UI1[1]]]))
           }
           if(distr==3){
             output<-natural.tolerance.exp(x = na.omit(data[[UI1[1]]]))
           }
         }
         else{
           x=seq(from=2, to=len)
         if(distr==1){
           output<-natural.tolerance.normal(x = na.omit(data[[UI1[1]]]))
           for (loop in x){
             output<-rbind(output,natural.tolerance.normal(x = na.omit(data[[UI1[loop]]])))
           }
           }
         if(distr==2){
           output<-natural.tolerance.exp.low(x = na.omit(data[[UI1[1]]]))
           for (loop in x){
             output<-rbind(output,natural.tolerance.exp.low(x = na.omit(data[[UI1[loop]]])))
           }
           
         }
           if(distr==3){
             output<-natural.tolerance.exp(x = na.omit(data[[UI1[1]]]))
             for (loop in x){
               output<-rbind(output,natural.tolerance.exp(x = na.omit(data[[UI1[loop]]])))
             }
             
           }
           }
         output<-cbind(Data=names(data)[UI1],output)
       }#end type=1
       
       if(type==2){
         #build a formula for the summary
         dep_name<- colnames(data)[as.numeric(data_col)]  #from data and data_col, one dependent data selected
         indep<-colnames(data)[as.numeric(unlist(strsplit (x = as.character(UI1),split = "\\s+")))]
         indep_names<-paste(indep,collapse = "+") #need to put pluses between for equation
         req(dep_name)
         req(indep_names)
         model_text<-formula(paste(dep_name," ~ ",indep_names))
         
         if(distr==1){
           sum_out<-summary.continuous(fx=model_text,data=na.omit(data))
           output<-natural.tolerance.normal.simple(mean=sum_out$mean,variance = sum_out$var)
           output<-cbind(sum_out[c(1,2,3)],output)
         }
         if(distr==2){
           sum_out<-summary.continuous(fx=model_text,data=na.omit(data),stat.min=T)
           output<-natural.tolerance.exp.low.simple(rate = 1/(sum_out$mean-sum_out$min),low =sum_out$min)
           output<-cbind(sum_out[c(1,2,3)],output)
         }
         
       }#end type 2
       
       output<-ro(output,R)
       
       output
       
     })#end nt_out_data
     
     
     output$nt_data_list<-renderUI({
       data<- res_filter$filtered()
       data_type<-input$eda_data_type#1=columns 2=factor
       UI1<-input$eda_UI1#columns if column data, factors if factor data
       UI2<-input$eda_UI2#selected data column numbers if factors
       
       if(data_type==1){output<-NULL}
       
       if(data_type==2){
         select<-as.numeric(unlist(strsplit (x = UI2,split = "\\s+")))
         names(UI2)<-names(data)[select]
         output<-radioButtons(inputId = "data_list_for_nt",label = "Select data:",choices = UI2)
       }
       
       output
     })
     
     output$nt_UI1<-renderUI({
       distr<-input$dist_nt
       
       if(distr == 1){
         output<-numericInput(inputId = "UI1_nt",label = "Mean",value = 0)
       }
       if(distr == 2){
         output<-numericInput(inputId = "UI1_nt",label = "Mean",value = 50)
       }
       if(distr == 3){
         output<-numericInput(inputId = "UI1_nt",label = "n",value = 10)
       }
       if(distr == 4){
         output<-numericInput(inputId = "UI1_nt",label = "lambda",value = 10)
       }
       if(distr == 5){
         output<-numericInput(inputId = "UI1_nt",label = "df",value = 10)
       }
       
       
       output
       
     })
     
     output$nt_UI2<-renderUI({
       distr<-input$dist_nt
       
       if(distr == 1){
         output<-numericInput(inputId = "UI2_nt",label = "Standard Deviation",value = 1)
       }
       if(distr == 2){
         output<-numericInput(inputId = "UI2_nt",label = "Minimum",value = 0)
       }
       if(distr == 3){
         output<-numericInput(inputId = "UI2_nt",label = "Probability",value = .5)
       }
       if(distr == 4){
         output<-NULL
       }
       if(distr == 5){
         output<-numericInput(inputId = "UI2_nt",label = "ncp",value = 0)
       }
       
       output
     })
     
     # CI_t <- function (x, ci = 0.95)#https://www.r-bloggers.com/2021/04/calculating-confidence-interval-in-r/
     # {
     #   `%>%` <- magrittr::`%>%`
     #   Margin_Error <- qt(ci + (1 - ci)/2, df = length(x) - 1) * sd(x)/sqrt(length(x))
     #   df_out <- data.frame( sample_size=length(x), Mean=mean(x), sd=sd(x),
     #                         Margin_Error=Margin_Error,
     #                         'CI lower limit'=(mean(x) - Margin_Error),
     #                         'CI Upper limit'=(mean(x) + Margin_Error)) %>%
     #     tidyr::pivot_longer(names_to = "Measurements", values_to ="values", 1:6 )
     #   return(df_out)
     # }
     
     #First UI element of the oneway data selection, used either for selecting columns or the factor
     output$factor_ow<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())

         output<-pickerInput(inputId = "ow_factor",
                             label = "Select Factor",
                             multiple=F,
                             choices = choices)
      
       output
       
     })
     
     #Second UI element of the oneway data selection used for selecting the data columns
     output$data_ow<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-input$ow_factor
       req(UI1)
           #take out those already selected
           fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-choices[temp]
           
           output<-pickerInput(inputId = "ow_data",
                               label = "Select Data",
                               multiple=F,
                               choices = choices)
          
       
       output
       
     })
     
     output$ow_table<-renderUI({#oneway table
       data<- res_filter$filtered()
       req(data)
       names(data)<-make.names(names(data))
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       conf<-input$conf_ow
       R<-input$decimal_ow
       form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
       type<-input$type_ow#1=Fisher, 2=random, 3=K-W, 4=Welch
       
       req(data_col)
       
       
       if(type==1 || type==2){#fixed or random the same source table
         oneway<-aov(formula = form,data = data)
         sum_aov<-ro(summary(oneway),R)
         
         temp<-summary(lm(formula = form,data = data))
         r_sq <- temp[["r.squared"]]
         r_sqr_adj <- temp[["adj.r.squared"]]
         
         sse<-sum_aov[[1]][["Sum Sq"]][1]
         ssw<-sum_aov[[1]][["Sum Sq"]][2]
         dfe<-sum_aov[[1]][["Df"]][1]
         dfw<-sum_aov[[1]][["Df"]][2]
         mse<-sum_aov[[1]][["Mean Sq"]][1]
         msw<-sum_aov[[1]][["Mean Sq"]][2]
         sst<-sse+ssw
         dft<-dfe+dfw
         
         omega_sq<-100*(sse-(dfe*msw))/(sst+msw)#fixed
         
         table_aov<-as.data.frame(table(data[factor_ow]))
         table_aov<-cbind(table_aov,table_aov[2]^2)
         J<-nrow(table_aov)
         sum_n<-colSums(table_aov[2])
         sum_nsq<-colSums(table_aov[3])
         K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
         
         bcv<-(mse-msw)/K_prime
         bcv<-max(0,bcv)
         ICC<-100*bcv/(bcv+msw)
        
         
         output<-
         HTML(c(
           #"<style> td,th{padding: 2px 15px !important;}</style>", style="padding: 2px 15px !important;"
           "Fisher's One-way analysis of variance (assumes equal variances, robust if equal n per group)","</br></br>",
           "Model : ",names(oneway$model)[1]," by ",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),
           "</br></br>",
           "<table><tr><th  style='padding: 2px 15px !important;'>Source</th><th  style='padding: 2px 15px !important;'>df</th><th  style='padding: 2px 15px !important;'>SS</th><th  style='padding: 2px 15px !important;'>MS</th><th  style='padding: 2px 15px !important;'>F</th><th  style='padding: 2px 15px !important;'>p</th></tr>",
           "<tr><td  style='padding: 2px 15px !important;'>",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),"</td>",
           "<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Sum Sq"]][1],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Mean Sq"]][1],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["F value"]][1],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Pr(>F)"]][1],if(sum_aov[[1]][["Pr(>F)"]][1]<=(1-conf)){"*"},"</tr>",
           "<tr><td  style='padding: 2px 15px !important;'> Within</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Sum Sq"]][2],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Mean Sq"]][2],"</td></tr>",
           "<tr><td  style='padding: 2px 15px !important;'> Total</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1]+sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Sum Sq"]][1]+sum_aov[[1]][["Sum Sq"]][2],"</td></tr>",
           "</table></br>",
           "<table><tr><td style='text-align:right'>",paste(withMathJax("$r^2=$"),ro(r_sq,R),"</td><td></td>",
                                                            "<td>",withMathJax("$r_{adj}^2=$"),ro(r_sqr_adj,R)),"</td></tr></table><br>",
           if(type==1){
             paste(
           "<table><tr><td>Fixed Effect Importance:</td></tr>",
           "<tr><td><b>",paste(withMathJax("$\\omega^2=$"),ro(omega_sq,R),"%"),"</b></td></tr></table>"
           )
           },
           if(type==2){
             paste(
               "<table><tr><td>Random Effect Importance:</td></tr>",
               "<tr><td>Treatment Variance =</td><td>",ro(bcv,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{treat}=$"),ro(bcv^.5,R),"</tr>",
               "<tr><td>Within Variance =</td><td>",ro(msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{within}=$"),ro(msw^.5,R),"</tr>",
               "<tr><td>Total Variance =</td><td>",ro(bcv+msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{total}=$"),ro((bcv+msw)^.5,R),"</tr>",
               "<tr><td><b>Intraclass Correlation =</b></td><td><b>",ro(ICC,R),"%</b></td>","</tr>",
               "</table>"
             )
           }
           ))#end html
       }#end fixed and random
       if(type==3){#K-W
         form<-as.formula(paste(names(data)[data_col]," ~ ",names(data)[factor_ow]))
         KW<-anova.independent.kruskal.wallis(fx = form,data = data,conf.level = conf)
         # mean_rank_tab<-cbind(factor=data[factor_ow],data=data[data_col],rank=rank(data[data_col]))
         # KW_tab<-ro(aggregate(x = mean_rank_tab,by=mean_rank_tab[1],FUN=function(x) c(Mean.Rank=mean(x),Count=length(x)))[c(-2,-3)],R)
         
         output<-
           HTML(c(
             "Method : ",KW$method,"</br>",
             "Model : ",names(data)[data_col]," by ",names(data)[factor_ow],
             "</br></br>",
             "<table><tr>",
             "<td>H = ",ro(KW$statistic,R),"</td><td>p =",ro(KW$p.value,R),if(KW$p.value <= 1-conf){"*"},"</td></tr>",
             "</table></br></br>"
           ))#end HTML and c
       }#end K-W
       
       if(type==4){#fixed welch output
         oneway_w<-oneway.test(formula = form,data = data,var.equal=FALSE)
         oneway<-aov(formula = form,data = data)#just for labels
         nTot<-nrow(data)
         dfEff<-(oneway_w[["parameter"]][["num df"]])
         wF<-oneway_w[["statistic"]][["F"]]
         imp_w<-(dfEff*(wF-1))/(dfEff*(wF-1)+nTot) * 100
         if(is.nan(wF)){return(HTML("NaN returned. This is possibly due to having a 0 variance for one or more cells. Try the Fisher ANOVA."))}
         output<-
           HTML(c(
             "Welch's ",oneway_w[["method"]],
             "</br></br>",
             "Model : ",names(oneway$model)[1]," by ",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),
             "</br></br>",
             
             "<table><tr><th  style='padding: 2px 15px !important;'>Source</th><th  style='padding: 2px 15px !important;'>df</th><th  style='padding: 2px 15px !important;'>F</th><th  style='padding: 2px 15px !important;'>p</th></tr>",
             "<tr><td  style='padding: 2px 15px !important;'>",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),"</td>",
             "<td  style='padding: 2px 15px !important;'>",dfEff,",",ro(oneway_w[["parameter"]][["denom df"]],R),"</td><td  style='padding: 2px 15px !important;'>",ro(wF,R),"</td><td  style='padding: 2px 15px !important;'>",ro(oneway_w[["p.value"]],R),if(oneway_w[["p.value"]]<=(1-conf)){"*"},"</tr>",   #if(sum_aov[[1]][["Pr(>F)"]][1]<=(1-conf)){"*"}
             "</table></br></br>",
             "<table><tr><td>Fixed Effect Importance:</td></tr>",
                 "<tr><td><b>",paste(withMathJax("$\\omega^2=$"),ro(imp_w,R),"%"),"</b></td></tr></table>"
            
           ))#end html
       }#end welch
       
       
       output
     })
     
     output$ow_disp<-renderUI({#oneway dispersion tests
       data<- res_filter$filtered()
       req(data)
       names(data)<-make.names(names(data))
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       req(data_col,factor_ow)
       conf<-input$conf_ow
       R<-input$decimal_ow
       form_c<-as.formula(paste(names(data)[data_col]," ~ ",names(data)[factor_ow]))
       form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
       type<-input$type_ow#1=fixed, 2=random, 3=K-W
       
       
       
       if(type==1 || type==2 || type==4){#fixed, random, Welch need dispersion tests
         #calculate ada, adm, admn-1
         ada_dat<-compute.group.dispersion.ADA(fx = form_c,data = data)
         adm_dat<-compute.group.dispersion.ADM(fx = form_c,data = data)
         admn1_dat<-compute.group.dispersion.ADMn1(fx = form_c,data = data)
         
         disp_data<-as.data.frame(cbind(factor=data[[factor_ow]],ada=ada_dat,adm=adm_dat,admn1=admn1_dat))
         
         
         if( length(unique((data%>%count(!! as.name(names(data)[factor_ow])))$n))!=1 ){#branch to use Welch anova for dispersion if sample sizes are unequal
           if(disp_data%>%group_by(as.factor(factor))%>%filter(!is.na(ada))%>%summarize(var=var(ada))%>%summarize(value=min(var))==0){#must use Fisher
             ada_type<-"Fisher (unequal n, cell var = 0)"
             ada_aov<-summary(aov(formula = ada~as.factor(factor),data = disp_data))
             lev_df<-paste("F(",ada_aov[[1]]$Df[1],",",ada_aov[[1]]$Df[2],")")
             lev_f<-ada_aov[[1]]$`F value`[1]
             lev_p<-ada_aov[[1]]$`Pr(>F)`[1]
           } else{#use Welch
             ada_type<-"Welch (unequal n)"
             ada_aov<-oneway.test(formula = ada~as.factor(factor),data = disp_data,var.equal = FALSE)
             lev_df<-paste("F(",ada_aov[["parameter"]][1],",",ro(ada_aov[["parameter"]][2],R),")")
             lev_f<-ada_aov[["statistic"]][["F"]]
             lev_p<-ada_aov[["p.value"]]
           }
           
           if(disp_data%>%group_by(as.factor(factor))%>%filter(!is.na(adm))%>%summarize(var=var(adm))%>%summarize(value=min(var))==0){#must use Fisher
             adm_type<-"Fisher (unequal n, cell var = 0)"
             adm_aov<-summary(aov(formula = adm~as.factor(factor),data = disp_data))
             adm_df<-paste("F(",adm_aov[[1]]$Df[1],",",ro(adm_aov[[1]]$Df[2],R),")")
             adm_f<-adm_aov[[1]]$`F value`[1]
             adm_p<-adm_aov[[1]]$`Pr(>F)`[1]
           
           } else{#use Welch
             adm_type<-"Welch (unequal n)"
             adm_aov<-oneway.test(formula = adm~as.factor(factor),data = disp_data,var.equal = FALSE)
             adm_df<-paste("F(",adm_aov[["parameter"]][1],",",ro(adm_aov[["parameter"]][2],R),")")
             adm_f<-adm_aov[["statistic"]][["F"]]
             adm_p<-adm_aov[["p.value"]]
           }
           
           if(disp_data%>%group_by(as.factor(factor))%>%filter(!is.na(admn1))%>%summarize(var=var(admn1))%>%summarize(value=min(var))==0){#must use Fisher
             admn1_type<-"Fisher (unequal n, cell var = 0)"
             admn1_aov<-summary(aov(formula = admn1~as.factor(factor),data = disp_data))
             admn1_df<-paste("F(",admn1_aov[[1]]$Df[1],",",admn1_aov[[1]]$Df[2],")")
             admn1_f<-admn1_aov[[1]]$`F value`[1]
             admn1_p<-admn1_aov[[1]]$`Pr(>F)`[1]
             } else{#use Welch
               admn1_type<-"Welch (unequal n)"
               admn1_aov<-oneway.test(formula = admn1~as.factor(factor),data = disp_data,var.equal = FALSE)
               admn1_df<-paste("F(",admn1_aov[["parameter"]][1],",",admn1_aov[["parameter"]][2],")")
               admn1_f<-admn1_aov[["statistic"]][["F"]]
               admn1_p<-admn1_aov[["p.value"]]
           }
           
         } else {#Use Fisher
           ada_type<-"Fisher (equal n)"
           adm_type<-"Fisher (equal n)"
           admn1_type<-"Fisher (equal n)"
           ada_aov<-summary(aov(formula = ada~as.factor(factor),data = disp_data))
           lev_df<-paste("F(",ada_aov[[1]]$Df[1],",",ada_aov[[1]]$Df[2],")")
           lev_f<-ada_aov[[1]]$`F value`[1]
           lev_p<-ada_aov[[1]]$`Pr(>F)`[1]
           
           adm_aov<-summary(aov(formula = adm~as.factor(factor),data = disp_data))
           adm_df<-paste("F(",adm_aov[[1]]$Df[1],",",adm_aov[[1]]$Df[2],")")
           adm_f<-adm_aov[[1]]$`F value`[1]
           adm_p<-adm_aov[[1]]$`Pr(>F)`[1]
           
           admn1_aov<-summary(aov(formula = admn1~as.factor(factor),data = disp_data))
           admn1_df<-paste("F(",admn1_aov[[1]]$Df[1],",",admn1_aov[[1]]$Df[2],")")
           admn1_f<-admn1_aov[[1]]$`F value`[1]
           admn1_p<-admn1_aov[[1]]$`Pr(>F)`[1]
         }
         
         #generate BB F - I don't like BB
        #variance.test.ksample.bartlett.box.fx()
         #present results as HTML table
         output<-HTML(paste(
         "</br></br><b><u>Dispersion Analysis</u></b></br>",
         "<table>",
         "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If normally distributed within cells</i></td><td style='text-align:left;background-color:#DCDCDC'><b>Calculation</b></td></tr>",
         "<tr><td style='text-align:left;'>",withMathJax("$\\text{Levene}$"),"</td><td style='text-align:left;'>",lev_df," = ",ro(lev_f,R),"</td><td></td><td style='text-align:left;'>p = ",ro(lev_p,R),if(lev_p<=1-conf){"*"}else{""},"</td><td style='text-align:left;'>",ada_type,"</td></tr>",
         "<tr><td colspan='4' style='text-align:left;background-color:#DCDCDC'><i>If not normally distributed within cells</i></td><td style='text-align:left;background-color:#DCDCDC'><b>Calculation</b></td></tr>",
         "<tr><td style='text-align:left;'>If n \U2264 10",withMathJax("$ADM$"),"</td><td style='text-align:left;'>",adm_df," = ",ro(adm_f,R),"</td><td></td><td style='text-align:left;'>p = ",ro(adm_p,R),if(adm_p<=1-conf){"*"}else{""},"</td><td style='text-align:left;'>",adm_type,"</td></tr>",
         "<tr><td style='text-align:left;'>If n > 10",withMathJax("$ADM_{n-1}$"),"</td><td style='text-align:left;'>",admn1_df," = ",ro(admn1_f,R),"</td><td></td><td style='text-align:left;'>p = ",ro(admn1_p,R),if(admn1_p<=1-conf){"*"}else{""},"</td><td style='text-align:left;'>",admn1_type,"</td></tr>",
         "</table>"))
         
       }
       if(type==3){output<-NULL}
       output
     })
     
     output$KW_out<-renderDT({
       data<- res_filter$filtered()
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       # conf<-input$conf_ow
       R<-input$decimal_ow
       # form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
       # type<-input$type_ow#1=fixed, 2=random, 3=K-W
       
       req(data_col)
       
       mean_rank_tab<-cbind(factor=data[factor_ow],data=data[data_col],rank=rank(data[data_col]))
       KW_tab<-ro(aggregate(x = mean_rank_tab,by=mean_rank_tab[1],FUN=function(x) c(Mean.Rank=mean(x),Count=length(x)))[c(-2,-3)],R)
       names(KW_tab)<-c(names(data)[factor_ow],"Mean Rank","Count")
       KW_tab
     })
     
     output$plotow<-renderPlot({plot_ow()})
     plotow_height<-reactive(400*4)
     plotow_width<-reactive(400*4)
     downloadServer('plotow', plot_ow,height = plotow_height,width = plotow_width)
     
     plot_ow<-reactive({#oneway plot
       conf<-input$conf_ow
       R<-input$decimal_ow_ph
       type<-input$type_ow
       #plot_l<-input$prof_plot_ow
       lines<-input$lines_ow_ph
       plot_type<-input$plot_type_ow_ph
       #ph_type<-input$ow_ph_type
       ph_details<-input$ow_ph_details
       data<-res_filter$filtered()
       req(data)
       names(data)<-make.names(names(data))
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       font_size<-as.numeric(input$ow_font_size)
       
       
       req(type)
       
       
       if (type==1 || type==4){#fixed
         req(plot_type)
         p<-ggplot(data=data,aes(x=.data[[names(data)[factor_ow]]],y=.data[[names(data)[data_col]]],group=.data[[names(data)[factor_ow]]]))+
           stat_summary(fun="mean", geom="point", size=4)+
           labs(caption = "Points are means")
         if(lines==T){#add lines
           p<-p+stat_summary(fun=mean, geom = "line", aes(group=1))
         }
         if(plot_type==2){#add violin
           p<-p+geom_violin(fill=adjustcolor(col = col_fill,alpha.f = .5),bw="sj")
         }
         if(plot_type==3){#boxplot
           p<-p+geom_boxplot(fill=adjustcolor(col = col_fill,alpha.f = .5))
         }
         
       }#end fixed
       
       if(type==2){#random

         form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
         
           oneway<-aov(formula = form,data = data)
           sum_aov<-summary(oneway)
           
           sse<-sum_aov[[1]][["Sum Sq"]][1]
           ssw<-sum_aov[[1]][["Sum Sq"]][2]
           dfe<-sum_aov[[1]][["Df"]][1]
           dfw<-sum_aov[[1]][["Df"]][2]
           mse<-sum_aov[[1]][["Mean Sq"]][1]
           msw<-sum_aov[[1]][["Mean Sq"]][2]
           sst<-sse+ssw
           dft<-dfe+dfw
           
           table_aov<-as.data.frame(table(data[factor_ow]))
           table_aov<-cbind(table_aov,table_aov[2]^2)
           J<-nrow(table_aov)
           sum_n<-colSums(table_aov[2])
           sum_nsq<-colSums(table_aov[3])
           K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
           
           bcv<-(mse-msw)/K_prime
           bcv<-max(0,bcv)
           ICC<-100*bcv/(bcv+msw)
           
           pop_mean<-mean(data[[data_col]])
           limits<-data.frame(x=c(pop_mean-2*bcv^.5-3*msw^.5,pop_mean,pop_mean+2*bcv^.5+3*msw^.5))
           colors<-c("Population of Means"=as.character(color[5]),"Unexplained Variability"=as.character(color[3]),"Unexplained Variability"=as.character(color[3]))
           effect_line<-c("95.45% Confidence Interval of Effect"=as.character(color[8]))
      
           p<-ggplot(data = limits,aes(x,fill=colors,color=effect_line))+
             ylab("PDF(x)")+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean,sd=bcv^.5),aes(fill="Population of Means"),color=color[1])+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean-2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean+2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             scale_fill_manual(values=colors)+
             scale_color_manual(values = effect_line,labels = function(x) str_wrap(x,width=10))
           
           ylim<-ggplot_build(p)[["layout"]][["panel_scales_y"]][[1]][["range"]][["range"]][2]
          
           
           p<-p+
             geom_segment(aes(x=pop_mean-2*bcv^.5,y=ylim/2,xend=pop_mean+2*bcv^.5,yend=ylim/2,color="95.45% Confidence Interval of Effect"),size=2)+
             labs(title="Random Effects Post-Hoc",fill=" ",color=" ")+
             theme(legend.position = "bottom")
         
       }#end random
       
       if(type==3){#kruskal-wallis - use medians
         req(plot_type)
         p<-ggplot(data=data,aes(x=.data[[names(data)[factor_ow]]],y=.data[[names(data)[data_col]]],group=.data[[names(data)[factor_ow]]]))+
           stat_summary(fun="median", geom="point", size=4)+
           labs(caption = "Points are medians")
         if(lines==T){#add lines
           p<-p+stat_summary(fun=median, geom = "line", aes(group=1))
         }
         if(plot_type==2){#add CI
           p<-p+geom_violin(fill=adjustcolor(col = col_fill,alpha.f = .5),bw="sj")
         }
         if(plot_type==3){#boxplot
           p<-p+geom_boxplot(fill=adjustcolor(col = col_fill,alpha.f = .5))
         }
       }
       
       p<-p+
         theme_gray(base_size = font_size)+#11 is default, but may be too small for some exports
         theme(legend.position = "bottom")+
         guides(color=guide_legend(nrow=2))+
         guides(fill=guide_legend(nrow=2))
       
       p
       
     })
     
     
     
     output$ow_ph_plot_type<-renderUI({#what type of plot
       type<-input$type_ow
       
       if(type==1 || type==3 || type==4){
         output<-radioButtons(inputId = "plot_type_ow_ph",label = "Choose plot type",choices = c("Points Only"=1,"Violin"=2,"Boxplot"=3))
       }
       if(type==2){
         output<-NULL
         }
       output
     })
     
     output$ow_ph_type<-renderUI({#what type of post hoc
       type<-input$type_ow
       
       if(type==1 || type==4){#fixed
         if(type==4){
           output<-radioButtons(inputId = "ow_ph_type",label = "Select Post-Hoc",choices = c("Tukey (equal variances)"=1,"Games & Howell(unequal variances)"=2),selected = 2)
         } else {
           output<-radioButtons(inputId = "ow_ph_type",label = "Select Post-Hoc",choices = c("Tukey (equal variances)"=1,"Games & Howell(unequal variances)"=2))
         }
         
       }
       if(type==2){#random
         output<-NULL
       }
       if(type==3){#K-W
         output<-radioButtons(inputId = "ow_ph_type",label = "Select Post-Hoc",choices = c("Wilcoxon-Mann-Whitney U"=3))
       }
       output
     })
     
     output$ow_ph_out_tab<-renderDataTable({
       conf<-input$conf_ow
       R<-input$decimal_ow_ph
       type<-input$type_ow
       #plot_l<-input$prof_plot_ow
       #lines<-input$lines_ow_ph
       #plot_type<-input$plot_type_ow_ph
       ph_type<-input$ow_ph_type
       ph_details<-input$ow_ph_details
       data<-res_filter$filtered()
       req(data)
       names(data)<-make.names(names(data))
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       
       req(type)
       
       form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
       oneway<-aov(formula = form,data = data)
       sum_aov<-summary(oneway)
       
       sse<-sum_aov[[1]][["Sum Sq"]][1]
       ssw<-sum_aov[[1]][["Sum Sq"]][2]
       dfe<-sum_aov[[1]][["Df"]][1]
       dfw<-sum_aov[[1]][["Df"]][2]
       mse<-sum_aov[[1]][["Mean Sq"]][1]
       msw<-sum_aov[[1]][["Mean Sq"]][2]
       sst<-sse+ssw
       dft<-dfe+dfw
       
       sum_stats<-as.data.frame(as.matrix(aggregate(data[data_col],by=data[factor_ow],FUN=function(x) c(mean(x),n=length(x),var=var(x)))))
       cell_means<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".",sep = "")])))
       cell_n<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".n",sep = "")])))
       cell_var<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".var",sep = "")])))
         
       if(type==1 || type==4){
         req(ph_type)
         if(ph_type==1){
         ph_test_results<-contrasts.tukey.kgroups.simple(group.label = sum_stats[[1]],
                                                         group.mean = cell_means,
                                                         group.sample.size = cell_n,
                                                         conf.level.familywise = conf,
                                                         #alternative = "two.sided",
                                                         mean.squared.error = msw,
                                                         df.mean.squared.error = dfw)
         output<-ph_test_results[["matrix.decision"]]
         output<-DT::datatable(output,caption="Tukey's HSD",
                               options=
                                 list(columnDefs=list(list(className='dt-center',targets='_all')),
                                      dom="t",
                                      ,paging=FALSE),
                                      class = 'cell-border stripe')
         }
       
         if(ph_type==2){
           ph_test_results<-contrasts.games.howell.kgroups.simple(group.label = sum_stats[[1]],
                                                                  group.mean = cell_means,
                                                                  group.variance = cell_var,
                                                                  group.sample.size = as.vector(as.matrix(cell_n)),
                                                                  conf.level.familywise = conf,
                                                                  #alternative = "two.sided",
                                                                  mean.squared.error = NA)#PHAST version
           output<-ph_test_results[["matrix.decision"]]
           output<-DT::datatable(output,caption="Games & Howell",options=list(columnDefs=list(list(className='dt-center',targets='_all')),dom="t",paging=FALSE),
                                 class = 'cell-border stripe')#should be long enough
           
         }
     }#end fixed
       if(type==2){
         table_aov<-as.data.frame(table(data[factor_ow]))
         table_aov<-cbind(table_aov,table_aov[2]^2)
         J<-nrow(table_aov)
         sum_n<-colSums(table_aov[2])
         sum_nsq<-colSums(table_aov[3])
         K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
         
         bcv<-(mse-msw)/K_prime
         bcv<-max(0,bcv)
         ICC<-100*bcv/(bcv+msw)
         
         Fu<-qf(p=(1-conf)/2,df1 = dfe,df2 = dfw,lower.tail = F)
         Fl<-qf(p=(1-conf)/2,df1 = dfe,df2 = dfw,lower.tail = T)
         thetal<-(1/K_prime)*((mse/(msw*Fu)-1))
         thetau<-(1/K_prime)*((mse/(msw*Fl)-1))
         
         lci<-100*(thetal/(1+thetal))
         uci<-100*(thetau/(1+thetau))
         
         title<-"Random Effect Importance"
         first_col<-c("Treatment Variance","Within Variance","Total Variance","Interclass Correlation",paste("ICC ",100*conf,"% Confidence Interval"))
         second_col<-as.vector(c(ro(bcv,R),ro(msw,R),ro(bcv+msw,R),paste(ro(ICC,R),"%"),paste(ro(lci,R),"%")))
         third_col<-c("","","","",paste(ro(uci,R),"%"))

         output<-cbind(" "=first_col," "=second_col," "=third_col)
         row.names(output)<-NULL
         datatable(output,colnames=rep("",ncol(output)))
         output<-DT::datatable(output,caption=title,options=list(columnDefs=list(list(className='dt-center',targets='_all')),dom="t",paging=FALSE),
                               class = 'cell-border stripe')
         
       }#end random
       
       if(type==3){#all pair-wise MWU
         combos<-factorial(dfe+1)/(factorial(2)*factorial(dfe-1))
         table_aov<-as.data.frame(table(data[factor_ow]))
         table_aov<-cbind(table_aov,table_aov[2]^2)
         J<-nrow(table_aov)
         form<-as.formula(paste(names(data)[data_col]," ~ ",names(data)[factor_ow]))
         mwu<-median.test.twosample.independent.mann.whitney.fx(fx = form,data = data)
         full_out=NULL
         for (i in seq(1:combos)){
           if(mwu[[i]][[5]]*combos>1){ mwu[[i]][[5]]<-1}
           else{mwu[[i]][[5]]<-mwu[[i]][[5]]*combos}
           full_out<-c(full_out,mwu[i])
         }
         output<-matrix("",J,J)
         rownames(output)<- unique(data[[factor_ow]])
         colnames(output)<- unique(data[[factor_ow]])
         loop=0
         for(i in seq(from=1,to=(J-1))){
           for(j in seq(from=(i+1),to=J)){
             loop=loop+1
             output[i,j]<-ifelse(full_out[[loop]][[5]]<(1-conf),"Reject","")
             output[j,i]<-ifelse(full_out[[loop]][[5]]<(1-conf),"Reject","")
           }
         }
         title="Kruskal-Wallis post-hoc: Wilcoxon-Mann-Whitney U using Bonferroni-Dunn (p-value multiplied by # comparisons). Compare stated p-value to desired familywise alpha."
         output<-datatable(output,caption=title,options=list(columnDefs=list(list(className='dt-center',targets='_all')),dom="t",paging=FALSE),
                           class = 'cell-border stripe')
         #output<-DT::datatable(output,caption=title,options=list(dom="t"))
       }#end K-W
         
         ro(output,R)
     })
     
     output$ow_ph_details<-renderPrint({
       conf<-input$conf_ow
       R<-input$decimal_ow_ph
       type<-input$type_ow
       #plot_l<-input$prof_plot_ow
       #lines<-input$lines_ow_ph
       #plot_type<-input$plot_type_ow_ph
       ph_type<-input$ow_ph_type
       ph_details<-input$ow_ph_details
       data<-res_filter$filtered()
       req(data)
       names(data)<-make.names(names(data))
       data_col<-as.numeric(input$ow_data)
       factor_ow<-as.numeric(input$ow_factor)
       
       req(ph_details==TRUE)
       #common anova info
       form<-as.formula(paste(names(data)[data_col]," ~ ","as.factor(",names(data)[factor_ow],")"))
       oneway<-aov(formula = form,data = data)
       sum_aov<-summary(oneway)
       
       sse<-sum_aov[[1]][["Sum Sq"]][1]
       ssw<-sum_aov[[1]][["Sum Sq"]][2]
       dfe<-sum_aov[[1]][["Df"]][1]
       dfw<-sum_aov[[1]][["Df"]][2]
       mse<-sum_aov[[1]][["Mean Sq"]][1]
       msw<-sum_aov[[1]][["Mean Sq"]][2]
       sst<-sse+ssw
       dft<-dfe+dfw
       
       combos<-factorial(dfe+1)/(factorial(2)*factorial(dfe-1))
       
       sum_stats<-as.data.frame(as.matrix(aggregate(data[data_col],by=data[factor_ow],FUN=function(x) c(mean(x),n=length(x),var=var(x)))))
       cell_means<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".",sep = "")])))
       cell_n<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".n",sep = "")])))
       cell_var<-as.numeric(as.vector(as.matrix(sum_stats[paste(names(data)[data_col],".var",sep = "")])))
       
       if(type==1 || type==4){
       if(ph_type==1){
         ph_test_results<-contrasts.tukey.kgroups.simple(group.mean = cell_means,
                                                         group.sample.size = cell_n,
                                                         conf.level.familywise = conf,
                                                         #alternative = "two.sided",
                                                         mean.squared.error = msw,
                                                         df.mean.squared.error = dfw)
         output<-NULL
         for (n in seq(1:combos)){
           output<-c(output,ph_test_results$list.tests[n])
         }
         
       }
       
       if(ph_type==2){
         ph_test_results<-contrasts.games.howell.kgroups.simple(group.mean = cell_means,
                                                                group.variance = cell_var,
                                                                group.sample.size = as.vector(as.matrix(cell_n)),
                                                                conf.level.familywise = conf,
                                                                #alternative = "two.sided",
                                                                mean.squared.error = NA)#PHAST version
         output<-NULL
         for (n in seq(1:combos)){
           output<-c(output,ph_test_results$list.tests[n])
         }
         
       
       }
       }#end fixed
       
       if(type==2){
         output="p-values multiplied by the number of combinations in order to maintain the family-wise alpha at your selected value"
       }
       if(type==3){
         form<-as.formula(paste(names(data)[data_col]," ~ ",names(data)[factor_ow]))
         mwu<-median.test.twosample.independent.mann.whitney.fx(fx = form,data = data)
         output=NULL
         for (n in seq(1:combos)){
           if(mwu[[n]][[5]]*combos>1){mwu[[n]][[5]]<-1}
           else{mwu[[n]][[5]]<-mwu[[n]][[5]]*combos}
           output<-c(output,mwu[n])
         }
         
         
       }#end K-W
       
       ro(output,R)
     })
     
     output$ui_bi1<-renderUI({
       one_or_two<-input$one_or_two_bi
       
       if(one_or_two==1){
         output<-numericInput(inputId = "biUI1",label = "R",value = 3,min = 0,step = 1,width = "75px")
       }
       if(one_or_two==2){
         output<-numericInput(inputId = "biUI1",label = "Lower R",value = 3,min = 0,step = 1,width = "75px")
       }
       output
     })
     output$ui_bi2<-renderUI({
       one_or_two<-input$one_or_two_bi
       
       if(one_or_two==1){
         output<-NULL
       }
       if(one_or_two==2){
         output<-numericInput(inputId = "biUI2",label = "Upper R",value = 8,min = 0,step = 1,width = "75px")
       }
       output
     })
     
     output$ui_bi3<-renderUI({#include lower R in calculation?
       enterR<-input$r_bi
       if(!enterR){output<-NULL}
       
       else{
         output<- radioButtons(inputId = "bi_low_inc",label = "Include R?",choices=c("\U2264"=1,"<"=2))
       }
       
       output
     })
     
     output$ui_bi4<-renderUI({#include lower R in calculation?
       one_or_two<-input$one_or_two_bi
       if(one_or_two == 1){output<-NULL}
       
       else{
         output<- radioButtons(inputId = "bi_hi_inc",label = "Include R?",choices=c("\U2265"=1,">"=2))
       }
       
       output
     })
     
     output$ui_po1<-renderUI({
       one_or_two<-input$one_or_two_po
       
       if(one_or_two==1){
         output<-numericInput(inputId = "poUI1",label = "X",value = 3,min = 0,step = 1,width = "75px")
       }
       if(one_or_two==2){
         output<-numericInput(inputId = "poUI1",label = "Lower X",value = 3,min = 0,step = 1,width = "75px")
       }
       output
     })
     output$ui_po2<-renderUI({
       one_or_two<-input$one_or_two_po
       
       if(one_or_two==1){
         output<-NULL
       }
       if(one_or_two==2){
         output<-numericInput(inputId = "poUI2",label = "Upper X",value = 8,min = 0,step = 1,width = "75px")
       }
       output
     })
     
     output$ui_po3<-renderUI({
       enterX<-input$r_po
       
       if(!enterX){output<-NULL}
       else{
         output<- radioButtons(inputId = "po_low_inc",label = "Include X?",choices=c("\U2264"=1,"<"=2))
       }
       output
     })
     
     output$ui_po4<-renderUI({
       one_or_two<-input$one_or_two_po
       if(one_or_two == 1){output<-NULL}
       
       else{
         output<- radioButtons(inputId = "po_hi_inc",label = "Include X?",choices=c("\U2265"=1,">"=2))
       }
       
       output
     })
     
     output$ui_exp1<-renderUI({
       tails<-input$tails_exp
       
       if(tails==1){
         output<-numericInput(inputId = "tail_exp",
                      label = "Point of Interest",
                      value = 10,
                      width = "100px")
       }
       if(tails==2){
         output<-numericInput(inputId = "tail_exp",
                      label = "Lower Tail",
                      value = 10,
                      width = "100px")
       }
       output
     })
     output$ui_exp2<-renderUI({
       tails<-input$tails_exp
       
       if(tails==1){
         output<-NULL
       }
       if(tails==2){
         output<-numericInput(inputId = "tailu_exp",
                              label = "Upper Tail",
                              value = 200,
                              width = "100px")
       }
       output
     })
     output$ui_exp3<-renderUI({
       tails<-input$tails_exp
       
       if(tails==1){
         output<-radioButtons(inputId = "exp_interest",label = "Lower or Upper Tail?",choices = c("Lower"=1,"Upper"=2))
       }
       
       if(tails==2){
         output<-radioButtons(inputId = "exp_interest",label = "Area between or outside of points?",choices = c("Inside"=1,"Outside"=2))
       }
       output
     })
     
     #Poisson exact power function
     #after Arpan Das and Wendy Bailey
     power.count.poisson.onesample.exact <- function(lambda_0, lambda_1, n, alpha = 0.05,alternative=c("two.sided","less","greater")){
       if(!is.finite(n)){return()}
       if(lambda_0==lambda_1){return(data.frame(c(error_message="Rates cannot be equal")))}
       if(alternative=="less"){
         if(lambda_1>=lambda_0){
           output<-data.frame(c(error_message="Alternative must be less than null"))
           return(output)
         }
         df <- table.dist.poisson(lambda_0*n)
         df.with.index <- mutate(df, IDX = 1:n())
         result <- data.frame(filter(df.with.index,(eq.and.below <= alpha))$IDX)
         df2 <- table.dist.poisson(lambda_1*n)
         power <- df2$eq.and.below[length(result$filter.df.with.index...eq.and.below....alpha...IDX)-1]
         
         #Critical Xs
         crit_x_l<-qpois(p = alpha,lambda = n*lambda_0,lower.tail = T)-1
         alpha_r<-ppois(q = crit_x_l,lambda = n*lambda_0,lower.tail = T)
         output<-data.frame(c(alpha=alpha_r,power=power,crti_x_l=crit_x_l))
         
         return(output)
       }
       
       if(alternative=="greater"){
         if(lambda_1<=lambda_0){
           output<-data.frame(c(error_message="Alternative must be greater than null"))
           return(output)
         }
         df <- table.dist.poisson(lambda_0*n)
         df.with.index <- mutate(df, IDX = 1:n())
         result <- data.frame(filter(df.with.index,(eq.and.above <= alpha))$IDX)
         df2 <- table.dist.poisson(lambda_1*n)
         power <- df2$eq.and.above[min(result$filter.df.with.index...eq.and.above....alpha...IDX)+1]
         
         #Critical Xs
         crit_x_u<-qpois(p = 1-alpha,lambda = n*lambda_0,lower.tail = T)+1
         alpha_r<-ppois(q = (crit_x_u-1),lambda = n*lambda_0,lower.tail = F)
         #print(alpha_r)
         output<-data.frame(c(alpha=alpha_r,power=power,crit_x_u=crit_x_u))
         
         return(output)
       }
       
       if(alternative=="two.sided"){
         if (lambda_0 > lambda_1){
           df <- table.dist.poisson(lambda_0*n)
           df.with.index <- mutate(df, IDX = 1:n())
           alpha2<-alpha/2
           result <- data.frame(filter(df.with.index,(eq.and.below <= alpha2))$IDX)
           df2 <- table.dist.poisson(lambda_1*n)
           power1 <- df2$eq.and.below[length(result$filter.df.with.index...eq.and.below....alpha2...IDX)-1]
           
           
         }
         
         else 
           df <- table.dist.poisson(lambda_0*n)
         df.with.index <- mutate(df, IDX = 1:n())
         alpha2<-alpha/2
         result <- data.frame(filter(df.with.index,(eq.and.above <= alpha2))$IDX)
         df2 <- table.dist.poisson(lambda_1*n)
         power2 <- df2$eq.and.above[min(result$filter.df.with.index...eq.and.above....alpha2...IDX)+1]
         
         if(lambda_0 > lambda_1) {
           #Critical Xs
           crit_x_l<-qpois(p = alpha/2,lambda = n*lambda_0,lower.tail = T)-1
           crit_x_u<-qpois(p = 1-(alpha/2),lambda = n*lambda_0,lower.tail = T)+1
           
           alpha_r<-ppois(q = crit_x_l,lambda = n*lambda_0,lower.tail = T)
           alpha_r<-alpha_r+ppois(q = crit_x_u-1,lambda = n*lambda_0,lower.tail = F)
           
           output<-data.frame(c(alpha=alpha_r,power=power1,crit_x_l=crit_x_l,crit_x_u=crit_x_u))
           
           return(output)
         }
         
         
         #   return(output)
         # }
         if(lambda_0 < lambda_1) {
           #Critical Xs
           crit_x_l<-qpois(p = alpha/2,lambda = n*lambda_0,lower.tail = T)-1
           crit_x_u<-qpois(p = 1-(alpha/2),lambda = n*lambda_0,lower.tail = T)+1
           
           alpha_r<-ppois(q = crit_x_l,lambda = n*lambda_0,lower.tail = T)
           alpha_r<-alpha_r+ppois(q = crit_x_u,lambda = n*lambda_0,lower.tail = F)
           
           output<-data.frame(c(alpha=alpha_r,power=power2,crit_x_l=crit_x_l,crit_x_u=crit_x_u))
           
           return(output)
         }
       }
     }
     
     
     sample.size.count.poisson.onesample.exact<-function(lambda_0, lambda_1, alpha = 0.05, beta=0.10, alternative=c("two.sided","less","greater")){
       if(lambda_0==lambda_1){return(data.frame(c(error_message="Rates cannot be equal")))}
       if(alternative=="less"){
         if(lambda_1>=lambda_0){
           output<-data.frame(c(error_message="Alternative must be less than null"))
           return(output)
         }}
       if(alternative=="greater"){
         if(lambda_1<=lambda_0){
           output<-data.frame(c(error_message="Alternative must be greater than null"))
           return(output)
         }
       }
       n<-sample.size.count.poisson.onesample.approximate(lambda.null.hypothesis = lambda_0,lambda.alternative.hypothesis = lambda_1,alpha = alpha,beta = beta,alternative = alternative,details = FALSE)
       #n<-start$sample.size
       pow<-power.count.poisson.onesample.exact(lambda_0=lambda_0,lambda_1=lambda_1,n=n,alpha=alpha,alternative=alternative)
       beta_this<-1-pow["power",]
       #print(paste("n = ",n," beta_this = ",beta_this))
       while(beta_this>beta){
         n<-n+1
         pow<-power.count.poisson.onesample.exact(lambda_0=lambda_0,lambda_1=lambda_1,n=n,alpha=alpha,alternative=alternative)
         beta_this<-1-pow["power",]
         #print(paste("loop n = ",n," beta_this = ",beta_this))
       }
       
       #Critical Xs
       crit_x_l<-NULL
       crit_x_u<-NULL
       
       if(alternative=="less"){
         crit_x_l<-qpois(p = alpha,lambda = n*lambda_0,lower.tail = T)-1
         alpha_r<-ppois(q = crit_x_l,lambda = n*lambda_0,lower.tail = T)
       }
       if(alternative=="greater"){
         crit_x_u<-qpois(p = 1-alpha,lambda = n*lambda_0,lower.tail = T)+1
         alpha_r<-ppois(q = (crit_x_u-1),lambda = n*lambda_0,lower.tail = F)
       }
       if(alternative=="two.sided"){
         crit_x_l<-qpois(p = alpha/2,lambda = n*lambda_0,lower.tail = T)-1
         crit_x_u<-qpois(p = 1-(alpha/2),lambda = n*lambda_0,lower.tail = T)+1
         alpha_r<-ppois(q = (crit_x_u-1),lambda = n*lambda_0,lower.tail = F)
         alpha_r<-alpha_r+ppois(q = crit_x_l,lambda = n*lambda_0,lower.tail = T)
       }
       
       output<-data.frame(c(alpha=alpha_r,power=1-beta_this,n=n,crit_x_l=crit_x_l,crit_x_u=crit_x_u))
       
       return(output)
     }
     
     ##########two sample Poisson power using Mathews(2010) square root transform
     
     power.count.poisson.twosample.approximate<-function(lambda_1, lambda_2, n1, n2, alpha = 0.05, alternative=c("two.sided","less","greater")){
       
       if(alternative=="two.sided"){
         if(lambda_1>lambda_2){
           lambda_sm<-lambda_1
           lambda_bg<-lambda_2
         }else {
           lambda_sm<-lambda_2
           lambda_bg<-lambda_1
         }
         z_power<-(
           (sqrt(lambda_sm) - sqrt(lambda_bg))/
             (.5*sqrt(n1^-1 + n2^-1))
         )-
           qnorm(p = (1-alpha/2),mean = 0,sd = 1,lower.tail = T)
         #print(z_power)
         power_out<-pnorm(q = z_power,mean = 0,sd = 1,lower.tail = T)
       }
       
       if(alternative=="greater"){
         if(lambda_2<lambda_1){
           output<-data.frame(c(error_message="Alternative must be greater than null"))
           return(output)
         }
         z_power<-(
           (sqrt(lambda_2) - sqrt(lambda_1))/
             (.5*sqrt(n1^-1 + n2^-1))
         )-
           qnorm(p = (1-alpha),mean = 0,sd = 1,lower.tail = T)
         #print(z_power)
         power_out<-pnorm(q = z_power,mean = 0,sd = 1,lower.tail = T)
         
         
       }
       if(alternative=="less"){
         if(lambda_2>lambda_1){
           output<-data.frame(c(error_message="Alternative must be less than null"))
           return(output)
         }
         z_power<-(
           (sqrt(lambda_1) - sqrt(lambda_2))/
             (.5*sqrt(n1^-1 + n2^-1))
         )-
           qnorm(p = (1-alpha),mean = 0,sd = 1,lower.tail = T)
         #print(z_power)
         power_out<-pnorm(q = z_power,mean = 0,sd = 1,lower.tail = T)
         
       }
       
       return(power_out)
     }
     sample.size.count.poisson.twosample.approximate<-function(lambda_1, lambda_2, alpha = 0.05, beta=0.10, alternative=c("two.sided","less","greater")){
       if(lambda_1==lambda_2){return(data.frame(c(error_message="Rates cannot be equal")))}
       if(alternative=="less"){
         if(lambda_2>=lambda_1){
           output<-data.frame(c(error_message="Alternative must be less than null"))
           return(output)
         }}
       if(alternative=="greater"){
         if(lambda_2<=lambda_1){
           output<-data.frame(c(error_message="Alternative must be greater than null"))
           return(output)
         }
       }
       n<-sample.size.count.poisson.onesample.approximate(lambda.null.hypothesis = lambda_1,lambda.alternative.hypothesis = lambda_2,alpha = alpha,beta = beta,alternative = alternative,details = FALSE)
       #n<-start$sample.size
       pow<-power.count.poisson.twosample.approximate(lambda_1=lambda_1,lambda_2=lambda_2,n1=n, n2=n,alpha=alpha,alternative=alternative)
       beta_this<-1-pow
       #print(paste("n = ",n," beta_this = ",beta_this))
       while(beta_this>beta){
         n<-n+1
         pow<-power.count.poisson.twosample.approximate(lambda_1=lambda_1,lambda_2=lambda_2,n1=n,n2=n,alpha=alpha,alternative=alternative)
         beta_this<-1-pow
         #print(paste("loop n = ",n," beta_this = ",beta_this))
       }
       output<-data.frame(c(power=1-beta_this,n=n))
       
       return(output)
     }
     
     output$x_bar_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$x_bar_lim_stat)
       x_bar<-as.numeric(input$x_bar_lim_x_bar)
       stat<-as.numeric(input$x_bar_lim_val)
       n<-as.numeric(input$x_bar_lim_n)
       sterr<-as.numeric(input$x_bar_lim_sterr)
       R<-input$x_bar_lim_decimals
       
       if(select==1){
         A2<-spc.constant.calculation.A2(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         UCL<-ro(x_bar+A2*stat,R)
         LCL<-ro(x_bar-A2*stat,R)
         sig_est<-ro(stat/d2,R)
       }
       if(select==2){
         A2<-spc.constant.calculation.A4(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d4(sample.size = n)
         UCL<-ro(x_bar+A2*stat,R)
         LCL<-ro(x_bar-A2*stat,R)
         sig_est<-ro(stat/d2,R)
       }
       if(select==3){
         A3<-spc.constant.calculation.A3(sample.size = n,n.sigma = sterr)
         c4<-spc.constant.calculation.c4(sample.size = n)
         UCL<-ro(x_bar+A3*stat,R)
         LCL<-ro(x_bar-A3*stat,R)
         sig_est<-ro(stat/c4,R)
       }
       if(select==4){#median stdev
         A10<-sterr/(c6(n)*sqrt(n))
         UCL<-ro(x_bar+A10*stat,R)
         LCL<-ro(x_bar-A10*stat,R)
         sig_est<-ro(stat/c6(n),R)
         
       }
       if(select==5){
         UCL<-ro(x_bar+3*sqrt(stat)/sqrt(n),R)
         LCL<-ro(x_bar-3*sqrt(stat)/sqrt(n),R)
         sig_est<-ro(stat^.5,R)
       }
       if(select==6){
         d2<-spc.constant.calculation.d2(sample.size = 2)
         sig_est_b<-ro(stat/d2,R)
         UCL<-ro(x_bar+sterr*stat/d2,R)
         LCL<-ro(x_bar-sterr*stat/d2,R)
         sig_est<-ro(stat/d2*sqrt(n),R)
         
       }
       if(select==7){
         d2<-spc.constant.calculation.d4(sample.size = 2)
         sig_est_b<-ro(stat/d2,R)
         UCL<-ro(x_bar+sterr*stat/d2,R)
         LCL<-ro(x_bar-sterr*stat/d2,R)
         sig_est<-ro(stat/d2*sqrt(n),R)
       }
       if(select==8){
         UCL<-ro(x_bar+sterr*stat,R)
         LCL<-ro(x_bar-sterr*stat,R)
         sig_est<-ro(stat*sqrt(n),R)
       }
       if(select==9){
         sig_est<-ro(stat,R)
         UCL<-ro(x_bar+sterr*stat/sqrt(n),R)
         LCL<-ro(x_bar-sterr*stat/sqrt(n),R)
         }
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$\\bar{X}$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_x_bar_limits)[select]," = ",ro(stat,R),"<br>"),
         if(select==6 || select==7){"Assuming Moving Ranges are calculated from two means<br>"},
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
          "<td>",paste(withMathJax("$UCL=$")),"</td>",
          "<td align='left'>",UCL,"</td>",
          "<td></td>",
          "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>",
          "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
          "<td>",paste(withMathJax("$\\overline{\\overline{X}}=$")),"</td>",
          "<td align='left'>",ro(x_bar,R),"</td>",
          "<td></td>",
          "<td>",paste(withMathJax("$n=$")),"</td>",
          "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
          "<td>",paste(withMathJax("$LCL =$")),"</td>",
          "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
         
       )#end html
       
       output
     })
     
     output$x_bar_lim_value<-renderUI({
       select<-input$x_bar_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\bar{R}:$"),value = 2,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\widetilde{R}:$"),value = 2,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\bar{s}:$"),value = 2,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\widetilde{s\\,}:$"),value = 2,width = "75px")
       }
       if(select==5){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\overline{s^{2}}:$"),value = 2,width = "75px")
       }
       if(select==6){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\overline{X}_{MR_\\widetilde{\\,X\\,}}:$"),value = 2,width = "75px")
       }
       if(select==7){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\widetilde{X}_{MR_\\bar{X}}:$"),value = 2,width = "75px")
       }
       if(select==8){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$s_{\\bar{X}}:$"),value = 2,width = "75px")
       }
       if(select==9){
         output<-numericInput(inputId = "x_bar_lim_val",label = withMathJax("$\\sigma:$"),value = 2,width = "75px")
       }
       
       output
     })
     
     output$x_tilde_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$x_tilde_lim_stat)
       x_bar<-as.numeric(input$x_tilde_lim_x_bar)
       stat<-as.numeric(input$x_tilde_lim_val)
       n<-as.numeric(input$x_tilde_lim_n)
       sterr<-as.numeric(input$x_tilde_lim_sterr)
       R<-input$x_tilde_lim_decimals
       
       if(select==1){
         A4<-spc.constant.calculation.A4(sample.size = n,n.sigma = sterr)#not right need constant for average range on median chart
         d2<-spc.constant.calculation.d2(sample.size = n)
         UCL<-ro(x_bar+A4*stat,R)
         LCL<-ro(x_bar-A4*stat,R)
         sig_est<-ro(stat/d2,R)#correct
       }
       if(select==2){
         A4<-spc.constant.calculation.A4(sample.size = n,n.sigma = sterr)#not right need constant for median 
         d4<-spc.constant.calculation.d4(sample.size = n)
         UCL<-ro(x_bar+A4*stat,R)
         LCL<-ro(x_bar-A4*stat,R)
         sig_est<-ro(stat/d4,R)#correct
       }
       if(select==3){
         A3<-spc.constant.calculation.A3(sample.size = n,n.sigma = sterr)#not right need constant for average s on median
         c4<-spc.constant.calculation.c4(sample.size = n)
         UCL<-ro(x_bar+A3*stat,R)
         LCL<-ro(x_bar-A3*stat,R)
         sig_est<-ro(stat/c4,R)#correct
       }
       if(select==4){#median stdev
         A10<-sterr/(c6(n)*sqrt(n))#not right need constant for median
         UCL<-ro(x_bar+A10*stat,R)
         LCL<-ro(x_bar-A10*stat,R)
         sig_est<-ro(stat/c6(n),R)#correct
         
       }
       if(select==5){
         UCL<-ro(x_bar+3*sqrt(stat)/sqrt(n),R)#not right need constant for median
         LCL<-ro(x_bar-3*sqrt(stat)/sqrt(n),R)
         sig_est<-ro(stat^.5,R)#correct
       }
       if(select==6){
         d2<-spc.constant.calculation.d2(sample.size = 2)
         sig_est_b<-ro(stat/d2,R)
         UCL<-ro(x_bar+sterr*stat/d2,R)#not right
         LCL<-ro(x_bar-sterr*stat/d2,R)
         sig_est<-ro(stat/d2*sqrt(n),R)#not right
         
       }
       if(select==7){
         d2<-spc.constant.calculation.d4(sample.size = 2)#not right
         sig_est_b<-ro(stat/d2,R)
         UCL<-ro(x_bar+sterr*stat/d2,R)#not right
         LCL<-ro(x_bar-sterr*stat/d2,R)
         sig_est<-ro(stat/d2*sqrt(n),R)#not right
       }
       if(select==8){
         UCL<-ro(x_bar+sterr*stat,R)#not right
         LCL<-ro(x_bar-sterr*stat,R)
         sig_est<-ro(stat*sqrt(n),R)#not right
       }
       if(select==9){
         sig_est<-ro(stat,R)
         UCL<-ro(x_bar+sterr*stat/sqrt(n),R)#not right
         LCL<-ro(x_bar-sterr*stat/sqrt(n),R)
       }
       
       
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$\\bar{X}$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_x_bar_limits)[select]," = ",ro(stat,R),"<br>"),
         if(select==6 || select==7){"Assuming Moving Ranges are calculated from two means<br>"},
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$\\overline{\\overline{X}}=$")),"</td>",
         "<td align='left'>",ro(x_bar,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     output$x_tilde_lim_value<-renderUI({
       select<-input$x_tilde_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\bar{R}:$"),value = 2,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\widetilde{R}:$"),value = 2,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\bar{s}:$"),value = 2,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\widetilde{s\\,}:$"),value = 2,width = "75px")
       }
       if(select==5){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\overline{s^{2}}:$"),value = 2,width = "75px")
       }
       if(select==6){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\overline{X}_{MR_\\bar{X}}:$"),value = 2,width = "75px")
       }
       if(select==7){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\widetilde{X}_{MR_\\bar{X}}:$"),value = 2,width = "75px")
       }
       if(select==8){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$s_{\\bar{X}}:$"),value = 2,width = "75px")
       }
       if(select==9){
         output<-numericInput(inputId = "x_tilde_lim_val",label = withMathJax("$\\sigma:$"),value = 2,width = "75px")
       }
       
       output
     })
     
     c6<-function(sample.size=5){#lookup table function for c6 used for median standard deviations
       c6_tab<-c(.674489524,.832554611,.888064165,.9160641325,.932894441,.944115161,.952126282,.958131091,.962798738,.966530795,.969582762,.972124923,.974275110,.976117460,.977713643,.979109892,.980341548,.981436090,.982415200,.983296223,.984093190,.984817583,.985478882,.986084984,.988487644,.990182489,.991442675,.992416146,.993190756,.993821792,.994345788,.994787849,.995165799,.995492642,.995778088,.996029532,.996252710,.996631404)
       c6_tab<-cbind(value=c6_tab,n=c(2:25,30,35,40,45,50,55,60,65,70,75,80,85,90,100))
       n<-which(abs(c6_tab[,2]-sample.size)==min(abs(c6_tab[,2]-sample.size)))
       c6_tab[n]
     }
     
     MR_span<-function(data=NULL,span=2){#calculate the moving range across a designated span
       n<-length(data)
       mr<-NULL
       loops<-seq(n-span+1)
       for (i in loops){
         low<-i
         high<-span+i-1
         mr[i]<-max(data[low:high])-min(data[low:high])
       }
       return(c(rep(NA,span-1),mr))
     }
     
     output$x_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$x_lim_stat)
       x_bar<-as.numeric(input$x_lim_x_bar)
       stat<-as.numeric(input$x_lim_val)
       n<-as.numeric(input$x_lim_n)
       sterr<-as.numeric(input$x_lim_sterr)
       R<-input$x_lim_decimals
       
       if(select==1){
         d2<-spc.constant.calculation.d2(sample.size = n)
         sig_est_b<-ro(stat/d2,R)
         UCL<-ro(x_bar+sterr*stat/d2,R)
         LCL<-ro(x_bar-sterr*stat/d2,R)
         sig_est<-ro(stat/d2,R)
       }
       if(select==2){
         #A4<-spc.constant.calculation.A4(sample.size = n,n.sigma = sterr)
         d4<-spc.constant.calculation.d4(sample.size = n)
         sig_est<-ro(stat/d4,R)
         UCL<-ro(x_bar+sterr*stat/d4,R)
         LCL<-ro(x_bar-sterr*stat/d4,R)
         }
       if(select==3){
         c4<-spc.constant.calculation.c4(sample.size = n)
         sig_est<-ro(stat/c4,R)
         UCL<-ro(x_bar+sterr*stat/c4,R)
         LCL<-ro(x_bar-sterr*stat/c4,R)
         
       }
       if(select==4){
         sig_est<-ro(stat,R)
         UCL<-ro(x_bar+sterr*stat,R)
         LCL<-ro(x_bar-sterr*stat,R)
       }
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$X$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_x_limits)[select]," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         if(select<4){
           paste(
             "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>"
             )
           } else (paste("<td>",paste(withMathJax("$\\sigma=$")),"</td>"))
         ,
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$\\bar{X}=$")),"</td>",
         "<td align='left'>",ro(x_bar,R),"</td>",
         "<td></td>",
         if(select==4){""}#get the right label
           else{
             paste("<td>",
                   if(select==1 || select ==2){
                     paste(withMathJax("$n_{MR}=$"))
                           }
                   else {
                     paste(withMathJax("$s_{k}=$"))
                     },
                   "</td>",
                   "<td align='left'>",n,"</td>")
           }
         ,
         "</tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     output$x_lim_value<-renderUI({
       select<-input$x_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "x_lim_val",label = withMathJax("$\\overline{MR}:$"),value = 5,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "x_lim_val",label = withMathJax("$\\widetilde{MR}:$"),value = 5,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "x_lim_val",label = withMathJax("$s_{k}:$"),value = 5,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "x_lim_val",label = withMathJax("$\\sigma:$"),value = 5,width = "75px")
       }
       
       
       output
     })
     
     output$x_lim_n_UI<-renderUI({
       select<-input$x_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "x_lim_n",label = withMathJax("$n_{MR}:$"),value = 2,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "x_lim_n",label = withMathJax("$n_{MR}:$"),value = 2,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "x_lim_n",label = withMathJax("$k_{s}:$"),value = 2,width = "75px")
       }
       if(select==4){
         output<-NULL
       }
       
       output
     })
     
     
     
     output$r_lim_value<-renderUI({
       select<-input$r_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\bar{R}:$"),value = 5,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\widetilde{R}:$"),value = 5,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\bar{s}:$"),value = 5,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\widetilde{s\\,}:$"),value = 5,width = "75px")
       }
       if(select==5){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\bar{s^{2}}:$"),value = 5,width = "75px")
       }
       if(select==6){
         output<-numericInput(inputId = "r_lim_val",label = withMathJax("$\\sigma:$"),value = 5,width = "75px")
       }
       
       
       output
     })
     
     
     output$r_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$r_lim_stat)
       #r_bar<-as.numeric(input$r_lim_x_bar)
       stat<-as.numeric(input$r_lim_val)
       n<-as.numeric(input$r_lim_n)
       sterr<-as.numeric(input$r_lim_sterr)
       R<-input$r_lim_decimals
       
       if(select==1){
         D3<-spc.constant.calculation.D3(sample.size = n,n.sigma = sterr)
         D4<-spc.constant.calculation.D4(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         UCL<-ro(D4*stat,R)
         LCL<-ro(D3*stat,R)
         sig_est<-ro(stat/d2,R)
         r_center<-stat
         stat_symb<-withMathJax("$\\bar{R}=$")
       }
       if(select==2){
         D5<-spc.constant.calculation.D5(sample.size = n,n.sigma = sterr)
         D6<-spc.constant.calculation.D6(sample.size = n,n.sigma = sterr)
         d4<-spc.constant.calculation.d4(sample.size = n)
         UCL<-ro(D6*stat,R)
         LCL<-ro(D5*stat,R)
         sig_est<-ro(stat/d4,R)
         r_center<-ro(stat*spc.constant.calculation.d2(sample.size = n)/d4,R)
         stat_symb<-withMathJax("$\\bar{R}_{est}=$")
       }
       if(select==3){
         c4<-spc.constant.calculation.c4(sample.size = n)
         d2<-spc.constant.calculation.d2(sample.size = n)
         D4<-spc.constant.calculation.D4(sample.size = n,n.sigma = sterr)
         D3<-spc.constant.calculation.D3(sample.size = n,n.sigma = sterr)
         sig_est<-stat/c4
         r_center<-sig_est*d2
         UCL<-ro(r_center*D4,R)
         LCL<-ro(r_center*D3,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{R}_{est}=$")
         
       }
       if(select==4){
         c6<-c6(n)
         D4<-spc.constant.calculation.D4(sample.size = n,n.sigma = sterr)
         D3<-spc.constant.calculation.D3(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         sig_est<-stat/c6
         r_center<-stat*d2/c6
         UCL<-ro(r_center*D4,R)
         LCL<-ro(r_center*D3,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{R}_{est}=$")
         
       }
       if(select==5){
         D4<-spc.constant.calculation.D4(sample.size = n,n.sigma = sterr)
         D3<-spc.constant.calculation.D3(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         sig_est<-sqrt(stat)
         r_center<-sig_est*d2
         UCL<-ro(r_center*D4,R)
         LCL<-ro(r_center*D3,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{R}_{est}=$")
         
       }
       if(select==6){
         D4<-spc.constant.calculation.D4(sample.size = n,n.sigma = sterr)
         D3<-spc.constant.calculation.D3(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         sig_est<-stat
         r_center<-sig_est*d2
         UCL<-ro(r_center*D4,R)
         LCL<-ro(r_center*D3,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{R}_{est}=$")
         
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$R$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_r_limits)[select]," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(r_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ###s
     output$s_lim_value<-renderUI({
       select<-input$s_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\bar{R}:$"),value = 5,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\widetilde{R}:$"),value = 5,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\bar{s}:$"),value = 5,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\widetilde{s\\,}:$"),value = 5,width = "75px")
       }
       if(select==5){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\bar{s^{2}}:$"),value = 5,width = "75px")
       }
       if(select==6){
         output<-numericInput(inputId = "s_lim_val",label = withMathJax("$\\sigma:$"),value = 5,width = "75px")
       }
       
       
       output
     })
     
     
     output$s_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$s_lim_stat)
       #r_bar<-as.numeric(input$r_lim_x_bar)
       stat<-as.numeric(input$s_lim_val)
       n<-as.numeric(input$s_lim_n)
       sterr<-as.numeric(input$s_lim_sterr)
       R<-input$s_lim_decimals
       
       if(select==1){
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         d2<-spc.constant.calculation.d2(sample.size = n)
         c4<-spc.constant.calculation.c4(sample.size = n)
         sig_est<-stat/d2
         s_center<-sig_est*c4
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}_{est}=$")
       }
       if(select==2){
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         d4<-spc.constant.calculation.d4(sample.size = n)
         c4<-spc.constant.calculation.c4(sample.size = n)
         
         sig_est<-stat/d4
         s_center<-sig_est*c4
           
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}_{est}=$")
       }
       if(select==3){
         c4<-spc.constant.calculation.c4(sample.size = n)
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         
         sig_est<-stat/c4
         s_center<-stat
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}=$")
         
       }
       if(select==4){
         c6<-c6(n)
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         c4<-spc.constant.calculation.c4(sample.size = n)
         
         sig_est<-stat/c6
         s_center<-sig_est*c4
           
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}_{est}=$")
         
       }
       if(select==5){
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         c4<-spc.constant.calculation.c4(sample.size = n)
         
         sig_est<-sqrt(stat)
         s_center<-sig_est*c4
         
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}_{est}=$")
         
       }
       if(select==6){
         B3<-spc.constant.calculation.B3(sample.size = n,n.sigma = sterr)
         B4<-spc.constant.calculation.B4(sample.size = n,n.sigma = sterr)
         c4<-spc.constant.calculation.c4(sample.size = n)
         
         sig_est<-stat
         s_center<-sig_est*c4
         UCL<-ro(B4*s_center,R)
         LCL<-ro(B3*s_center,R)
         s_center<-ro(s_center,R)
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s}_{est}=$")
         
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$s$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_r_limits)[select]," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(s_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ###var
     output$s2_lim_value<-renderUI({
       select<-input$s2_lim_stat
       
       if(select==1){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\bar{R}:$"),value = 5,width = "75px")
       }
       if(select==2){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\widetilde{R}:$"),value = 5,width = "75px")
       }
       if(select==3){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\bar{s}:$"),value = 5,width = "75px")
       }
       if(select==4){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\widetilde{s\\,}:$"),value = 5,width = "75px")
       }
       if(select==5){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\bar{s^{2}}:$"),value = 5,width = "75px")
       }
       if(select==6){
         output<-numericInput(inputId = "s2_lim_val",label = withMathJax("$\\sigma:$"),value = 5,width = "75px")
       }
       
       
       output
     })
     
     
     output$s2_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$s2_lim_stat)
       stat<-as.numeric(input$s2_lim_val)
       n<-as.numeric(input$s2_lim_n)
       sterr<-as.numeric(input$s2_lim_sterr)
       R<-input$s2_lim_decimals
       
       if(select==1){
         
         d2<-spc.constant.calculation.d2(sample.size = n)
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         sig_est<-stat/d2
         s_center<-sig_est^2
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro((sig_est*spc.constant.calculation.c4(sample.size = n))^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}_{est}=$")
       }
       if(select==2){
         
         d4<-spc.constant.calculation.d4(sample.size = n)
         sig_est<-stat/d4
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         s_center<-sig_est^2
         
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro((sig_est*spc.constant.calculation.c4(sample.size = n))^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}_{est}=$")
       }
       if(select==3){
         c4<-spc.constant.calculation.c4(sample.size = n)
         sig_est<-stat/c4
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         s_center<-sig_est^2#
         
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro(sig_est^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}_{est}=$")
         
       }
       if(select==4){
         c6<-c6(n)
         sig_est<-stat/c6
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         s_center<-sig_est^2
         
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro((sig_est*spc.constant.calculation.c4(sample.size = n))^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}_{est}=$")
         
       }
       if(select==5){
         sig_est<-sqrt(stat)
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         s_center<-sig_est^2
         
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro((sig_est*spc.constant.calculation.c4(sample.size = n))^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}=$")
         
       }
       if(select==6){
         sig_est<-stat
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         s_center<-sig_est^2
         
         chi_low<-qchisq(p = p_low,df = n-1)
         chi_high<-qchisq(p = p_high,df = n-1)
         
         UCL<-ro(s_center*chi_high/(n-1),R)
         LCL<-ro(s_center*chi_low/(n-1),R)
         s_center<-ro((sig_est*spc.constant.calculation.c4(sample.size = n))^2,R)#these aren't right steve
         sig_est<-ro(sig_est,R)
         stat_symb<-withMathJax("$\\bar{s^{2}}_{est}=$")
         
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$s^2$"),"</b>"),
         "<br><br>",
         paste("Limits based on ",names(choice_r_limits)[select]," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$\\hat{\\sigma}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(s_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ###p
     output$p_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$p_lim_stat)
       stat<-as.numeric(input$p_lim_value)
       n<-as.numeric(input$p_lim_n)
       sterr<-as.numeric(input$p_lim_sterr)
       R<-input$p_lim_decimals
       
       if(select==1){
         
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         LCL<-ro((qbinom(p = p_low,size = n,prob = stat,lower.tail = T)-.5)/n,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro((qbinom(p = p_high,size = n,prob = stat,lower.tail = T)+.5)/n,R)
         p_center<-stat
         sig_est<-ro(sqrt(stat*(1-stat)/n),R)
         
         stat_symb<-withMathJax("$\\bar{p}=$")
       }
       if(select==2){
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         p_center<-stat
         sig_est<-ro(sqrt(stat*(1-stat)/n),R)
         LCL<-ro(p_center-3*sig_est,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro(p_center+3*sig_est,R)
         
         stat_symb<-withMathJax("$\\bar{p}=$")
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$p$"),"</b>"),
         "<br><br>",
         paste("Limits are ",c("Exact Bimonial, ","Normal Approximate, ")[select],withMathJax("$\\bar{p}$")," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$SE_{norm}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(p_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ##np
     output$np_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$np_lim_stat)
       stat<-as.numeric(input$np_lim_value)
       n<-as.numeric(input$np_lim_n)
       sterr<-as.numeric(input$np_lim_sterr)
       R<-input$np_lim_decimals
       
       if(select==1){
         
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         LCL<-ro((qbinom(p = p_low,size = n,prob = stat/n,lower.tail = T)-.5),R)
         if(LCL<0){LCL<-NA}
         UCL<-ro((qbinom(p = p_high,size = n,prob = stat/n,lower.tail = T)+.5),R)
         p_center<-stat
         sig_est<-ro(sqrt(stat*(1-(stat/n))),R)
         
         stat_symb<-withMathJax("$\\overline{np}=$")
       }
       if(select==2){
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         p_center<-stat
         sig_est<-ro(sqrt(stat*(1-(stat/n))),R)
         LCL<-ro(p_center-3*sig_est,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro(p_center+3*sig_est,R)
         
         stat_symb<-withMathJax("$\\overline{np}=$")
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$np$"),"</b>"),
         "<br><br>",
         paste("Limits are ",c("Exact Binomial, ","Normal Approximate, ")[select],withMathJax("$\\overline{np}$")," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$SE_{norm}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(p_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ##c################################
     output$c_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$c_lim_stat)
       stat<-as.numeric(input$c_lim_value)
       sterr<-as.numeric(input$c_lim_sterr)
       R<-input$c_lim_decimals
       
       if(select==1){
         
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         LCL<-ro((qpois(p = p_low,lambda = stat,lower.tail = T)-.5),R)
         if(LCL<0){LCL<-NA}
         UCL<-ro((qpois(p = p_high,lambda = stat,lower.tail = T)+.5),R)
         c_center<-stat
         sig_est<-ro(sqrt(stat),R)
         
         stat_symb<-withMathJax("$\\bar{c}=$")
       }
       if(select==2){
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         c_center<-stat
         sig_est<-sqrt(stat)
         LCL<-ro(c_center-3*sig_est,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro(c_center+3*sig_est,R)
         sig_est<-ro(sig_est,R)
         
         stat_symb<-withMathJax("$\\bar{c}=$")
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$c$"),"</b>"),
         "<br><br>",
         paste("Limits are ",c("Exact Poisson, ","Approximate Normal, ")[select],withMathJax("$\\bar{c}$")," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$SE_{norm}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(c_center,R),"</td>",
         
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     ##u##########################################
     output$u_lim_out<-renderUI({#calculate the various outputs and put them in a pretty table
       select<-as.numeric(input$u_lim_stat)
       stat<-as.numeric(input$u_lim_value)
       n<-as.numeric(input$u_lim_n)
       sterr<-as.numeric(input$u_lim_sterr)
       R<-input$u_lim_decimals
       
       if(select==1){
         
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         LCL<-ro((qpois(p = p_low,lambda = stat*n,lower.tail = T)-.5)/n,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro((qpois(p = p_high,lambda = stat*n,lower.tail = T)+.5)/n,R)
         u_center<-stat
         sig_est<-ro(sqrt(stat*n)/n,R)
         
         stat_symb<-withMathJax("$\\bar{u}=$")
       }
       if(select==2){
         p_low<-pnorm(-sterr,0,1)
         p_high<-pnorm(sterr,0,1)
         
         u_center<-stat
         sig_est<-sqrt(stat/n)
         LCL<-ro(u_center-3*sig_est,R)
         if(LCL<0){LCL<-NA}
         UCL<-ro(u_center+3*sig_est,R)
         sig_est<-ro(sig_est,R)
         
         stat_symb<-withMathJax("$\\bar{u}=$")
       }
       
       
       #build output table
       output<-HTML(c(
         paste("<b>Control Limit Calculations: ",withMathJax("$u$"),"</b>"),
         "<br><br>",
         paste("Limits are ",c("Exact Poisson, ","Approximate Normal, ")[select],withMathJax("$\\bar{u}$")," = ",ro(stat,R),"<br>"),
         paste("Standard Errors = ",sterr),
         "<br><br>",
         
         "<table>",
         "<tr>",
         "<td>",paste(withMathJax("$UCL=$")),"</td>",
         "<td align='left'>",UCL,"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$SE_{norm}=$")),"</td>",
         "<td align='left'>",sig_est,"</td>",
         "</tr>",
         "<tr>",
         "<td>",paste(stat_symb),"</td>",
         "<td align='left'>",ro(u_center,R),"</td>",
         "<td></td>",
         "<td>",paste(withMathJax("$n=$")),"</td>",
         "<td align='left'>",n,"</td>",
         "</tr>",
         "<tr>",
         "<tr>",
         "<td>",paste(withMathJax("$LCL =$")),"</td>",
         "<td>",LCL,"</td></tr>",
         "</table>"
       )#end c
       
       )#end html
       
       output
     })
     
     #SPC#######################################################################
     
     appendList <- function (x, val) #this appends more complicated lists like the spc output credit:Sarkar
     {
       stopifnot(is.list(x), is.list(val))
       xnames <- names(x)
       for (v in names(val)) {
         x[[v]] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]])) 
           appendList(x[[v]], val[[v]])
         else c(x[[v]], val[[v]])
       }
       x
     }
     
     #First UI element of the EDA data selection, used either for selecting columns or the factor
     output$spc_var_UI1<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_var_data_type
       ind_chart<-input$spc_var_ind_or_mean
       
       if(ind_chart){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "spc_var_UI1",
                             label = "Select Data Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
         return(output)
       }
       
       
       if((data_type==1)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "spc_var_UI1",
                             label = "Select Data Columns",
                             multiple=T,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       if((data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "spc_var_UI1",
                             label = "Select Sample Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       } 
       
       output
       
     })
     
     #Second UI element of the EDA data selection used for selecting the data columns
     output$spc_var_UI2<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_var_data_type
       UI1<-input$spc_var_UI1
       req(UI1)
       ind_chart<-input$spc_var_ind_or_mean
       
       output<-NULL
       
       if(!ind_chart){
        if(data_type==1){
         output<-NULL
       } else
         if(data_type==2){
           #take out those already selected
           fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-choices[temp]
           
           output<-pickerInput(inputId = "spc_var_UI2",
                               label = "Select Data Column",
                               multiple=F,
                               options=list(`actions-box` = TRUE),
                               choices = choices)
         } 
       }
       
       output
       
     })
     
     output$spc_var_set<-renderUI({#sets
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       req(UI1)
       #req(UI2)
       ind_chart<-input$spc_var_ind_or_mean
       
       output<-NULL
       
       if(data_type==1 || ind_chart){
         fact_selected<-c(UI1)
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-c("None"=0,choices[temp])
         output<-pickerInput(inputId = "spc_var_set",
                             label = "Select Set Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       } else
         if(data_type==2){
           #take out those already selected
           #fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           fact_selected<-c(UI1,UI2)
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-c("None"=0,choices[temp])
           
           output<-pickerInput(inputId = "spc_var_set",
                               label = "Select Set Column",
                               multiple=F,
                               options=list(`actions-box` = TRUE),
                               choices = choices)
         } 
       
       output
       
     })
     
     output$spc_var_loc_type<-renderUI({
       # data_type<-input$spc_var_data_type
       ind_chart<-input$spc_var_ind_or_mean
       
       if(!ind_chart){
         output<-selectInput(inputId = "spc_var_loc_type",label = "Location",choices = c("X-bar"=1))
       }
       
       if(ind_chart){
         output<-selectInput(inputId = "spc_var_loc_type",label = "Location",choices = c("X"=2))
       }
       
       # if(data_type==1){
       #   output<-selectInput(inputId = "spc_var_loc_type",label = "Location",choices = c("X-bar"=1))
       # }
       # if(data_type==2){
       #   choices<-choice_x_spc
       #   output<-selectInput(inputId = "spc_var_loc_type",label = "Location",choices = choices)
       # }
       
       output
     })
     
     output$spc_var_disp_type<-renderUI({
       data_type<-input$spc_var_data_type
       x_type<-input$spc_var_loc_type
       # choice_xbar<-c("Range"=1,"Standard Deviation"=2,"Variance"=3)
       # choice_x<-c("Moving Range"=4)
       choice<-choice_disp_spc
       
       req(x_type)
       
       if(x_type==1){#x-bar
         output<-selectInput(inputId = "spc_var_disp_type",label = "Dispersion",choices = choice[1:3])
       }
       if(x_type==2){#individual
         output<-selectInput(inputId = "spc_var_disp_type",label = "Dispersion",choices = choice[4])
       }
       
       output
     })
     
     output$spc_var_loc_lim<-renderUI({
       x_type<-input$spc_var_loc_type
       choice_x_bar<-choice_x_bar_limits2#change to 2
       ind_chart<-input$spc_var_ind_or_mean
       #choice_x<-c(choice_x_limits,"Custom"=5)
       req(x_type)#can't use ind_chart as required since it fails on FALSE
       
       if(!ind_chart){
         output<-selectInput(inputId = "spc_var_loc_lim",label = "X-bar Limit Calculation",choices = choice_x_bar)
       }
       if(ind_chart){
         choice<-c(1:9,12)#for generating spc charts - all x charts
         names(choice)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average Moving Range of X",
           "Median Moving Range of X",
           "Standard Deviation of X",
           "Known \U03c3",
           "Custom"
         )
         output<-selectInput(inputId = "spc_var_loc_lim",label = "X Limit Calculation",choices = choice[6:10])
       }
       output
     })
     
     output$spc_var_disp_lim<-renderUI({
       x_type<-input$spc_var_loc_type
       #choice_x_bar<-c(choice_x_bar_limits,"Custom"=10)
       choice_x<-choice_x_limits
       choice_disp_xbar<-c("R","s","s\U00B2")
       choice_disp_x<-c("Moving Range")
       disp_type<-as.numeric(input$spc_var_disp_type)
       req(disp_type)
       if(disp_type==2){
         choice_r_limits2<-c(1:9,12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s",
           "Median MR of s",
           "Standard Deviation of s",
           "Known \U03c3",
           "Custom"
         )
       }
       
       if(disp_type==3){
         choice_r_limits2<-c(1:9,12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s\U00B2",
           "Median MR of s\U00B2",
           "Standard Deviation of s\U00B2",
           "Known \U03c3",
           "Custom"
         )
       }
       
       if(disp_type==4){
         choice_r_limits2<-c(1:9,12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR",
           "Median MR",
           "Standard Deviation of X",
           "Known \U03c3",
           "Custom"
         )
       }
       
       req(x_type)
       
       if(x_type==1){
         output<-selectInput(inputId = "spc_var_disp_lim",label = paste(choice_disp_xbar[disp_type]," Limit Calculation"),choices = choice_r_limits2)
       }
       if(x_type==2){
         output<-selectInput(inputId = "spc_var_disp_lim",label = paste(choice_disp_x," Limit Calculations"),choices = choice_r_limits2[6:10])#here if need to revert back to old choices
       }
       output
     })
     
     output$spc_run_type<-renderUI({
       runchart<-input$spc_runchart#logical true is run chart
       
       if(!runchart){return()} else{
         if(!input$spc_var_ind_or_mean){#if not individuals
           output<-tags$div(
             tags$p("Run chart of:"),
             materialSwitch(inputId = "spc_run_loc",label = "Means",value = FALSE,inline = TRUE),
             tags$span("Medians")
             )
           
         } else{#individuals
           output<-tags$div(
             tags$p("Centerline:"),
             materialSwitch(inputId = "spc_run_loc",label = "Mean",value = FALSE,inline = TRUE),
             tags$span("Median")
             )
           
         }
       }
       output
     })
     
     output$xchartout<-renderPlot({x_chart_out()})
     xchartout_width<-reactive(400*8)
     xchartout_height<-reactive(200*8)
     downloadServer('xchartout', x_chart_out,height = xchartout_height,width = xchartout_width)
     
     
     x_chart_out<-reactive({#spc plot starts here
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       req(UI1)
       x_type<-input$spc_var_loc_type
       disp_type<-input$spc_var_disp_type
       span<-input$spc_mr_span
       x_lim_calc<-input$spc_var_loc_lim
       disp_lim_calc<-input$spc_var_disp_lim
       loc_upper_custom<-input$custom.x.upper
       loc_center_custom<-input$custom.x.center
       loc_lower_custom<-input$custom.x.lower
       disp_upper_custom<-input$custom.disp.upper
       disp_center_custom<-input$custom.disp.center
       disp_lower_custom<-input$custom.disp.lower
       std_err<-as.numeric(input$std_err_x)
       known_sig_x<-input$known_sig_x#use for both x and disp
       loc_center_type<-input$spc_x_loc
       disp_center_type<-input$spc_x_disp
       USL<-input$spc_x_USL
       Target<-input$spc_x_target
       LSL<-input$spc_x_LSL
       ind_chart<-input$spc_var_ind_or_mean#logical: is it an individual chart?
       runchart<-input$spc_runchart #logical TRUE means make a run chart
       run_loc<-input$spc_run_loc#logical FALSE is means
       font_size<-as.numeric(input$spc_font_size)
       
       sets<-as.numeric(input$spc_var_set)
       req(sets)
       
       #req(ind_chart)
       
       
       #chart_complete<<-FALSE
       
       if(!ind_chart){
       
       if(data_type==1){#row is subgroup
         req(length(UI1)>1)
         k_obs<-nrow(data)
         data<-transform.dependent.format.to.independent.format(data = data[UI1])
         if(sets==0){
           data<-cbind("Data"=data,"Sample"=seq(1,k_obs))
           names(data)<-c("Name","Data","Sample")
         }
         else {
           data<-cbind("Data"=data,"Sample"=seq(1,k_obs),"Sets"=sets)
           names(data)<-c("Name","Data","Sample","Sets")
         }
         y_lab<-names(res_filter$filtered()[UI1])
       }
       else{
         req(UI2)
         k_obs<-nrow(unique(data[UI1]))
         if(sets==0){
           data<-cbind("Data"=data[UI2],"Sample"=data[UI1])#,"Sets"=data[sets])
           names(data)<-c("Data","Sample")
         }
         else{
           data<-cbind("Data"=data[UI2],"Sample"=data[UI1],"Sets"=data[sets])
           names(data)<-c("Data","Sample","Sets")
         }
         y_lab<-names(res_filter$filtered()[UI2])
       }
       }
       
       if(ind_chart){
         
         k_obs<-nrow(data)
         y_lab<-names(res_filter$filtered()[UI1])
         if(sets==0){
          data<-cbind("Data"=data[UI1],"Sample"=seq(1,k_obs))
          names(data)<-c("Data","Sample")
         }
         else{
           data<-cbind("Data"=data[UI1],"Sample"=seq(1,k_obs),"Sets"=data[sets])
           names(data)<-c("Data","Sample","Sets")
         }
       }
       
       #data is now in subgroups defined by a column, data in column, set in column (if present)
       data<-data[order(data$Sample),]#reorder by sample num
       
       #if run chart create it and drop out here
       if(runchart){
         names(data)[names(data)=="Sample"]<-"x_label"#need these for mouseover to work
         names(data)[names(data)=="Data"]<-"measure"
         if(sets==0){
           data<-cbind(data,"Sets"=1)
           if(run_loc){
             data<-cbind(data,"loc"=median(data$measure))
             p<-ggplot(data=data,aes(x=x_label,y=measure))+
               stat_summary(geom="point",fun="median",color=color[4])+
               stat_summary(geom="line",fun="median",color=color[4])+
               geom_hline(aes(yintercept=median(measure)),color=color[3])+
               theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
             if(ind_chart){
               p<-p+
                 ggtitle("Run Chart, Median Centerline")+
                 labs(x="Samples",y=names(res_filter$filtered())[UI1])
             } else{
               p<-p+
               ggtitle("Run Chart of Medians")+
               labs(x="Samples",y="Data")
             }
               
           } else{
             data<-cbind(data,"loc"=mean(data$measure))
             p<-ggplot(data=data,aes(x=x_label,y=measure))+
               stat_summary(geom="point",fun="mean",color=color[4])+
               stat_summary(geom="line",fun="mean",color=color[4])+
               geom_hline(aes(yintercept=mean(measure)),color=color[3])+
               theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
             if(ind_chart){
               p<-p+
                 ggtitle("Run Chart, Mean Centerline")+
                 labs(x="Samples",y=names(res_filter$filtered())[UI1])
             } else{
               p<-p+ggtitle("Run Chart of Means")+
               labs(x="Samples",y="Data")
             }
               
           }
         } else{
           diff_run<-c(0,diff(data$Set))
           diff_set<-1
           for (i in 1:length(diff_run)){
             if(diff_run[i]==0) {diff_run[i]<-diff_set}
             else{
               diff_set<-diff_set+1
               diff_run[i]<-diff_set
             }
           }
           data<-cbind(data,diff_run)
           if(run_loc){
             group_medians<-aggregate(data$measure,list(data$Set),FUN=median)
             names(group_medians)<-c("Sets","loc")
             data<-merge(data,group_medians,sort = FALSE)
             p<-ggplot(data=data,aes(x=x_label,y=measure,group=diff_run))+
               stat_summary(geom="point",fun="median",color=color[4])+
               stat_summary(geom="line",fun="median",color=color[4])+
               geom_line(aes(y=loc),color=color[3])+
               theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
             if(ind_chart){
               p<-p+
                 ggtitle("Run Chart, Median Centerline")+
                 labs(x="Samples",y=names(res_filter$filtered())[UI1])
             } else{
               p<-p+
                 ggtitle("Run Chart of Medians")+
                 labs(x="Samples",y="Data")
             }
           }else{
             group_means<-aggregate(data$measure,list(data$Set),FUN=mean)
             names(group_means)<-c("Sets","loc")
             data<-merge(data,group_means,sort = FALSE)
             p<-ggplot(data=data,aes(x=x_label,y=measure,group=diff_run))+
               stat_summary(geom="point",fun="mean",color=color[4])+
               stat_summary(geom="line",fun="mean",color=color[4])+
               geom_line(aes(y=loc),color=color[3])+
               theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
             if(ind_chart){
               p<-p+
                 ggtitle("Run Chart, Mean Centerline")+
                 labs(x="Samples",y=names(res_filter$filtered())[UI1])
             } else{
               p<-p+ggtitle("Run Chart of Means")+
                 labs(x="Samples",y="Data")
             }
           }
           
         }
         
         if(run_loc){meas<-"median"} else{meas<-"mean"}
         
         hoverdata<-data.frame(x_label=sort(unique(data$x_label)),
                               n_sample=aggregate(data$measure,list(data$x_label),FUN=length)[2],
                               set=aggregate(data$Sets,list(data$x_label),FUN=unique)[2],
                               measure=aggregate(data$measure,list(data$x_label),FUN=meas)[2],
                               centerline=aggregate(data$loc,list(data$x_label),FUN=meas)[2]
                               )
         colnames(hoverdata)<-c("x_label","n_sample","set","measure","centerline")
         
         plot_data_r<<-reactive(data.frame(x_label=hoverdata$x_label,
                                           facet="Run Chart",
                                           n_sample=hoverdata$n_sample,
                                           set=hoverdata$set,
                                           UCL=NA,
                                           LCL=NA,
                                           measure=hoverdata$measure,
                                           est_sig=NA,
                                           ind_s=NA,
                                           set_sd=NA,
                                           centerline=hoverdata$centerline,
                                           outside=NA,
                                           runs=NA,
                                           zone_bc_up=NA,
                                           zone_bc_low=NA,
                                           zone_ab_up=NA,
                                           zone_ab_low=NA,
                                           zone_a_up=NA,
                                           zone_a_low=NA,
                                           trends=NA,
                                           alternating=NA,
                                           zone_a=NA,
                                           consec_c=NA,
                                           consec_ab=NA,
                                           zone_a_b=NA))#,plot_order)[order(-xtfrm(facet),x_label),])
         
         return(p)
         
       }
       #end of run chart, new requirements
       req(x_type,disp_lim_calc,disp_type)
       
       run_length<-as.numeric(input$run_length_x)
       ooc_rules<-spc.rulesets.nelson.1984.test.1.2.3.4.5.6.7.8()
       ooc_rules$runs<-spc.controlviolation.nelson.1984.test2.runs.create(point.count = run_length)
         
      
       #c2_rules<-spc.rulesets.outside.limits()
       #c2_rules<-spc.rulesets.nelson.1984.test.1.2.3.4.5.6.7.8()
       #c2_rules<-spc.rulesets.nelson.1984.test.1.2.3.4()
       
       
       st_dev_ind<-sd(data$Data)#add this in output later
       
       #for sets
       if(sets!=0){
         set_id<-unique(data$Sets)
         #num_sets<-length(set_id)
       } else{
         set_id<-1
         row_num<-nrow(data)
         if(!is.null(data$Sets)){#not sure if I need this in app
           data$Sets<-NULL
         }
         data<-cbind(data,Sets=rep(1,row_num))
         sets<-ncol(data)
       }
       ##################
       
       data <- data[order(data$Sample),]
       
       #count observations outside of spec if spec exists
       if(!is.na(USL) || !is.na(Target) ||!is.na(LSL)){
         #loop through sets
         set_num<-unique(data$Sets)
         for(i in set_num){
           above_USL[i]<<-sum(data$Data[data$Sets==i] > USL)
           below_LSL[i]<<-sum(data$Data[data$Sets==i] < LSL)
         }
       }
       
       #in this part we calculate the points we are going to use including some we might not need. Limits come later.
       
       if(x_type==1){
         # if(as.numeric(input$spc_var_set)!=0){#steve
         if(ind_chart){return()}
           points<-cbind(aggregate(Sets~Sample,data = data,mean),spc.preprocess.data(data =data$Data,sample = data$Sample,stat.n=T,stat.mean=T,stat.range=T,stat.sd=T,stat.var=T))
           points<-points[order(points$g),]
         # }
         # else{points<-spc.preprocess.data(data =data$Data,sample = data$Sample,stat.n=T,stat.mean=T,stat.range=T,stat.sd=T,stat.var=T)}
       }
       if(x_type==2){
         if(!ind_chart){return()}
         # if(sets!=0){
         #   
         # } else
         #x 
         points<-data
         n<-rep(1,k_obs)
         #MR 
         
         #add bit to take out spikes associated with a set if using a set
         if(as.numeric(input$spc_var_set)!=0){
           set_change<-c(0,diff(points$Sets))
           MR<-MR_span(data = points$Data,span = span)
           for(i in seq(1,length(set_change))){
             if(set_change[i]!= 0){
               MR[i]<-NA
             }
           }
                       
         } else{
           MR<-MR_span(data = points$Data,span = span)#c(rep(NA,span-1),max(abs(diff(points$Data,differences=span-1))))
         }
         points<-cbind(points,MR,n)
       }
       
       #now that we have the points, we can calculate the limits for each and estimated std - set up vectors
       points_1<-NULL
       centerline_1<-NULL
       UCL1<-NULL
       zone_a_up_1<-NULL
       zone_ab_up_1<-NULL
       zone_bc_up_1<-NULL
       LCL1<-NULL
       zone_a_low_1<-NULL
       zone_ab_low_1<-NULL
       zone_bc_low_1<-NULL
       
       #bottom chart
       points_2<-NULL
       centerline_2<-NULL
       UCL2<-NULL
       zone_a_up_2<-NULL
       zone_ab_up_2<-NULL
       zone_bc_up_2<-NULL
       LCL2<-NULL
       zone_a_low_2<-NULL
       zone_ab_low_2<-NULL
       zone_bc_low_2<-NULL
       
       #other variables
       set<-NULL
       Sample<-NULL
       points_1<-NULL
       points_2<-NULL
       sample<-NULL
       sample2<-NULL
       est_sig<-NULL
       ind_sd<-NULL
       set_sd<-NULL
       sd_set<-NULL
       sig_est<-NULL
       n_k<-NULL
       
       #k_obs<-nrow(points)
       
       if(x_lim_calc==1){#avg R loc
         for(j in set_id){
           stat<-mean(points$range[points$Set==j])#avg range within set
           # disp_d<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
           # sig_est[j]<-stat/disp_d
           sd_set[j]<-sd(data$Data[data$Set==j])
           Sample<-unique(points$g[points$Set==j])
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }

           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-spc.constant.calculation.A2(sample.size = n,n.sigma = std_err)

             points_1<-c(points_1,points$mean[i])

             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             # est_sig<-c(est_sig,sig_est[j])
             # ind_sd<-c(ind_sd,st_dev_ind)
             # set_sd<-c(set_sd,sd_set[j])
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )

       }#end avg R loc
       
       if(x_lim_calc==2){#median R loc
         for(j in set_id){
           stat<-median(points$range[points$Set==j])#median range within set
           # disp_d<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
           # sig_est[j]<-stat/disp_d
           sd_set[j]<-sd(data$Data[data$Set==j])
           Sample<-unique(points$g[points$Set==j])
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-spc.constant.calculation.A4(sample.size = n,n.sigma = std_err)#std_err/(disp_d*sqrt(n))
             
             points_1<-c(points_1,points$mean[i])
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             # est_sig<-c(est_sig,sig_est[j])
             # ind_sd<-c(ind_sd,st_dev_ind)
             # set_sd<-c(set_sd,sd_set[j])
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end median R loc
       
       if(x_lim_calc==3){#avg s loc
         for(j in set_id){
           stat<-mean(points$sd[points$Set==j])#avg std within set
           # disp_d<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
           # sig_est[j]<-stat/disp_d
           sd_set[j]<-sd(data$Data[data$Set==j])
           Sample<-unique(points$g[points$Set==j])
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-spc.constant.calculation.A3(sample.size = n,n.sigma = std_err)
             
             points_1<-c(points_1,points$mean[i])
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             # est_sig<-c(est_sig,sig_est[j])
             # ind_sd<-c(ind_sd,st_dev_ind)
             # set_sd<-c(set_sd,sd_set[j])
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end avg s loc
       
       if(x_lim_calc==4){#median s loc
         for(j in set_id){
           stat<-median(points$sd[points$Set==j])#median std within set
           # disp_d<-c6(mean(points$n[points$Set==j]))
           # sig_est[j]<-stat/disp_d
           sd_set[j]<-sd(data$Data[data$Set==j])
           Sample<-unique(points$g[points$Set==j])
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-std_err/(c6(n)*sqrt(n))
             
             points_1<-c(points_1,points$mean[i])
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             # est_sig<-c(est_sig,sig_est[j])
             # ind_sd<-c(ind_sd,st_dev_ind)
             # set_sd<-c(set_sd,sd_set[j])
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end median s loc
       
       if(x_lim_calc==5){#average var loc
         for(j in set_id){
           stat<-mean(points$var[points$Set==j])#average var within set
           #disp_d<-c6(mean(points$n[points$Set==j]))
           # sig_est[j]<-sqrt(stat)
           sd_set[j]<-sd(data$Data[data$Set==j])
           Sample<-unique(points$g[points$Set==j])
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-std_err/sqrt(n*stat)
             
             points_1<-c(points_1,points$mean[i])
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             # est_sig<-c(est_sig,sig_est[j])
             # ind_sd<-c(ind_sd,st_dev_ind)
             # set_sd<-c(set_sd,sd_set[j])
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end ave var loc
       
       if(x_lim_calc==6){#MR x loc
         for(j in set_id){
           if(ind_chart){
             stat<-mean(na.omit(points$MR[points$Set==j]))#average MR within set
             Sample<-unique(points$Sample[points$Set==j])
           } else{
            stat<-mean(abs(diff(points$mean[points$Set==j])))#average MR within set
            Sample<-unique(points$g[points$Set==j])
           }
           sd_set[j]<-sd(data$Data[data$Set==j])
           
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-std_err/(spc.constant.calculation.d2(sample.size = span))
             
             if(ind_chart){
               points_1<-c(points_1,points$Data[i])
             } else{
               points_1<-c(points_1,points$mean[i])}
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end MR x loc
       
       if(x_lim_calc==7){#median MR x loc
         for(j in set_id){
           if(ind_chart){
             stat<-median(na.omit(points$MR[points$Set==j]))#median MR within set
             Sample<-unique(points$Sample[points$Set==j])
           } else{
             stat<-median(abs(diff(points$mean[points$Set==j])))#median MR within set
             Sample<-unique(points$g[points$Set==j])
           }
           sd_set[j]<-sd(data$Data[data$Set==j])
           
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-std_err/(spc.constant.calculation.d4(sample.size = span))
             
             if(ind_chart){
               points_1<-c(points_1,points$Data[i])
             } else{
               points_1<-c(points_1,points$mean[i])}
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end median MR x loc
       
       if(x_lim_calc==8){#std x loc
         for(j in set_id){
           if(ind_chart){
             stat<-sd(points$Data[points$Set==j])#sd of ind within set
             Sample<-unique(points$Sample[points$Set==j])
           } else{
             stat<-sd(points$mean[points$Set==j])#sd of means within set
             Sample<-unique(points$g[points$Set==j])
           }
           
           sd_set[j]<-sd(data$Data[data$Set==j])
           
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-3
             
             if(ind_chart){
               points_1<-c(points_1,points$Data[i])
             } else{
               points_1<-c(points_1,points$mean[i])}
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end std of xbar loc
       
       if(x_lim_calc==9){#std known sigma loc
         for(j in set_id){
           if(ind_chart){
             Sample<-unique(points$Sample[points$Set==j])
           } else{
             Sample<-unique(points$g[points$Set==j])
           }
           
           stat<-known_sig_x#
           sd_set[j]<-sd(data$Data[data$Set==j])
           
           if(loc_center_type==1){
             centerline_loc<-mean(data$Data[data$Set==j])
           }
           if(loc_center_type==2){
             centerline_loc<-median(data$Data[data$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             loc_const<-std_err/sqrt(n)
             
             if(ind_chart){
               points_1<-c(points_1,points$Data[i])
             } else{
               points_1<-c(points_1,points$mean[i])}
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,centerline_loc+loc_const*stat)
             LCL1<-c(LCL1,centerline_loc-loc_const*stat)
             ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,centerline_loc+loc_const*stat)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*ac1)
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*ac1)
             zone_a_low_1<-c(zone_a_low_1,centerline_loc-loc_const*stat)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*ac1)
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*ac1)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end known sigma loc
       
       if(x_lim_calc==12){#custom loc
         for(j in set_id){
           #stat<-known_sig_x#
           sd_set[j]<-sd(data$Data[data$Set==j])
           if(ind_chart){
             Sample<-unique(points$Sample[points$Set==j])
           } else{
             Sample<-unique(points$g[points$Set==j])
           }
           #centerline_loc<-mean(data$Data[data$Set==j])#add option for median or user-defined?
           centerline_loc<-loc_center_custom
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             #loc_const<-std_err/sqrt(n)
             
             if(ind_chart){
               points_1<-c(points_1,points$Data[i])
             } else{
               points_1<-c(points_1,points$mean[i])}
             
             sample<-c(sample,i)
             set<-c(set,j)
             n_k<-c(n_k,n)
             centerline_1<-c(centerline_1,centerline_loc)
             UCL1<-c(UCL1,loc_upper_custom)
             LCL1<-c(LCL1,loc_lower_custom)
             #ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_1<-c(zone_a_up_1,UCL1)
             zone_ab_up_1<-c(zone_ab_up_1,centerline_loc+(2/3)*(UCL1-centerline_loc))
             zone_bc_up_1<-c(zone_bc_up_1,centerline_loc+(1/3)*(UCL1-centerline_loc))
             zone_a_low_1<-c(zone_a_low_1,LCL1)
             zone_ab_low_1<-c(zone_ab_low_1,centerline_loc-(2/3)*(centerline_loc-LCL1))
             zone_bc_low_1<-c(zone_bc_low_1,centerline_loc-(1/3)*(centerline_loc-LCL1))
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data<-cbind(set,sample,n_k,points_1,LCL1,centerline_1,UCL1,zone_a_up_1,zone_ab_up_1,zone_bc_up_1,zone_a_low_1,zone_ab_low_1,zone_bc_low_1)
         
         plot_data<-as.data.frame(plot_data[order(sample),])
         
         #####ooc tests
         control_vio_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data$points_1,
                                                            center.line = plot_data$centerline_1,
                                                            control.limits.ucl = plot_data$UCL1,
                                                            zone.a.upper = plot_data$zone_a_up_1,
                                                            zone.ab.upper = plot_data$zone_ab_up_1,
                                                            zone.bc.upper = plot_data$zone_bc_up_1,
                                                            control.limits.lcl = plot_data$LCL1,
                                                            zone.a.lower = plot_data$zone_a_low_1,
                                                            zone.ab.lower = plot_data$zone_ab_low_1,
                                                            zone.bc.lower = plot_data$zone_bc_low_1
         )
         
       }#end custom loc
       
       #other location charts
       
       #dispersion charts here
       
       if(disp_lim_calc==1){#avg R disp
         for(j in set_id){
           
           stat<-mean(points$range[points$Set==j])#avg range within set
           disp_d<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
           sig_est[j]<-stat/disp_d
           
            if(disp_type==1){#range chart centerline
              if(disp_center_type==1){
                centerline_disp<-mean(points$range[points$Set==j])
              }
              if(disp_center_type==2){
                centerline_disp<-median(points$range[points$Set==j])
              }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){#range chart
              disp_low<-spc.constant.calculation.D3(sample.size = n,n.sigma = std_err)
              disp_up<-spc.constant.calculation.D4(sample.size = n,n.sigma = std_err)
              points_2<-c(points_2,points$range[i])
             }
             
              if(disp_type==2){#s chart
                mean_est<-sig_est[j]*spc.constant.calculation.c4(sample.size = n)
                disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
                disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
                points_2<-c(points_2,points$sd[i])
                stat<-mean_est
              }
             
             if(disp_type==3){#var chart
                p_low<-pnorm(-std_err,0,1)
                p_high<-pnorm(std_err,0,1)
                mean_est<-sig_est[j]^2
                disp_low<-qchisq(p = p_low,df = n-1)/(n-1)
                disp_up<-qchisq(p = p_high,df = n-1)/(n-1)
                points_2<-c(points_2,points$var[i])
                stat<-mean_est
             }
             
             #s chart move to s needs to be using average range to calculate CL for s
             #   disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
             #   disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
             #   points_2<-c(points_2,points$sd[i])
             # }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up*stat)
             LCL2<-c(LCL2,disp_low*stat)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up*stat-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up*stat)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             ac3<-centerline_disp-LCL2[i]
             if(is.na(ac3)){ac3<-centerline_disp}
             zone_a_low_2<-c(zone_a_low_2,centerline_disp-ac3)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac3)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac3)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
         
         
         
       }#end avg R disp
       
       if(disp_lim_calc==2){#median R disp
         for(j in set_id){
           stat<-median(points$range[points$Set==j])#median range within set
           disp_d<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
           sig_est[j]<-stat/disp_d
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){#range chart
              disp_low<-spc.constant.calculation.D5(sample.size = n,n.sigma = std_err)
              disp_up<-spc.constant.calculation.D6(sample.size = n,n.sigma = std_err)
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){#s chart
               mean_est<-sig_est[j]*spc.constant.calculation.c4(sample.size = n)
               disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
               disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
               points_2<-c(points_2,points$sd[i])
               stat<-mean_est
             }
             
             if(disp_type==3){#var chart
               p_low<-pnorm(-std_err,0,1)
               p_high<-pnorm(std_err,0,1)
               mean_est<-sig_est[j]^2
               disp_low<-qchisq(p = p_low,df = n-1)/(n-1)
               disp_up<-qchisq(p = p_high,df = n-1)/(n-1)
               points_2<-c(points_2,points$var[i])
               stat<-mean_est
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up*stat)
             LCL2<-c(LCL2,disp_low*stat)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up*stat-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up*stat)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             ac3<-centerline_disp-LCL2[i]
             if(is.na(ac3)){ac3<-centerline_disp}
             zone_a_low_2<-c(zone_a_low_2,centerline_disp-ac3)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac3)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac3)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
         
         
         
       }#end median R disp
       
       if(disp_lim_calc==3){#ave s disp
         for(j in set_id){
           stat<-mean(points$sd[points$Set==j])#avg sd within set
           disp_d<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
           sig_est[j]<-stat/disp_d
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){
              disp_low<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D3(sample.size = n,n.sigma = std_err)/spc.constant.calculation.c4(sample.size = n)
              disp_up<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D4(sample.size = n,n.sigma = std_err)/spc.constant.calculation.c4(sample.size = n)
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){#s chart
               disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
               disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
               points_2<-c(points_2,points$sd[i])
             }
             
             if(disp_type==3){#var chart
               p_low<-pnorm(-std_err,0,1)
               p_high<-pnorm(std_err,0,1)
               mean_est<-sig_est[j]^2
               disp_low<-qchisq(p = p_low,df = n-1)/(n-1)
               disp_up<-qchisq(p = p_high,df = n-1)/(n-1)
               points_2<-c(points_2,points$var[i])
               stat<-mean_est
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up*stat)
             LCL2<-c(LCL2,disp_low*stat)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up*stat-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up*stat)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             ac3<-centerline_disp-LCL2[i]
             if(is.na(ac3)){ac3<-centerline_disp}
             zone_a_low_2<-c(zone_a_low_2,centerline_disp-ac3)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac3)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac3)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
         
         
         
       }#end ave s disp
       
       if(disp_lim_calc==4){#median s disp
         for(j in set_id){
           stat<-median(points$sd[points$Set==j])#median sd within set
           disp_d<-c6(mean(points$n[points$Set==j]))
           sig_est[j]<-stat/disp_d
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){
              disp_low<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D3(sample.size = n,n.sigma = std_err)/c6(n)
              disp_up<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D4(sample.size = n,n.sigma = std_err)/c6(n)
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){#s chart
               mean_est<-sig_est[j]*spc.constant.calculation.c4(sample.size = n)
               disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
               disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
               points_2<-c(points_2,points$sd[i])
               stat<-mean_est
             }
             
             if(disp_type==3){#var chart
               p_low<-pnorm(-std_err,0,1)
               p_high<-pnorm(std_err,0,1)
               mean_est<-sig_est[j]^2
               disp_low<-qchisq(p = p_low,df = n-1)/(n-1)
               disp_up<-qchisq(p = p_high,df = n-1)/(n-1)
               points_2<-c(points_2,points$var[i])
               stat<-mean_est
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up*stat)
             LCL2<-c(LCL2,disp_low*stat)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up*stat-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up*stat)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             ac3<-centerline_disp-LCL2[i]
             if(is.na(ac3)){ac3<-centerline_disp}
             zone_a_low_2<-c(zone_a_low_2,centerline_disp-ac3)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac3)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac3)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end median s disp
       
       if(disp_lim_calc==5){#ave var disp
         for(j in set_id){
           stat<-mean(points$var[points$Set==j])#avg var within set
           #disp_d<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
           sig_est[j]<-sqrt(stat)
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){
              disp_low<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D3(sample.size = n,n.sigma = std_err)/sqrt(stat)
              disp_up<-spc.constant.calculation.d2(sample.size = n)*spc.constant.calculation.D4(sample.size = n,n.sigma = std_err)/sqrt(stat)
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){
               mean_est<-sig_est[j]*spc.constant.calculation.c4(sample.size = n)
               disp_low<-spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)
               disp_up<-spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)
               points_2<-c(points_2,points$sd[i])
               stat<-mean_est
             }
             
             if(disp_type==3){#var chart
               p_low<-pnorm(-std_err,0,1)
               p_high<-pnorm(std_err,0,1)
               mean_est<-sig_est[j]^2
               disp_low<-qchisq(p = p_low,df = n-1)/(n-1)
               disp_up<-qchisq(p = p_high,df = n-1)/(n-1)
               points_2<-c(points_2,points$var[i])
               stat<-mean_est
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up*stat)
             LCL2<-c(LCL2,disp_low*stat)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up*stat-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up*stat)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             ac3<-centerline_disp-LCL2[i]
             if(is.na(ac3)){ac3<-centerline_disp}
             zone_a_low_2<-c(zone_a_low_2,centerline_disp-ac3)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac3)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac3)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end ave var disp
       
       if(disp_lim_calc==6){#ave mr of disp
         for(j in set_id){
           
           if(ind_chart){
             stat<-mean(na.omit(points$MR[points$Sets==j]))#ave MR
             Sample<-unique(points$Sample[points$Set==j])
             sig_est[j]<-stat/spc.constant.calculation.d2(sample.size = span)
             if(disp_center_type==1){
               centerline_disp<-stat
             }
             if(disp_center_type==2){
               centerline_disp<-median(na.omit(points$MR[points$Set==j]))
             }
           }#end x chart if
           
           if(!ind_chart){#for non X charts use x chart limit choice to calculate underlying process variation
            stat_r<-mean(abs(diff(points$range[points$Set==j])))#avg mr of ranges within set
            stat_s<-mean(abs(diff(points$sd[points$Set==j])))#avg mr of s within set
            stat_s2<-mean(abs(diff(points$var[points$Set==j])))#avg mr of var within set
            
           disp_d_r<-spc.constant.calculation.d2(sample.size = 2)#going to be used to estimate the std of the ranges
           if(x_lim_calc==1){
             stat_x<-mean(points$range[points$Set==j])#avg range within set
             disp_d_x<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==2){
             stat_x<-median(points$range[points$Set==j])#median range within set
             disp_d_x<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==3){
             stat_x<-mean(points$sd[points$Set==j])#avg sd within set
             disp_d_x<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==4){
             stat_x<-median(points$sd[points$Set==j])#median sd within set
             disp_d_x<-c6(mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==5){
             stat_x<-mean(points$var[points$Set==j])#avg var within set
             sig_est[j]<-sig_est[j]<-sqrt(stat_x)#from variance
           }
           if(x_lim_calc==6){
             sig_est[j]<-sqrt(n)*mean(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d2(sample.size = 2) #calculated from average MR of the means
           }
           if(x_lim_calc==7){
             sig_est[j]<-sqrt(n)*median(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d4(sample.size = 2) #calculated from median MR of the means
           }
           if(x_lim_calc==8){
             sig_est[j]<-sqrt(n)*sd(points$mean[points$Set==j]) #calculated from s of the means
           }
           if(x_lim_calc==9){
             sig_est[j]<-known_sig_x #entered value
           }
           if(x_lim_calc==10){
             sig_est[j]<-NA
           }
           if(x_lim_calc==11){
             sig_est[j]<-NA
           }
           if(x_lim_calc==12){
             sig_est[j]<-NA
           }
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           Sample<-unique(points$g[points$Set==j])
           }#end of non X chart if
           
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==4){
               disp_low<-stat*spc.constant.calculation.D3(sample.size = span,n.sigma = std_err)+centerline_disp
               disp_up<-stat*spc.constant.calculation.D4(sample.size = span,n.sigma = std_err)-centerline_disp
               points_2<-c(points_2,points$MR[i])
             }
        
             if(disp_type==1){
              disp_low<- (std_err*stat_r/disp_d_r)
              disp_up<- std_err*stat_r/disp_d_r
              if(centerline_disp-disp_low<0){disp_low<-NA}
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){#these need to use the mr
               disp_low<- (std_err*stat_s/disp_d_r)
               disp_up<- std_err*stat_s/disp_d_r
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$sd[i])
             }
             
             if(disp_type==3){#var chart
               disp_low<- (std_err*stat_s2/disp_d_r)
               disp_up<- std_err*stat_s2/disp_d_r
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$var[i])
             }
      
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,centerline_disp+disp_up)#using MR to get limits
             LCL2<-c(LCL2,centerline_disp-disp_low)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-centerline_disp+disp_up-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,centerline_disp+disp_up)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             if(is.na(centerline_disp-disp_low)){
               zone_a_low_2<-c(zone_a_low_2,0)
               ac2_low<-centerline_disp
             } else {
               zone_a_low_2<-c(zone_a_low_2,centerline_disp-disp_low)
               ac2_low<-disp_low
             }
             #ac2_low<-centerline_disp-zone_a_low_2[i]
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac2_low)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac2_low)
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         if(disp_type==4){ooc_rules<-spc.rulesets.outside.limits()}
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end ave mr of range disp

       if(disp_lim_calc==7){#median mr of range disp
         for(j in set_id){
           if(ind_chart){
             stat<-median(na.omit(points$MR[points$Set==j]))#median MR
             Sample<-unique(points$Sample[points$Set==j])
             sig_est[j]<-stat/spc.constant.calculation.d4(sample.size = span)
             if(disp_center_type==1){
               centerline_disp<-mean(na.omit(points$MR[points$Sets==j]))
             }
             if(disp_center_type==2){
               centerline_disp<-stat
             }
           }#end x chart if
           
           if(!ind_chart){
           stat_r<-median(abs(diff(points$range[points$Set==j])))#median mr of ranges within set
           stat_s<-median(abs(diff(points$s[points$Set==j])))#median mr of s within set
           stat_s2<-median(abs(diff(points$var[points$Set==j])))#median mr of var within set
           
           disp_d_r<-spc.constant.calculation.d4(sample.size = 2)#going to be used to estimate the std of the ranges
           
           #use x chart limit choice to calculate underlying process variation
           if(x_lim_calc==1){
             stat_x<-mean(points$range[points$Set==j])#avg range within set
             disp_d_x<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==2){
             stat_x<-median(points$range[points$Set==j])#median range within set
             disp_d_x<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==3){
             stat_x<-mean(points$sd[points$Set==j])#avg sd within set
             disp_d_x<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==4){
             stat_x<-median(points$sd[points$Set==j])#median sd within set
             disp_d_x<-c6(mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==5){
             stat_x<-mean(points$var[points$Set==j])#avg var within set
             sig_est[j]<-sig_est[j]<-sqrt(stat_x)#from variance
           }
           if(x_lim_calc==6){
             sig_est[j]<-sqrt(n)*mean(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d2(sample.size = 2) #calculated from average MR of the means
           }
           if(x_lim_calc==7){
             sig_est[j]<-sqrt(n)*median(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d4(sample.size = 2) #calculated from median MR of the means
           }
           if(x_lim_calc==8){
             sig_est[j]<-sqrt(n)*sd(points$mean[points$Set==j]) #calculated from s of the means
           }
           if(x_lim_calc==9){
             sig_est[j]<-known_sig_x #entered value
           }
           if(x_lim_calc==10){
             sig_est[j]<-NA
           }
           if(x_lim_calc==11){
             sig_est[j]<-NA
           }
           if(x_lim_calc==12){
             sig_est[j]<-NA
           }
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           Sample<-unique(points$g[points$Set==j])
           }#end not ind chart if
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==4){
               disp_low<-stat*spc.constant.calculation.D5(sample.size = span,n.sigma = std_err)+centerline_disp
               disp_up<-stat*spc.constant.calculation.D6(sample.size = span,n.sigma = std_err)-centerline_disp
               points_2<-c(points_2,points$MR[i])
             }#end x chart if
             
             if(disp_type==1){
               disp_low<- (std_err*stat_r/disp_d_r)
               disp_up<- std_err*stat_r/disp_d_r
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){#these need to use the mr
               disp_low<- (std_err*stat_s/disp_d_r)
               disp_up<- std_err*stat_s/disp_d_r
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$sd[i])
             }
             
             if(disp_type==3){#var chart
               disp_low<- (std_err*stat_s2/disp_d_r)
               disp_up<- std_err*stat_s2/disp_d_r
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$var[i])
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,centerline_disp+disp_up)#using MR to get limits
             LCL2<-c(LCL2,centerline_disp-disp_low)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-centerline_disp+disp_up-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,centerline_disp+disp_up)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             if(is.na(centerline_disp-disp_low)){
               zone_a_low_2<-c(zone_a_low_2,0)
               ac2_low<-centerline_disp
             } else {
               zone_a_low_2<-c(zone_a_low_2,centerline_disp-disp_low)
               ac2_low<-disp_low
             }
             #ac2_low<-centerline_2[i]-zone_a_low_2[i]
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac2_low)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac2_low)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         if(disp_type==4){ooc_rules<-spc.rulesets.outside.limits()}
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end median mr of range disp
       
       if(disp_lim_calc==8){#s of disp (individuals for MR)
         for(j in set_id){
           
           if(ind_chart){
             #stat_mr<-sd(points$MR[points$Set==j][!is.na(points$MR)])
             Sample<-unique(points$Sample[points$Set==j])
           }
           
           if(!ind_chart){
            stat_r<-sd(points$range[points$Set==j])#sd of ranges within set
            stat_s<-sd(points$sd[points$Set==j])#sd of ranges within set
            stat_s2<-sd(points$var[points$Set==j])#sd of ranges within set
            Sample<-unique(points$g[points$Set==j])
           }
           
           #use x chart limit choice to calculate underlying process variation
           if(x_lim_calc==1){
             stat_x<-mean(points$range[points$Set==j])#avg range within set
             disp_d_x<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==2){
             stat_x<-median(points$range[points$Set==j])#median range within set
             disp_d_x<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==3){
             stat_x<-mean(points$sd[points$Set==j])#avg sd within set
             disp_d_x<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==4){
             stat_x<-median(points$sd[points$Set==j])#median sd within set
             disp_d_x<-c6(mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==5){
             stat_x<-mean(points$var[points$Set==j])#avg var within set
             sig_est[j]<-sig_est[j]<-sqrt(stat_x)#from variance
           }
           if(ind_chart){#just use s of individuals
             sig_est[j]<-sd(points$Data[points$Set==j])
           }
           if(!ind_chart){
           if(x_lim_calc==6){
             sig_est[j]<-sqrt(n)*mean(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d2(sample.size = 2) #calculated from average MR of the means
           }
           if(x_lim_calc==7){
             sig_est[j]<-sqrt(n)*median(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d4(sample.size = 2) #calculated from median MR of the means
           }
           if(x_lim_calc==8){
             sig_est[j]<-sqrt(n)*sd(points$mean[points$Set==j]) #calculated from s of the means
             }
           }
           if(x_lim_calc==9){
             sig_est[j]<-known_sig_x #entered value
           }
           if(x_lim_calc==10){
             sig_est[j]<-NA
           }
           if(x_lim_calc==11){
             sig_est[j]<-NA
           }
           if(x_lim_calc==12){
             sig_est[j]<-NA
           }
           
           if(disp_type==1){#range chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$range[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$range[points$Set==j])
             }
           }
           
           if(disp_type==2){#s chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$sd[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$sd[points$Set==j])
             }
           }
           
           if(disp_type==3){#var chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(points$var[points$Set==j])
             }
             if(disp_center_type==2){
               centerline_disp<-median(points$var[points$Set==j])
             }
           }
           
           if(disp_type==4){#MR chart centerline
             if(disp_center_type==1){
               centerline_disp<-mean(na.omit(points$MR[points$Set==j]))
             }
             if(disp_center_type==2){
               centerline_disp<-median(na.omit(points$MR[points$Set==j]))
             }
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){
              disp_low<- std_err*stat_r
              disp_up<- std_err*stat_r
              if(centerline_disp-disp_low<0){disp_low<-NA}
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){
               disp_low<- std_err*stat_s
               disp_up<- std_err*stat_s
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$sd[i])
             }
             
             if(disp_type==3){
               disp_low<- std_err*stat_s2
               disp_up<- std_err*stat_s2
               if(centerline_disp-disp_low<0){disp_low<-NA}
               points_2<-c(points_2,points$var[i])
             }
             
             if(disp_type==4){#use the sig_est
               mr_bar<-sig_est[j]*spc.constant.calculation.d2(sample.size = span)
               disp_low<-mr_bar*spc.constant.calculation.D3(sample.size = span,n.sigma = std_err)+centerline_disp
               disp_up<-mr_bar*spc.constant.calculation.D4(sample.size = span,n.sigma = std_err)-centerline_disp
               points_2<-c(points_2,points$MR[i])
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,centerline_disp+disp_up)#using s to get limits
             LCL2<-c(LCL2,centerline_disp-disp_low)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-centerline_disp+disp_up-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,centerline_disp+disp_up)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             if(is.na(centerline_disp-disp_low)){
               zone_a_low_2<-c(zone_a_low_2,0)
               ac2_low<-centerline_disp
             } else {
               zone_a_low_2<-c(zone_a_low_2,centerline_disp-disp_low)
               ac2_low<-disp_low
             }
             #ac2_low<-centerline_2[i]-zone_a_low_2[i]
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac2_low)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac2_low)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         if(disp_type==4){ooc_rules<-spc.rulesets.outside.limits()}
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end s range disp
       
       if(disp_lim_calc==9){#known sigma disp
         for(j in set_id){
           stat<-known_sig_x#known sigma within set
           #disp_d<-spc.constant.calculation.d2(sample.size = n)#used to estimate r bar
           
           #use x chart limit choice to calculate underlying process variation
           if(x_lim_calc==1){
             stat_x<-mean(points$range[points$Set==j])#avg range within set
             disp_d_x<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==2){
             stat_x<-median(points$range[points$Set==j])#median range within set
             disp_d_x<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==3){
             stat_x<-mean(points$sd[points$Set==j])#avg sd within set
             disp_d_x<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==4){
             stat_x<-median(points$sd[points$Set==j])#median sd within set
             disp_d_x<-c6(mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==5){
             stat_x<-mean(points$var[points$Set==j])#avg var within set
             sig_est[j]<-sig_est[j]<-sqrt(stat_x)#from variance
           }
           
           if(!ind_chart){
            if(x_lim_calc==6){
             sig_est[j]<-sqrt(n)*mean(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d2(sample.size = 2) #calculated from average MR of the means
           }
            if(x_lim_calc==7){
             sig_est[j]<-sqrt(n)*median(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d4(sample.size = 2) #calculated from median MR of the means
           }
            if(x_lim_calc==8){
             sig_est[j]<-sqrt(n)*sd(points$mean[points$Set==j]) #calculated from s of the means
             }
           }#end !ind_chart if
           
           if(ind_chart){
             if(x_lim_calc==6){
               sig_est[j]<-stat #sqrt(n)*mean(points$MR[points$Set==j][!is.na(points$MR)])/spc.constant.calculation.d2(sample.size = span) #calculated from average MR of the means
             }
             if(x_lim_calc==7){
               sig_est[j]<-stat#sqrt(n)*median(points$MR[points$Set==j][!is.na(points$MR)])/spc.constant.calculation.d2(sample.size = span) #calculated from median MR of the means
             }
             if(x_lim_calc==8){
               sig_est[j]<-stat#sqrt(n)*sd(points$Data[points$Set==j]) #calculated from s of the means
             }
           }#end ind_chart if
           
           if(x_lim_calc==9){
             sig_est[j]<-known_sig_x #entered value
           }
           if(x_lim_calc==10){
             sig_est[j]<-NA
           }
           if(x_lim_calc==11){
             sig_est[j]<-NA
           }
           if(x_lim_calc==12){
             sig_est[j]<-NA
           }
           
           if(!ind_chart){
           Sample<-unique(points$g[points$Set==j])
           }
           if(ind_chart){
             Sample<-unique(points$Sample[points$Set==j])
           }
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             
             if(disp_type==1){
              mean_est<-stat*spc.constant.calculation.d2(sample.size = n)
              disp_low<- spc.constant.calculation.D3(sample.size = n,n.sigma = std_err)*mean_est
              disp_up<- spc.constant.calculation.D4(sample.size = n,n.sigma = std_err)*mean_est
              centerline_disp<-mean_est
              points_2<-c(points_2,points$range[i])
             }
             
             if(disp_type==2){
               mean_est<-stat*spc.constant.calculation.c4(sample.size = n)
               disp_low<- spc.constant.calculation.B3(sample.size = n,n.sigma = std_err)*mean_est
               disp_up<- spc.constant.calculation.B4(sample.size = n,n.sigma = std_err)*mean_est
               centerline_disp<-mean_est
               points_2<-c(points_2,points$sd[i])
             }
             
             if(disp_type==3){
               p_low<-pnorm(-std_err,0,1)
               p_high<-pnorm(std_err,0,1)
               mean_est<-sig_est[j]^2
               disp_low<-mean_est*qchisq(p = p_low,df = n-1)/(n-1)
               disp_up<-mean_est*qchisq(p = p_high,df = n-1)/(n-1)
               points_2<-c(points_2,points$var[i])
               centerline_disp<-(sig_est[j]*spc.constant.calculation.c4(sample.size = n))^2
             }
             
             if(disp_type==4){#use the sig_est
               mr_bar<-stat*spc.constant.calculation.d2(sample.size = span)
               disp_low<-mr_bar*spc.constant.calculation.D3(sample.size = span,n.sigma = std_err)
               disp_up<-mr_bar*spc.constant.calculation.D4(sample.size = span,n.sigma = std_err)
               points_2<-c(points_2,points$MR[i])
               centerline_disp<-mr_bar
             }
             
             sample2<-c(sample2,i)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_up)#using s of r to get limits
             LCL2<-c(LCL2,disp_low)
             est_sig<-c(est_sig,sig_est[j])
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             ac2<-disp_up-centerline_disp
             zone_a_up_2<-c(zone_a_up_2,disp_up)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*ac2)
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*ac2)
             if(is.na(disp_low)){
               zone_a_low_2<-c(zone_a_low_2,0)
               ac2_low<-centerline_disp
             } else {
               zone_a_low_2<-c(zone_a_low_2,disp_low)
               ac2_low<-disp_low
             }
             #c2_low<-centerline_2[i]-zone_a_low_2[i]
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*ac2_low)
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*ac2_low)
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #####ooc tests
         
         if(disp_type==4){ooc_rules<-spc.rulesets.outside.limits()}
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                               chart.series = points_2,
                                                               center.line = centerline_2,
                                                               control.limits.ucl = UCL2,
                                                               zone.a.upper = zone_a_up_2,
                                                               zone.ab.upper = zone_ab_up_2,
                                                               zone.bc.upper = zone_bc_up_2,
                                                               control.limits.lcl = LCL2,
                                                               zone.a.lower = zone_a_low_2,
                                                               zone.ab.lower = zone_ab_low_2,
                                                               zone.bc.lower = zone_bc_low_2
         )
       }#end known sigma range disp
       
       
       
       
       if(disp_lim_calc==12){#custom disp
         
         for(j in set_id){
           #stat<-known_sig_x#
           #sd_set[j]<-sd(data$Data[data$Set==j])
           
           #use x chart limit choice to calculate underlying process variation
           if(x_lim_calc==1){
             stat_x<-mean(points$range[points$Set==j])#avg range within set
             disp_d_x<-spc.constant.calculation.d2(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==2){
             stat_x<-median(points$range[points$Set==j])#median range within set
             disp_d_x<-spc.constant.calculation.d4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==3){
             stat_x<-mean(points$sd[points$Set==j])#avg sd within set
             disp_d_x<-spc.constant.calculation.c4(sample.size = mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==4){
             stat_x<-median(points$sd[points$Set==j])#median sd within set
             disp_d_x<-c6(mean(points$n[points$Set==j]))
             sig_est[j]<-stat_x/disp_d_x
           }
           if(x_lim_calc==5){
             stat_x<-mean(points$var[points$Set==j])#avg var within set
             sig_est[j]<-sig_est[j]<-sqrt(stat_x)#from variance
           }
           
           
           if(!ind_chart){
             if(x_lim_calc==6){
               sig_est[j]<-sqrt(n)*mean(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d2(sample.size = 2) #calculated from average MR of the means
             }
             if(x_lim_calc==7){
               sig_est[j]<-sqrt(n)*median(abs(diff(points$mean[points$Set==j])))/spc.constant.calculation.d4(sample.size = 2) #calculated from median MR of the means
             }
             if(x_lim_calc==8){
               sig_est[j]<-sqrt(n)*sd(points$mean[points$Set==j]) #calculated from s of the means
             }
             if(x_lim_calc==9){
               sig_est[j]<-known_sig_x #entered value
             }
           }#end !ind_chart if
           
           if(ind_chart){
             if(x_lim_calc==6){
               sig_est[j]<-sqrt(n)*mean(points$MR[points$Set==j][!is.na(points$MR)])/spc.constant.calculation.d2(sample.size = span) 
             }
             if(x_lim_calc==7){
               sig_est[j]<-sqrt(n)*median(points$MR[points$Set==j][!is.na(points$MR)])/spc.constant.calculation.d2(sample.size = span) 
             }
             if(x_lim_calc==8){
               sig_est[j]<-sqrt(n)*sd(points$Data[points$Set==j]) #calculated from s of the means
             }
             if(x_lim_calc==9){
               sig_est[j]<-known_sig_x #entered value
             }
           }#end ind_chart if
           
           if(x_lim_calc==10){
             sig_est[j]<-NA
           }
           if(x_lim_calc==11){
             sig_est[j]<-NA
           }
           if(x_lim_calc==12){
             sig_est[j]<-NA
           }
           
           if(!ind_chart){
             Sample<-unique(points$g[points$Set==j])
           }
           if(ind_chart){
             Sample<-unique(points$Sample[points$Set==j])
           }
           
           centerline_disp<-disp_center_custom
           
           
           for(i in Sample){
             n<-points$n[i]#add n to plot_data
             #loc_const<-std_err/sqrt(n)
             
             if(disp_type==1){
               points_2<-c(points_2,points$range[i])
             }
             if(disp_type==2){
               points_2<-c(points_2,points$sd[i])
             }
             if(disp_type==3){
               points_2<-c(points_2,points$var[i])
             }
             
             if(disp_type==4){
               points_2<-c(points_2,points$MR[i])
             }
             
             sample2<-c(sample2,i)
             #set<-c(set,j)
             #n_k<-c(n_k,n)
             centerline_2<-c(centerline_2,centerline_disp)
             UCL2<-c(UCL2,disp_upper_custom)
             LCL2<-c(LCL2,disp_lower_custom)
             est_sig<-c(est_sig,sig_est[j])#c(est_sig,NA)
             ind_sd<-c(ind_sd,st_dev_ind)
             set_sd<-c(set_sd,sd_set[j])
             #ac1<-centerline_loc+loc_const*stat-centerline_loc
             zone_a_up_2<-c(zone_a_up_2,disp_upper_custom)
             zone_ab_up_2<-c(zone_ab_up_2,centerline_disp+(2/3)*(disp_upper_custom-centerline_disp))
             zone_bc_up_2<-c(zone_bc_up_2,centerline_disp+(1/3)*(disp_upper_custom-centerline_disp))
             if(is.na(disp_lower_custom)){disp_lower_custom<-0}
             zone_a_low_2<-c(zone_a_low_2,disp_lower_custom)
             zone_ab_low_2<-c(zone_ab_low_2,centerline_disp-(2/3)*(centerline_disp-disp_lower_custom))
             zone_bc_low_2<-c(zone_bc_low_2,centerline_disp-(1/3)*(centerline_disp-disp_lower_custom))
             
           }
         }#end j loop through sets
         
         #####combine
         plot_data_disp<-cbind(sample2,points_2,LCL2,centerline_2,UCL2,est_sig,ind_sd,set_sd,zone_a_up_2,zone_ab_up_2,zone_bc_up_2,zone_a_low_2,zone_ab_low_2,zone_bc_low_2)
         
         plot_data_disp<-as.data.frame(plot_data_disp[order(sample2),])
         
         #if(is.na(disp_lower_custom) || disp_lower_custom<0){disp_lower_custom<-0}#accomodate no LCL
         #####ooc tests
         if(is.na(disp_lower_custom) || disp_lower_custom<0){
           cl_lcl<-rep(0,k_obs)}
         else{
           cl_lcl<-plot_data_disp$LCL2
         }
         
         if(disp_type==4){ooc_rules<-spc.rulesets.outside.limits()}
         
         control_vio_disp<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                            chart.series = plot_data_disp$points_2,
                                                            center.line = plot_data_disp$centerline_2,
                                                            control.limits.ucl = plot_data_disp$UCL2,
                                                            zone.a.upper = plot_data_disp$zone_a_up_2,
                                                            zone.ab.upper = plot_data_disp$zone_ab_up_2,
                                                            zone.bc.upper = plot_data_disp$zone_bc_up_2,
                                                            control.limits.lcl = cl_lcl, #accommodate no LCL doesn't work yet ERROR in spc.controlviolation.nelson.1984.test2.runs.below
                                                            zone.a.lower = plot_data_disp$zone_a_low_2,
                                                            zone.ab.lower = plot_data_disp$zone_ab_low_2,
                                                            zone.bc.lower = plot_data_disp$zone_bc_low_2
         )
         
       }#end custom disp
       
       #add more disp limits here
       
       plot_data<-c(plot_data,plot_data_disp,x=control_vio_x,disp=control_vio_disp)
       
       ###final chart
       #bring together chart elements into a dataframe
       x_name<-names(choice_x_spc)[as.numeric(x_type)]
       disp_name<-names(choice_disp_spc)[as.numeric(disp_type)]
       
       x_label<-c(rep(1:k_obs,2))
       set<-c(rep(plot_data$set,2))
       n_sample<-c(rep(n_k,2))
       facet<-c(rep(x_name,k_obs),rep(disp_name,k_obs))
       UCL<-c(plot_data[["UCL1"]],plot_data[["UCL2"]])
       LCL<-c(plot_data[["LCL1"]],plot_data[["LCL2"]])
       measure<-c(plot_data[["points_1"]],plot_data[["points_2"]])
       centerline<-c(plot_data[["centerline_1"]],plot_data[["centerline_2"]])
       outside<-c(plot_data[["x.rule.results"]][["outside.limits"]],plot_data[["disp.rule.results"]][["outside.limits"]])
       runs<-c(plot_data[["x.rule.results"]][["runs"]],plot_data[["disp.rule.results"]][["runs"]])
       zone_a_up<-c(plot_data[["zone_a_up_1"]],plot_data[["zone_a_up_2"]])
       zone_a_low<-c(plot_data[["zone_a_low_1"]],plot_data[["zone_a_low_2"]])
       zone_bc_up<-c(plot_data[["zone_bc_up_1"]],plot_data[["zone_bc_up_2"]])
       zone_bc_low<-c(plot_data[["zone_bc_low_1"]],plot_data[["zone_bc_low_2"]])
       zone_ab_up<-c(plot_data[["zone_ab_up_1"]],plot_data[["zone_ab_up_2"]])
       zone_ab_low<-c(plot_data[["zone_ab_low_1"]],plot_data[["zone_ab_low_2"]])
       trends<-c(plot_data[["x.rule.results"]][["trends"]],plot_data[["disp.rule.results"]][["trends"]])
       alternating<-c(plot_data[["x.rule.results"]][["alternating"]],plot_data[["disp.rule.results"]][["alternating"]])
       zone_a<-c(plot_data[["x.rule.results"]][["zone.a"]],plot_data[["disp.rule.results"]][["zone.a"]])
       consec_c<-c(plot_data[["x.rule.results"]][["consecutive.zone.c"]],plot_data[["disp.rule.results"]][["consecutive.zone.c"]])
       consec_ab<-c(plot_data[["x.rule.results"]][["consecutive.zone.ab"]],plot_data[["disp.rule.results"]][["consecutive.zone.ab"]])
       zone_a_b<-c(plot_data[["x.rule.results"]][["consecutive.zone.ab"]],plot_data[["disp.rule.results"]][["consecutive.zone.ab"]])
       est_sig<-plot_data$est_sig
       ind_s<-plot_data$ind_s
       set_sd<-plot_data$set_sd
       
       plot_order<-factor(facet,levels = c(x_name,disp_name))#needed so that the charts are in the right order
       
       #assemble data for final plot first one is reactive and available outside of the plotting subroutine
       plot_data_r<<-reactive(data.frame(x_label,
                                         facet,
                                         n_sample,
                                         set,
                                         UCL,
                                         LCL,
                                         measure,
                                         est_sig,
                                         ind_s,
                                         set_sd,
                                         centerline,
                                         outside,
                                         runs,
                                         zone_bc_up,
                                         zone_bc_low,
                                         zone_ab_up,
                                         zone_ab_low,
                                         zone_a_up,
                                         zone_a_low,
                                         trends,
                                         alternating,
                                         zone_a,
                                         consec_c,
                                         consec_ab,
                                         zone_a_b,plot_order)[order(-xtfrm(facet),x_label),])
       plot_data_change<<-plot_data_change+1
       plot_data_p<-plot_data_r()#this one will be modified for plotting
       
       ooc_x<-input$ooc_rules_x
       ooc_disp<-input$ooc_rules_disp
       
       if(is.null(ooc_x)){ooc_x<-c(1,2,3,4)}#added these since these inputs are lazy and NULL until clicked on - shouldn't see NULL after that set
       if(is.null(ooc_disp)){ooc_disp<-c(1)}

       for(i in 1:(k_obs)){#loop through location
         if(plot_data_p$outside[i]==TRUE && is.element(1,ooc_x)){
           plot_data_p$outside[i]<-plot_data_p$measure[i]
         } else {plot_data_p$outside[i]<-NA}
         if(plot_data_p$runs[i]==TRUE && is.element(2,ooc_x)){
           plot_data_p$runs[i]<-plot_data_p$measure[i]
         } else {plot_data_p$runs[i]<-NA}
         if(plot_data_p$trends[i]==TRUE && is.element(3,ooc_x)){
           plot_data_p$trends[i]<-plot_data_p$measure[i]
         } else {plot_data_p$trends[i]<-NA}
         if(plot_data_p$alternating[i]==TRUE && is.element(4,ooc_x)){
           plot_data_p$alternating[i]<-plot_data_p$measure[i]
         } else {plot_data_p$alternating[i]<-NA}
         if(plot_data_p$zone_a[i]==TRUE && is.element(5,ooc_x)){
           plot_data_p$zone_a[i]<-plot_data_p$measure[i]
         } else {plot_data_p$zone_a[i]<-NA}
         if(plot_data_p$consec_c[i]==TRUE && is.element(6,ooc_x)){
           plot_data_p$consec_c[i]<-plot_data_p$measure[i]
         } else {plot_data_p$consec_c[i]<-NA}
         if(plot_data_p$consec_ab[i]==TRUE && is.element(7,ooc_x)){
           plot_data_p$consec_ab[i]<-plot_data_p$measure[i]
         } else {plot_data_p$consec_ab[i]<-NA}
         if(plot_data_p$zone_a_b[i]==TRUE && is.element(8,ooc_x)){
           plot_data_p$zone_a_b[i]<-plot_data_p$measure[i]
         } else {plot_data_p$zone_a_b[i]<-NA}
       }
       
       
       for (i in (seq(from=k_obs+1, to=k_obs*2))){#loop through dispersion
         if(plot_data_p$outside[i]==TRUE && is.element(1,ooc_disp)){
           plot_data_p$outside[i]<-plot_data_p$measure[i]
         } else {plot_data_p$outside[i]<-NA}
         if(plot_data_p$runs[i]==TRUE && is.element(2,ooc_disp)){
           plot_data_p$runs[i]<-plot_data_p$measure[i]
         } else {plot_data_p$runs[i]<-NA}
         if(plot_data_p$trends[i]==TRUE && is.element(3,ooc_disp)){
           plot_data_p$trends[i]<-plot_data_p$measure[i]
         } else {plot_data_p$trends[i]<-NA}
         if(plot_data_p$alternating[i]==TRUE && is.element(4,ooc_disp)){
           plot_data_p$alternating[i]<-plot_data_p$measure[i]
         } else {plot_data_p$alternating[i]<-NA}
         if(plot_data_p$zone_a[i]==TRUE && is.element(5,ooc_disp)){
           plot_data_p$zone_a[i]<-plot_data_p$measure[i]
         } else {plot_data_p$zone_a[i]<-NA}
         if(plot_data_p$consec_c[i]==TRUE && is.element(6,ooc_disp)){
           plot_data_p$consec_c[i]<-plot_data_p$measure[i]
         } else {plot_data_p$consec_c[i]<-NA}
         if(plot_data_p$consec_ab[i]==TRUE && is.element(7,ooc_disp)){
           plot_data_p$consec_ab[i]<-plot_data_p$measure[i]
         } else {plot_data_p$consec_ab[i]<-NA}
         if(plot_data_p$zone_a_b[i]==TRUE && is.element(8,ooc_disp)){
           plot_data_p$zone_a_b[i]<-plot_data_p$measure[i]
         } else {plot_data_p$zone_a_b[i]<-NA}
         
       }
       
       #set columns with no OOC as numeric to avoid error
       plot_data_p$outside<-as.numeric(plot_data_p$outside)
       plot_data_p$runs<-as.numeric(plot_data_p$runs)
       plot_data_p$trends<-as.numeric(plot_data_p$trends)
       plot_data_p$alternating<-as.numeric(plot_data_p$alternating)
       plot_data_p$zone_a<-as.numeric(plot_data_p$zone_a)
       plot_data_p$consec_c<-as.numeric(plot_data_p$consec_c)
       plot_data_p$consec_ab<-as.numeric(plot_data_p$consec_ab)
       plot_data_p$zone_a_b<-as.numeric(plot_data_p$zone_a_b)
       
        
       plot_data_p<-plot_data_p[order(-xtfrm(facet),x_label),]
       
       #plot_data_p$plot_order<-factor(plot_data_p$facet,levels = c(x_name,disp_name))#needed so that the charts are in the right order
       
       #requested OOCs
       #x_chart_options<-c(1,2,3,4)
       x_chart_options<-input$x_chart_options
       
       #make the subtitle
       disp_labels<-c("R","s","s\U00B2","MR")
       
       if(disp_type==2){
         choice_r_limits2<-(1:12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s",
           "Median MR of s",
           "Standard Deviation of s",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
       
       if(disp_type==3){
         choice_r_limits2<-(1:12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s\U00B2",
           "Median MR of s\U00B2",
           "Standard Deviation of s\U00B2",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
         
         if(disp_type==4){
           choice_r_limits2<-(1:12)#for spc charts
           names(choice_r_limits2)<-c(
             "Average Range",
             "Median Range",
             "Average Standard Deviation",
             "Median Standard Deviation",
             "Average Variance",
             "Average MR",
             "Median MR",
             "Standard Deviation of X",
             "Known \U03c3",
             "Centerline Only",
             "None",
             "Custom"
           )
       }
       
       if(x_type==1){
         subtitle<-paste("X-bar & ",disp_labels[as.numeric(disp_type)],":: Location Limits from ",names(choice_x_bar_limits2[as.numeric(x_lim_calc)]),", Dispersion Limits from",names(choice_r_limits2[as.numeric(disp_lim_calc)]))
       }
       if(x_type==2){
         
           choice_x_bar_limits2<-(1:12)#for generating spc charts - all x charts
           names(choice_x_bar_limits2)<-c(
             "Average Range",
             "Median Range",
             "Average Standard Deviation",
             "Median Standard Deviation",
             "Average Variance",
             "Average Moving Range of X",
             "Median Moving Range of X",
             "Standard Deviation of X",
             "Known \U03c3",
             "Centerline Only",
             "None",
             "Custom")
           
         subtitle<-paste("X & ",disp_labels[as.numeric(disp_type)],":: Location Limits from ",names(choice_x_bar_limits2[as.numeric(x_lim_calc)]),", Dispersion Limits from",names(choice_r_limits2[as.numeric(disp_lim_calc)]))
       }
       #add increment to plot data for sets
       diff_t<-c(0,diff(plot_data_p$set))
       set_plot<-1
       for(i in seq(1,(k_obs))){
         if(i==1){next}
         if(diff_t[i]!=0){
           set_plot[i]<-set_plot[i-1]+1
         }else {set_plot[i]<-set_plot[i-1]}
       }
       set_plot<-c(set_plot,set_plot)
       cbind(plot_data,set_plot)
       #base plot
       p<-ggplot(plot_data_p,aes(x=x_label,y=measure))+
         facet_grid(plot_order~.,scales="free_y")+
         labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = subtitle)+
         theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
       
       #zones
       if(is.element(9,ooc_x) || is.element(6,x_chart_options)){
         trans<-90
         rgb_outer<-col2rgb(color[2])
         rgb_mid<-col2rgb(color[7])
         rgb_inner<-col2rgb(color[3])
         
         outer_col<-rgb(red = rgb_outer[1],green = rgb_outer[2],blue = rgb_outer[3],alpha = trans, maxColorValue = 255)
         mid_col<-rgb(red = rgb_mid[1],green = rgb_mid[2],blue = rgb_mid[3],alpha = trans, maxColorValue = 255)
         inner_col<-rgb(red = rgb_inner[1],green = rgb_inner[2],blue = rgb_inner[3],alpha = trans, maxColorValue = 255)
         
         
         
         p<-p+
           geom_ribbon(aes(ymin=zone_a_low,ymax=zone_a_up, group=set_plot),fill=outer_col)+#outer third
           geom_ribbon(aes(ymin=zone_ab_low,ymax=zone_ab_up, group=set_plot),fill=mid_col)+
           geom_ribbon(aes(ymin=zone_bc_low,ymax=zone_bc_up, group=set_plot),fill=inner_col)
       }
       
       #lines and points
       p<-p+geom_point(color=color[4])
       if(is.element(1,x_chart_options)){
         p<-p+geom_line(aes(group=set_plot),color=color[4])
       }
       if(is.element(3,x_chart_options)){
         p<-p+geom_line(aes(y=centerline, group=set_plot),color=color[3])#add centerline
       }
       
       #limits
       if(is.element(2,x_chart_options)){
         p<-p+
           geom_line(aes(y=UCL, group=set_plot),color=color[2],linetype=5)+#add cl
           geom_line(aes(y=LCL, group=set_plot),color=color[2],linetype=5)#add cl
       }
       
       #ooc points
       # if(is.element(1,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=outside,label="O"),nudge_x = .75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=outside),color=color[2],shape=8)#add points outside
         }
       # }
       # if(is.element(2,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=runs,label="R"),nudge_x = -.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=runs),color=color[2],shape=8)#runs
         }
       # }
       # if(is.element(3,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=trends,label="T"),nudge_y = .75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=trends),color=color[2],shape=8)#trends
         }
       # }
       # if(is.element(4,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=alternating,label="A"),nudge_y = -.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=alternating),color=color[2],shape=8)
         }
       # }
       # if(is.element(5,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=zone_a,label="Z-a"),nudge_y = .75,nudge_x=.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=zone_a),color=color[2],shape=8)
         }
       # }
       # if(is.element(6,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=consec_c,label="C-c"),nudge_y = -.75,nudge_x=.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=consec_c),color=color[2],shape=8)
         }
       # }
       # if(is.element(7,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=consec_ab,label="C-ab"),nudge_y = .75,nudge_x=-.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=consec_ab),color=color[2],shape=8)
         }
       # }
       # if(is.element(8,ooc)){
         if(is.element(5,x_chart_options)){
           p<-p+geom_text(aes(y=zone_a_b,label="Z-ab"),nudge_y = -.75,nudge_x=-.75,color=color[2])
         }
         if(is.element(4,x_chart_options)){
           p<-p+geom_point(aes(y=zone_a_b),color=color[2],shape=8)
         }
       # }
       
       #ggsave(paste("spc_plot.",input$download_spc_x_format,sep=""),p)
      p#final graph
     })
     
     output$hover_info_x <- renderUI({
       loc_type<-input$spc_var_loc_type#these are here to trigger if the chart changes
       disp_type<-input$spc_var_disp_type
       R<-input$spc_x_anova_decimals
       hover <- input$plot_hover
       if(is.null(hover)){return()}
       point <- nearPoints(plot_data_r(), hover, threshold = 5, maxpoints = 1, addDist = TRUE)
       if (nrow(point) == 0) return(NULL)
       
       
       # calculate distance from left and bottom side of the picture in pixels
       left_px <- hover$coords_css$x
       top_px <- hover$coords_css$y
       
       
       # create style property for tooltip
       # background color is set so tooltip is a bit transparent
       # z-index is set so we are sure are tooltip will be on top
       style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
                       "left:", left_px + 2, "px; top:", top_px + 2, "px;")
       
       # actual tooltip created as wellPanel
       wellPanel(
         style = style,
         p(HTML(paste0(
           "<span style='display:block; text-transform:capitalize; text-align:center'>",point$facet,"</span>",
           "<b> Point: </b>", ro(point$x_label,R), "<br/>",
           "<b> Measure: </b>", ro(point$measure,R), "<br/>",
           if(length(unique(plot_data_r()$set))>1){
             paste0("<b> Set: </b>", point$set, "<br/>")
           },
           "<b> UCL: </b>", ro(point$UCL,R), "<br/>",
           "<b> Centerline: </b>", ro(point$centerline,R), "<br/>",
           "<b> LCL: </b>", ro(point$LCL,R))))
       )
     })
     
     output$spc_anova<-renderUI({#oneway table for SPC
       data<- res_filter$filtered()
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       sets<-as.numeric(input$spc_var_set)#number of column with sets in it, 0 if no sets
       req(data)
       req(data_type)
       
       
       
       
       
       if(input$spc_var_loc_type==2){
         return(p("Cannot perform ANOVA on individual data."))
       }
       
       #change row data to column
       if(data_type==1){#row is subgroup
         req(length(UI1)>1)
         k_obs<-nrow(data)
         data<-transform.dependent.format.to.independent.format(data = data[UI1])
         if(sets==0){
           data<-cbind("Data"=data,"Sample"=seq(1,k_obs))
           names(data)<-c("Name","Data","Sample")
         }
         else {
           data<-cbind("Data"=data,"Sample"=seq(1,k_obs),"Sets"=sets)
           names(data)<-c("Name","Data","Sample","Sets")
         }
         
       }
       else{
         req(UI2)
         if(sets==0){
           data<-cbind("Data"=data[UI2],"Sample"=data[UI1])#,"Sets"=data[sets])
           names(data)<-c("Data","Sample")
         }
         else{
           data<-cbind("Data"=data[UI2],"Sample"=data[UI1],"Sets"=data[sets])
           names(data)<-c("Data","Sample","Sets")
         }
         
       }
       #data is now in subgroups defined by a column Sample, data in column Data, set in column Sets (if present)
       
       # data_col<-as.numeric(input$ow_data)
       # factor_ow<-as.numeric(input$ow_factor)
       conf<-input$spc_x_anova_conf
       R<-input$spc_x_anova_decimals
       
       
       if(sets==0){#no sets, one ANOVA
         oneway<-aov(formula = Data~as.factor(Sample),data = data)
         #sum_aov<-ro(summary(oneway),R)
         sum_aov<-summary(oneway)
         
         sse<-sum_aov[[1]][["Sum Sq"]][1]
         ssw<-sum_aov[[1]][["Sum Sq"]][2]
         dfe<-sum_aov[[1]][["Df"]][1]
         dfw<-sum_aov[[1]][["Df"]][2]
         mse<-sum_aov[[1]][["Mean Sq"]][1]
         msw<-sum_aov[[1]][["Mean Sq"]][2]
         sst<-sse+ssw
         dft<-dfe+dfw
         
         #omega_sq<-100*(sse-(dfe*msw))/(sst+msw)#fixed
         
         table_aov<-as.data.frame(table(data$Sample))
         table_aov<-cbind(table_aov,table_aov[2]^2)
         J<-nrow(table_aov)
         sum_n<-colSums(table_aov[2])
         sum_nsq<-colSums(table_aov[3])
         K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
         
         bcv<-(mse-msw)/K_prime
         bcv<-max(0,bcv)
         ICC<-100*bcv/(bcv+msw)
         
         output<-
           HTML(c(
             #"<style> td,th{padding: 2px 15px !important;}</style>", style="padding: 2px 15px !important;"
             "<u>Model : ",names(oneway$model)[1]," by ",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),
             "</u></br></br>",
             "<table><tr><th  style='padding: 2px 15px !important;'>Source</th><th  style='padding: 2px 15px !important;'>df</th><th  style='padding: 2px 15px !important;'>SS</th><th  style='padding: 2px 15px !important;'>MS</th><th  style='padding: 2px 15px !important;'>F</th><th  style='padding: 2px 15px !important;'>p</th></tr>",
             "<tr><td  style='padding: 2px 15px !important;'>","Between Samples","</td>",
             "<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["F value"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Pr(>F)"]][1],R),if(sum_aov[[1]][["Pr(>F)"]][1]<(1-conf)){"*"},"</tr>",
             "<tr><td  style='padding: 2px 15px !important;'> Within Samples</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][2],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][2],R),"</td></tr>",
             "<tr><td  style='padding: 2px 15px !important;'> Total</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1]+sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1]+sum_aov[[1]][["Sum Sq"]][2],R),"</td></tr>",
             "</table></br></br>",
               paste(
                 "<table><tr><td>Random Effect Importance:</td></tr>",
                 "<tr><td>Sample-to-Sample Variance =</td><td>",ro(bcv,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{treat}=$"),ro(bcv^.5,R),"</tr>",
                 "<tr><td>Within Sample Variance =</td><td>",ro(msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{within}=$"),ro(msw^.5,R),"</tr>",
                 "<tr><td>Total Variance =</td><td>",ro(bcv+msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{total}=$"),ro((bcv+msw)^.5,R),"</tr>",
                 "<tr><td><b>Intraclass Correlation =</b></td><td><b>",ro(ICC,R),"%</b></td>","</tr>",
                 "</table><br/>"
               )
             
           ))#end html
       }
       
       if(sets!=0){#need to accommodate sets
         
         set<-unique(data$Set)
         
         for(i in set){
           if(i==set[1]){#first ANOVA
             oneway<-aov(formula = Data~as.factor(Sample),data = data[which(data$Set==i),])
             #sum_aov<-ro(summary(oneway),R)
             sum_aov<-summary(oneway)
             
             sse<-sum_aov[[1]][["Sum Sq"]][1]
             ssw<-sum_aov[[1]][["Sum Sq"]][2]
             dfe<-sum_aov[[1]][["Df"]][1]
             dfw<-sum_aov[[1]][["Df"]][2]
             mse<-sum_aov[[1]][["Mean Sq"]][1]
             msw<-sum_aov[[1]][["Mean Sq"]][2]
             sst<-sse+ssw
             dft<-dfe+dfw
             
             #omega_sq<-100*(sse-(dfe*msw))/(sst+msw)#fixed
             
             table_aov<-as.data.frame(table(data$Sample[which(data$Set==i)]))
             table_aov<-cbind(table_aov,table_aov[2]^2)
             J<-nrow(table_aov)
             sum_n<-colSums(table_aov[2])
             sum_nsq<-colSums(table_aov[3])
             K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
             
             bcv<-(mse-msw)/K_prime
             bcv<-max(0,bcv)
             ICC<-100*bcv/(bcv+msw)
             
             output<-
               HTML(c(
                 #"<style> td,th{padding: 2px 15px !important;}</style>", style="padding: 2px 15px !important;"
                 "<u>Model Set ",i," : ",names(oneway$model)[1]," by ",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),
                 "</u></br></br>",
                 "<table><tr><th  style='padding: 2px 15px !important;'>Source</th><th  style='padding: 2px 15px !important;'>df</th><th  style='padding: 2px 15px !important;'>SS</th><th  style='padding: 2px 15px !important;'>MS</th><th  style='padding: 2px 15px !important;'>F</th><th  style='padding: 2px 15px !important;'>p</th></tr>",
                 "<tr><td  style='padding: 2px 15px !important;'>","Between Samples","</td>",
                 "<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["F value"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Pr(>F)"]][1],R),if(sum_aov[[1]][["Pr(>F)"]][1]<(1-conf)){"*"},"</tr>",
                 "<tr><td  style='padding: 2px 15px !important;'> Within Samples</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][2],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][2],R),"</td></tr>",
                 "<tr><td  style='padding: 2px 15px !important;'> Total</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1]+sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1]+sum_aov[[1]][["Sum Sq"]][2],R),"</td></tr>",
                 "</table></br></br>",
                 paste(
                   "<table><tr><td>Random Effect Importance:</td></tr>",
                   "<tr><td>Sample-to-Sample Variance =</td><td>",ro(bcv,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{treat}=$"),ro(bcv^.5,R),"</tr>",
                   "<tr><td>Within Sample Variance =</td><td>",ro(msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{within}=$"),ro(msw^.5,R),"</tr>",
                   "<tr><td>Total Variance =</td><td>",ro(bcv+msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{total}=$"),ro((bcv+msw)^.5,R),"</tr>",
                   "<tr><td><b>Intraclass Correlation =</b></td><td><b>",ro(ICC,R),"%</b></td>","</tr>",
                   "</table><br/>"
                 )
                 
               ))#end html
           }#end if first ANOVA
         else{
         
         oneway<-aov(formula = Data~as.factor(Sample),data = data[which(data$Set==i),])
         #sum_aov<-ro(summary(oneway),R)
         sum_aov<-summary(oneway)
         
         sse<-sum_aov[[1]][["Sum Sq"]][1]
         ssw<-sum_aov[[1]][["Sum Sq"]][2]
         dfe<-sum_aov[[1]][["Df"]][1]
         dfw<-sum_aov[[1]][["Df"]][2]
         mse<-sum_aov[[1]][["Mean Sq"]][1]
         msw<-sum_aov[[1]][["Mean Sq"]][2]
         sst<-sse+ssw
         dft<-dfe+dfw
         
         #omega_sq<-100*(sse-(dfe*msw))/(sst+msw)#fixed
         
         table_aov<-as.data.frame(table(data$Sample[which(data$Set==i)]))
         table_aov<-cbind(table_aov,table_aov[2]^2)
         J<-nrow(table_aov)
         sum_n<-colSums(table_aov[2])
         sum_nsq<-colSums(table_aov[3])
         K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
         
         bcv<-(mse-msw)/K_prime
         bcv<-max(0,bcv)
         ICC<-100*bcv/(bcv+msw)
         
         output<-
           HTML(c(output,
             #"<style> td,th{padding: 2px 15px !important;}</style>", style="padding: 2px 15px !important;"
             "<u>Model Set ",i," : ",names(oneway$model)[1]," by ",gsub(pattern = "as\\.factor\\(|\\)",replacement = "",names(oneway$model)[2]),
             "</u></br></br>",
             "<table><tr><th  style='padding: 2px 15px !important;'>Source</th><th  style='padding: 2px 15px !important;'>df</th><th  style='padding: 2px 15px !important;'>SS</th><th  style='padding: 2px 15px !important;'>MS</th><th  style='padding: 2px 15px !important;'>F</th><th  style='padding: 2px 15px !important;'>p</th></tr>",
             "<tr><td  style='padding: 2px 15px !important;'>","Between Samples","</td>",
             "<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["F value"]][1],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Pr(>F)"]][1],R),if(sum_aov[[1]][["Pr(>F)"]][1]<(1-conf)){"*"},"</tr>",
             "<tr><td  style='padding: 2px 15px !important;'> Within Samples</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][2],R),"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Mean Sq"]][2],R),"</td></tr>",
             "<tr><td  style='padding: 2px 15px !important;'> Total</td>","<td  style='padding: 2px 15px !important;'>",sum_aov[[1]][["Df"]][1]+sum_aov[[1]][["Df"]][2],"</td><td  style='padding: 2px 15px !important;'>",ro(sum_aov[[1]][["Sum Sq"]][1]+sum_aov[[1]][["Sum Sq"]][2],R),"</td></tr>",
             "</table></br></br>",
             paste(
               "<table><tr><td>Random Effect Importance:</td></tr>",
               "<tr><td>Sample-to-Sample Variance =</td><td>",ro(bcv,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{treat}=$"),ro(bcv^.5,R),"</tr>",
               "<tr><td>Within Sample Variance =</td><td>",ro(msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{within}=$"),ro(msw^.5,R),"</tr>",
               "<tr><td>Total Variance =</td><td>",ro(bcv+msw,R),"</td><td>",withMathJax("$\\hat{\\sigma}_{total}=$"),ro((bcv+msw)^.5,R),"</tr>",
               "<tr><td><b>Intraclass Correlation =</b></td><td><b>",ro(ICC,R),"%</b></td>","</tr>",
               "</table>"
             )
             
           ))#end html
         }#end of else not first ANOVA
         }#end loop
       }#end if sets !=0
         
       output
     })
     
     output$xbar_table_out<-DT::renderDataTable({
       dat<-plot_data_r()
       R<-input$spc_x_anova_decimals
       
       #need these to trigger recalculation if any of them change
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       req(UI1)
       x_type<-input$spc_var_loc_type
       disp_type<-input$spc_var_disp_type
       span<-input$spc_mr_span
       x_lim_calc<-input$spc_var_loc_lim
       disp_lim_calc<-input$spc_var_disp_lim
       loc_upper_custom<-input$custom.x.upper
       loc_center_custom<-input$custom.x.center
       loc_lower_custom<-input$custom.x.lower
       disp_upper_custom<-input$custom.disp.upper
       disp_center_custom<-input$custom.disp.center
       disp_lower_custom<-input$custom.disp.lower
       sets<-as.numeric(input$spc_var_set)
       std_err<-as.numeric(input$std_err_x)
       known_sig<-input$known_sig_x
       loc_center_type<-input$spc_x_loc
       disp_center_type<-input$spc_x_disp
       
       # run<-plot_data_change#did the reactive plot_data_r()change if so trigger this
       # ind_chart<-input$spc_var_ind_or_mean
       # 
       # #dat<-plot_data_r()
       # if(ind_chart){#testing to make sure data has changed before executing again
       #   if(dat$facet[1]!="X"){
       #     return()
       #   }
       # } else{
       #   if(dat$facet[1]!="X-bar"){
       #     return()
       #   }
       # }
       
       
       ro(DT::datatable(data = dat,options=list(dom="t",paging=FALSE),rownames = F),R)
       })
     
     output$ooc_rules_x_ui<-renderUI({
       x_lim_calc<-as.numeric(input$spc_var_loc_lim)
       
       if(x_lim_calc<10 || x_lim_calc == 12){
         output<-pickerInput(
           inputId = "ooc_rules_x",
           label = "Out-of-Control Rules - Location",
           selected = c(1,2,3,4),
           multiple = TRUE,
           choices = list(
             Basic = c("Points Outside Limits"=1, "Runs"=2, "Trend of 6"=3, "14 Alternating Values"=4),
             Zones = c("2 out of 3 in Outer Third"=5,"15 in Inner Third"=6, "4 out of 5 in Outer Two-thirds"=7, "8 in Outer Two-thirds"))
         )
       }
       if(x_lim_calc==10){
         output<-pickerInput(
           inputId = "ooc_rules_x",
           label = "Out-of-Control Rules - Location",
           selected = c(2),
           multiple = TRUE,
           choices = list(Basic = c("Runs"=2))
         )
       }
       if(x_lim_calc==11){
         output<-NULL
       }
       output
     })
     
     output$ooc_rules_disp_ui<-renderUI({
       disp_lim_calc<-as.numeric(input$spc_var_disp_lim)
       x_type<-as.numeric(input$spc_var_loc_type)
       
       if(x_type==2 && (disp_lim_calc==6 || disp_lim_calc== 7)){
         return(output<-pickerInput(
           inputId = "ooc_rules_disp",
           label = "Out-of-Control Rules - Dispersion",
           selected = c(1),
           multiple = TRUE,
           choices = list(
             Basic = c("Points Outside Limits"=1))
         ))
       }
       
       if(disp_lim_calc<10 || disp_lim_calc == 12){
         output<-pickerInput(
           inputId = "ooc_rules_disp",
           label = "Out-of-Control Rules - Dispersion",
           selected = c(1),
           multiple = TRUE,
           choices = list(
             Basic = c("Points Outside Limits"=1, "Runs"=2, "Trend of 6"=3, "14 Alternating Values"=4),
             Zones = c("2 out of 3 in Outer Third"=5,"15 in Inner Third"=6, "4 out of 5 in Outer Two-thirds"=7, "8 in Outer Two-thirds"))
         )
       }
       if(disp_lim_calc==10){
         output<-pickerInput(
           inputId = "ooc_rules_disp",
           label = "Out-of-Control Rules - Dispersion",
           multiple = TRUE,
           choices = list(Basic = c("Runs"=2))
         )
       }
       if(disp_lim_calc==11){
         output<-NULL
       }
       output
     })
     
     output$limit_analysis_x<-renderUI({
       #stuff that can change to trigger this output
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       req(UI1)
       x_type<-input$spc_var_loc_type
       disp_type<-input$spc_var_disp_type
       span<-input$spc_mr_span
       loc_upper_custom<-input$custom.x.upper
       loc_center_custom<-input$custom.x.center
       loc_lower_custom<-input$custom.x.lower
       disp_upper_custom<-input$custom.disp.upper
       disp_center_custom<-input$custom.disp.center
       disp_lower_custom<-input$custom.disp.lower
       sets<-as.numeric(input$spc_var_set)
       known_sig<-input$known_sig_x
       
       run<-plot_data_change#did the reactive plot_data_r()change if so trigger this
       ind_chart<-input$spc_var_ind_or_mean
       
       dat<-plot_data_r()
       if(ind_chart){#testing to make sure data has changed before executing again
         if(dat$facet[1]!="X"){
           return()
         }
       } else{
         if(dat$facet[1]!="X-bar"){
           return()
         }
       }
       
       #needed for output
       #dat<-plot_data_r()
       R<-input$spc_x_anova_decimals
       loc_center_type<-as.numeric(input$spc_x_loc)
       disp_center_type<-as.numeric(input$spc_x_disp)
       x_lim_calc<-as.numeric(input$spc_var_loc_lim)
       disp_lim_calc<-as.numeric(input$spc_var_disp_lim)
       std_err<-as.numeric(input$std_err_x)
       
       if(disp_type==2){
         choice_r_limits2<-(1:12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s",
           "Median MR of s",
           "Standard Deviation of s",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
       
       if(disp_type==3){
         choice_r_limits2<-(1:12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR of s\U00B2",
           "Median MR of s\U00B2",
           "Standard Deviation of s\U00B2",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
       
       if(disp_type==4){
         choice_r_limits2<-(1:12)#for spc charts
         names(choice_r_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average MR",
           "Median MR",
           "Standard Deviation of X",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
       
       if(x_type==2){
         choice_x_bar_limits2<-(1:12)#for generating spc charts - all x charts
         names(choice_x_bar_limits2)<-c(
           "Average Range",
           "Median Range",
           "Average Standard Deviation",
           "Median Standard Deviation",
           "Average Variance",
           "Average Moving Range of X",
           "Median Moving Range of X",
           "Standard Deviation of X",
           "Known \U03c3",
           "Centerline Only",
           "None",
           "Custom"
         )
       }
       
       if(disp_type==4){
         sigma_from<-names(choice_r_limits2)[disp_lim_calc]
       } else if(disp_lim_calc<6){
         sigma_from<-names(choice_r_limits2)[disp_lim_calc]
       } else {sigma_from<-names(choice_x_bar_limits2)[as.numeric(x_lim_calc)]}
       
       output<-HTML(c(
         "<h4>Limit Calculation Summary</h4>",
         "<table>",
        "<tr><td><u>",names(choice_x_spc)[as.numeric(x_type)]," Chart</u></td>",
        "<td></td></tr>",
        "<tr><td>Limits from:</td><td style='text-align:left'>",names(choice_x_bar_limits2[x_lim_calc]),"</td></tr>",
        "<tr><td>Centerline:</td><td style='text-align:left'>",if(x_lim_calc==11){"None"}else if(x_lim_calc==12){"Custom"}else{names(choice_x_centerline)[loc_center_type]},"</td></tr>",
        
        "<td><u>",names(choice_disp_spc)[as.numeric(disp_type)]," Chart</u></td>",
        "<td></td></tr>",
        "<tr><td>Limits from:</td><td style='text-align:left'>",names(choice_r_limits2[disp_lim_calc]),"</td></tr>",
        "<tr><td>Centerline:</td><td style='text-align:left'>",if(disp_lim_calc==11){"None"}else if(disp_lim_calc==12){"Custom"}else{names(choice_x_centerline)[disp_center_type]},"</td></tr>",
        "</table>",
        "<br/>",
        "<table>",
        "<tr><td>\U03C3 estimated from: </td><td style='text-align:left'>",sigma_from,"</td></tr>",
        "<tr><td>Standard Errors Used: </td><td style='text-align:left'>",std_err,"</td></tr>",
        "</table>"
         
       )#end c
                    )#end HTML
       
       output
     })
     
     output$capability_analysis_x<-renderUI({
       #stuff that can change to trigger this output to recalculate
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_var_data_type
       UI1<-as.numeric(input$spc_var_UI1)
       UI2<-as.numeric(input$spc_var_UI2)
       req(UI1)
       x_type<-input$spc_var_loc_type
       disp_type<-input$spc_var_disp_type
       span<-input$spc_mr_span
       loc_upper_custom<-input$custom.x.upper
       loc_center_custom<-input$custom.x.center
       loc_lower_custom<-input$custom.x.lower
       disp_upper_custom<-input$custom.disp.upper
       disp_center_custom<-input$custom.disp.center
       disp_lower_custom<-input$custom.disp.lower
       sets<-as.numeric(input$spc_var_set)
       known_sig<-input$known_sig_x
       loc_center_type<-as.numeric(input$spc_x_loc)
       disp_center_type<-as.numeric(input$spc_x_disp)
       x_lim_calc<-as.numeric(input$spc_var_loc_lim)
       disp_lim_calc<-as.numeric(input$spc_var_disp_lim)
       std_err<-as.numeric(input$std_err_x)
       # chart_done<-chart_complete
       # if(!chart_complete){return()}
       run<-plot_data_change#did the reactive plot_data_r()change if so trigger this
       ind_chart<-input$spc_var_ind_or_mean
       
       dat<-plot_data_r()
       if(ind_chart){#testing to make sure data has changed before executing again
         if(dat$facet[1]!="X"){
           return()
         }
       } else{
         if(dat$facet[1]!="X-bar"){
           return()
         }
       }
       
       #needed for output
       req(dat)
       R<-input$spc_x_anova_decimals
       USL<-input$spc_x_USL
       Target<-input$spc_x_target
       LSL<-input$spc_x_LSL
       
       x_name<-names(choice_x_spc)[as.numeric(x_type)]
       disp_name<-names(choice_disp_spc)[as.numeric(disp_type)]
       
       output<-NULL
       set_num<-unique(dat$set)
       n_tot<-sum(dat$n_sample[dat$facet==x_name])
       
       header<-paste("<h4>Chart Statistics</h4><u><b>All Data</b></u><br/>",withMathJax("$s_{individuals}=$"),ro(dat$ind_s[1],R),"<br/>Total n = ",n_tot ,"<br/><br/>")
       
       for (i in set_num){
         
         corr<-cor.test(x = dat$measure[dat$facet==x_name & dat$set==i],y = dat$measure[dat$facet==disp_name & dat$set==i],method = "pearson")
         corr_r<-corr[["estimate"]][["cor"]]
         corr_p<-corr[["p.value"]]
         if(x_type==2){
           acf<-acf(dat$measure[dat$facet==x_name & dat$set==i],plot=F)
           crit_acf<-qnorm((1+.95)/2)/sqrt(acf[["n.used"]])
           #acf_out<-sum(abs(acf[["acf"]][-1])>crit_acf)
           acf_up<-acf$acf[acf$acf > crit_acf][-1]
           acf_lag_up<-acf$lag[acf$acf > crit_acf][-1]
           acf_low<-acf$acf[acf$acf < -crit_acf]
           acf_lag_low<-acf$lag[acf$acf < -crit_acf]
           up_text<-""
           down_text<-""
         }
         
       output<-paste(output,
         "<table>",
         "<tr><th style='text-align:left'>Set ",i,"</th></tr>",
         "<tr><td>Centerline = ",ro(dat$centerline[which(dat$set==i & dat$facet==x_name)][1],R),"</td></tr>",
         
         "<tr><td>",withMathJax("$s_{set}=$"),ro(dat$set_sd[which(dat$set==i & dat$facet==x_name)][1],R),"</td></tr>",
         "<tr><td>",withMathJax("$\\hat{\\sigma}_{est}=$"),ro(dat$est_sig[which(dat$set==i & dat$facet==x_name)][1],R),"</td></tr></table>",
         "<br/>",
         "<u>",x_name," and ",disp_name," correlation</u>",
         "<table><tr><td>r = ",ro(corr_r,R),"</td><td>p = ",ro(corr_p,R),"</td></tr>",
         "</table><br/>",
         if(x_type==2){
          if((length(acf_up)+length(acf_low)) > 0){ 
           paste(
           "<u>Autocorrelation</u>",
         "<table><tr><td>ACF greater than ",withMathJax("$ACF_{crit}=$"),ro(crit_acf,R),"</td><td>Confidence = 0.95</td></tr>",
         for(a in seq(1,length(acf_up))){
           up_text<-paste(up_text,"<tr><td>Lag = ",acf_lag_up[a],"</td><td>ACF =",ro(acf_up[a],R),"</td></tr>")
         },
         up_text,
         "</tr><tr><td>ACF less than ",withMathJax("$ACF_{crit}=$"),ro(-crit_acf,R),"</td><td>Confidence = 0.95</td></tr>",
         for(a in seq(1,length(acf_low))){
           down_text<-paste(down_text,"<tr><td>Lag = ",acf_lag_low[a],"</td><td>ACF =",ro(acf_low[a],R),"</td></tr>")
         },
         down_text,
         "</table><br/>")
            } else{
              paste(
                "<u>Autocorrelation</u>",
                "<table><tr><td>ACF greater than ",withMathJax("$ACF_{crit}=$"),ro(crit_acf,R),"</td><td>Confidence = 0.95</td></tr>",
                "<tr><td>No significant autocorrelation found</td></tr></table><br/>"
            )
         }
         
         } else{paste("")}
         
         
       )#end paste
       #capability
       if(!is.na(USL) || !is.na(Target) ||!is.na(LSL)){
         n_set<-sum(dat$n_sample[dat$facet==x_name & dat$set==i])
         cap<-spc.capability.summary.normal.simple(stat.lsl = LSL,
                                                   stat.target = Target,
                                                   stat.usl = USL,
                                                   process.center = dat$centerline[dat$set==i][1],
                                                   process.variability.estimate = dat$est_sig[dat$set==i][1]^2,
                                                   process.variability.overall = dat$set_sd[dat$set==i][1]^2,
                                                   process.n.upper = above_USL[i],
                                                   process.n.lower = below_LSL[i],
                                                   process.n = n_set)
         
         pct_off_target<-abs(100*(dat$centerline[dat$facet==x_name & dat$set==i][1] - Target)/(USL-LSL))
         
         output<-paste(output,
                       "<u>Capability Measures (Using ",withMathJax("$\\hat{\\sigma}_{est}$"),")</u>",
                       "<table>",
                       "<tr><td>C<sub>p</sub> = </td><td style='text-align:left'>",ro(cap$value[1],R),"</td></tr>",
                       "<tr><td>C<sub>pk</sub> = </td><td style='text-align:left'>",ro(cap$value[2],R),"</td></tr>",
                       "<tr><td>C<sub>pm</sub> = </td><td style='text-align:left'>",ro(cap$value[3],R),"</td></tr>",
                       "</table>",
                       "<br/>",
                       "<u>Potential Estimated Parts per Million (assuming normality of the individuals)</u>",
                       "<table>",
                       "<tr><td>Above Upper Spec = </td><td style='text-align:left'>",ro(cap$value[11],R),"</td></tr>",
                       "<tr><td>Below Lower Spec </td><td style='text-align:left'>",ro(cap$value[10],R),"</td></tr>",
                       "<tr><td>Total Out of Spec = </td><td style='text-align:left'>",ro(cap$value[12],R),"</td></tr>",
                       "</table>",
                       "<br/>",
                       "<u>Performance Measures (Using observed s)</u>",
                       "<table>",
                       "<tr><td>P<sub>p</sub> = </td><td style='text-align:left'>",ro(cap$value[4],R),"</td></tr>",
                       "<tr><td>P<sub>pk</sub> = </td><td style='text-align:left'>",ro(cap$value[5],R),"</td></tr>",
                       "<tr><td>P<sub>pm</sub> = </td><td style='text-align:left'>",ro(cap$value[6],R),"</td></tr>",
                       "<tr><td>% Off-Target = </td><td style='text-align:left'>",ro(pct_off_target,R),"% of spec width</td></tr>",
                       "</table>",
                       "<br/>",
                       "<u>Actual Observed Parts per Million Nonconforming</u>",
                       "<table>",
                       "<tr><th></th><th>Count</th><th>ppm</th></tr>",
                       "<tr><td>&gt;USL = </td><td>",cap$n[8],"</td><td>",ro(cap$value[8],R),"</td></tr>",
                       "<tr><td>&lt;LSL = </td><td>",cap$n[7],"</td><td>",ro(cap$value[7],R),"</td></tr>",
                       "<tr><td>Total Out of Spec = </td><td>",cap$n[9],"</td><td>",ro(cap$value[9],R),"</td></tr>",
                       "</table><br/>"
                       )
       }
       }#end loop
       
       HTML(c(header,output))
       
     })
     
     #update spc x limit selection based on dispersion selection
     
     observe({#match the location chart limit calculation to the dispersion one
       disp_lim_calc<-as.numeric(input$spc_var_disp_lim)
       x_type<-input$spc_var_loc_type
       req(x_type)
       req(disp_lim_calc)
       
       if(x_type==1){
         updateSelectInput(inputId = "spc_var_loc_lim",label = "X-bar Limit Calculation",selected = disp_lim_calc)
       }
       if(x_type==2){
         updateSelectInput(inputId = "spc_var_loc_lim",label = "X Limit Calculation",selected = disp_lim_calc)#here if need to revert back to old choices
       }
     })
     
     observe({#set dispersion calculation to default for the four types of dispersion charts
       disp_type<-input$spc_var_disp_type
       req(disp_type)
       
       if(disp_type==2){
         updateSelectInput(inputId = "spc_var_disp_lim",selected = 3)
       }
       if(disp_type==3){
         updateSelectInput(inputId = "spc_var_disp_lim",selected = 5)
       }
       if(disp_type==4){
         updateSelectInput(inputId = "spc_var_disp_lim",selected = 6)
       }
       
     })
     
     observe({#match the location type to the dispersion calculation
       disp_lim<-input$spc_var_disp_lim
       req(disp_lim)
       
       if(is.element(1,disp_lim) ||is.element(3,disp_lim) ||is.element(5,disp_lim) ||is.element(6,disp_lim) ||is.element(8,disp_lim) ||is.element(9,disp_lim)){
         #mean
         updateSelectInput(inputId = "spc_x_disp",selected=1)
         updateSelectInput(inputId = "spc_x_loc",selected=1)
       }
       
       if(is.element(2,disp_lim) ||is.element(4,disp_lim) ||is.element(7,disp_lim)){
         #median
         updateSelectInput(inputId = "spc_x_disp",selected=2)
         updateSelectInput(inputId = "spc_x_loc",selected=2)
       }
       
     })
     
     output$download_spc_x<-downloadHandler(
       filename=function(){paste("spc_plot.",input$download_spc_x_format,sep="")},
       content=function(file){
         file.copy(from = paste("spc_plot.",input$download_spc_x_format,sep=""),to = file,overwrite = TRUE)
       }
     )
     
     #######################attribute charts
     
     #First UI element of the attribute data selection, used either for spc
     output$spc_att_UI1<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_att_data_type
       
       
       
       if((data_type==1)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "spc_att_UI1",
                             label = "Select Count Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       if((data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "spc_att_UI1",
                             label = "Select Count Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       } 
       
       output
       
     })
     
     #Second UI element of the attribute data selection used for spc
     output$spc_att_UI2<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_att_data_type
       UI1<-input$spc_att_UI1
       req(UI1)
       const_n<-input$att_const_n
       
       
       #output<-NULL
       
       if(const_n){
         return(numericInput(inputId = "spc_att_UI2",label = "Sample Size",value = 1,min = 1,step = 1))
       }
       
       
         if(data_type==1){
           #take out those already selected
           fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-choices[temp]
           
           output<-pickerInput(inputId = "spc_att_UI2",
                               label = "Select Sample Size Column",
                               multiple=F,
                               options=list(`actions-box` = TRUE),
                               choices = choices)
         } else
           if(data_type==2){
             #take out those already selected
             fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
             temp<-seq(1:length(choices))
             temp<-temp[-fact_selected]
             choices<-choices[temp]
             
             output<-pickerInput(inputId = "spc_att_UI2",
                                 label = "Select Sample Column",
                                 multiple=F,
                                 options=list(`actions-box` = TRUE),
                                 choices = choices)
           } 
       
       
       output
       
     })
     
     output$spc_att_set<-renderUI({#sets
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       data_type<-input$spc_att_data_type
       UI1<-as.numeric(input$spc_att_UI1)
       UI2<-as.numeric(input$spc_att_UI2)
       req(UI1)
       
       const_n<-input$att_const_n
       
       output<-NULL
       
       if(const_n){
         fact_selected<-c(UI1)
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-c("None"=0,choices[temp])
         output<-pickerInput(inputId = "spc_att_set",
                             label = "Select Set Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       } else{
         
           #take out those already selected
           #fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
           if(is.null(input$spc_att_UI2) || is.na(input$spc_att_UI2)){return()}
         fact_selected<-c(UI1,UI2)
           temp<-seq(1:length(choices))
           temp<-temp[-fact_selected]
           choices<-c("None"=0,choices[temp])
           
           output<-pickerInput(inputId = "spc_att_set",
                               label = "Select Set Column",
                               multiple=F,
                               options=list(`actions-box` = TRUE),
                               choices = choices)
         }
       
       output
       
     })
     
     output$spc_att_loc_type<-renderUI({
       
       output<-selectInput(inputId = "spc_att_loc_type",label = "Chart Type",choices = choice_att_charts)
       
       output
     })
     
     output$spc_att_loc_lim<-renderUI({
       chart<-as.numeric(input$spc_att_loc_type)
       req(chart)
       
       if(chart==1 || chart==2)(
         output<-selectInput(inputId = "spc_att_loc_lim",label = "Limit Calculation",choices = choice_att_b_limits)
       )
       if(chart==3 || chart==4)(
         output<-selectInput(inputId = "spc_att_loc_lim",label = "Limit Calculation",choices = choice_att_p_limits)
       )
       
       output
       
     })
     
     output$ooc_rules_att_ui<-renderUI({
       att_lim_calc<-as.numeric(input$spc_att_loc_lim)
       req(att_lim_calc)
       
       if(att_lim_calc<7){
         output<-pickerInput(
           inputId = "ooc_rules_att",
           label = "Out-of-Control Rules",
           selected = c(1,2,3,4),
           multiple = TRUE,
           choices = list(
             Basic = c("Points Outside Limits"=1, "Runs"=2, "Trend of 6"=3, "14 Alternating Values"=4),
             Zones = c("2 out of 3 in Outer Third"=5,"15 in Inner Third"=6, "4 out of 5 in Outer Two-thirds"=7, "8 in Outer Two-thirds"))
         )
       }
       if(att_lim_calc==7){
         output<-pickerInput(
           inputId = "ooc_rules_att",
           label = "Out-of-Control Rules",
           selected = c(2),
           multiple = TRUE,
           choices = list(Basic = c("Runs"=2))
         )
       }
       if(att_lim_calc>7){
         output<-NULL
       }
       output
     })
     
     output$known_param_att<-renderUI({
       chart<-as.numeric(input$spc_att_loc_type)
       req(chart)
       loc_type<-input$spc_att_loc
       req(loc_type)
       
       if(loc_type!=3){return(NULL)}
       
       if(chart==1)(
         output<-numericInput(inputId = "known_param",label = "Enter \U03C0",value = NA,min = 0,max = 1)
       )
       if(chart==2)(
         output<-numericInput(inputId = "known_param",label = "Enter n\U03C0",value = NA,min = 0,max = 1)
       )
       if(chart==3)(
         output<-numericInput(inputId = "known_param",label = "Enter \U03bb",value = NA,min = 0)
       )
       if(chart==4)(
         output<-numericInput(inputId = "known_param",label = "Enter \U03bb/n",value = NA,min = 0)
       )
       
       output
       
     })
     
     output$attchartout<-renderPlot({att_chart_out()})
     attchartout_width<-reactive(400*8)
     attchartout_height<-reactive(400*4)
     downloadServer('attchartout', att_chart_out,width = attchartout_width,height = attchartout_height)
     
     att_chart_out<-reactive({#start attribute plot
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_att_data_type
       UI1<-as.numeric(input$spc_att_UI1)#column number of counts
       UI2<-as.numeric(input$spc_att_UI2)#either column number of sample sizes or if att_const_n is T it is the sample size for everything
       req(UI1)
       req(UI2)
       att_type<-input$spc_att_loc_type
       req(att_type)
       #disp_type<-input$spc_var_disp_type
       #span<-input$spc_mr_span
       att_lim_calc<-input$spc_att_loc_lim
       req(att_lim_calc)
       #disp_lim_calc<-input$spc_var_disp_lim
       loc_upper_custom<-input$custom.att.upper
       loc_center_custom<-input$custom.att.center
       loc_lower_custom<-input$custom.att.lower
       # disp_upper_custom<-input$custom.disp.upper
       # disp_center_custom<-input$custom.disp.center
       # disp_lower_custom<-input$custom.disp.lower
       std_err<-as.numeric(input$std_err_att)
       req(std_err)
       known_param<-input$known_param
       loc_center_type<-input$spc_att_loc
       req(loc_center_type)
       #disp_center_type<-input$spc_x_disp
       # USL<-input$spc_x_USL
       # Target<-input$spc_x_target
       # LSL<-input$spc_x_LSL
       # ind_chart<-input$spc_var_ind_or_mean#logical: is it an individual chart?
       const_n<-input$att_const_n#logical
       font_size<-input$att_spc_font_size
       
       sets<-as.numeric(input$spc_att_set)
       req(sets)
       
       req(att_type)
       #req(disp_type)
       #req(ind_chart)
       req(att_lim_calc)
       
       if(loc_center_type==3){
         req(known_param)
       }
       
       #form data
       if(data_type==1){#column of count column of sample size OR constant sample size
         k_obs<-nrow(data[UI1])
         Sample<-seq(1,k_obs)
         if(sets==0){
           set<-rep(1,k_obs)
         } else{
           set<-data[sets]
         }
         if(const_n){
           plot_data<-cbind("Count"=data[UI1],"n"=rep(UI2,k_obs),"Sets"=set)
         } else{
           plot_data<-cbind("Count"=data[UI1],"n"=data[UI2],"Sets"=set)
         }
         if(att_type==1){
          plot_data<-cbind(Sample,plot_data,"p"=plot_data[1]/plot_data[2])
          names(plot_data)<-c("Sample","Count","n","Sets","p")
         }
         if(att_type==2){
           plot_data<-cbind(Sample,plot_data,"np"=plot_data[1])
           names(plot_data)<-c("Sample","Count","n","Sets","np")
         }
         if(att_type==3){
           plot_data<-cbind(Sample,plot_data,"c"=plot_data[1])
           names(plot_data)<-c("Sample","Count","n","Sets","c")
         }
         if(att_type==4){
           plot_data<-cbind(Sample,plot_data,"u"=plot_data[1]/plot_data[2])
           names(plot_data)<-c("Sample","Count","n","Sets","u")
         }
       } else #column of count, column of observation, column of n OR constant n
       {
         #can't think of a reason why you would need this
       }
       
       #data are now a column of Count, n, Sets, and p
       y_lab<-names(res_filter$filtered()[UI1])
       plot_data<-plot_data[order(plot_data$Sample),]#reorder by sample if needed
       set_id<-unique(plot_data$Sets)
       
       #set up some stats we will need for alternate limits calculations
       set_sd_att<-NULL
       set_MR_att<-NULL

        for(i in set_id){#sd within sets, only needed for alternate limit calculations
         set_sd_att[i]<-sd(plot_data[[5]])
         #set_MR_att[i]<-abs(diff(plot_data[[5]]))
        }
       
       #calculate limits and check ooc
       run_length<-as.numeric(input$run_length_att)
       ooc_rules<-spc.rulesets.nelson.1984.test.1.2.3.4.5.6.7.8()
       ooc_rules$runs<-spc.controlviolation.nelson.1984.test2.runs.create(point.count = run_length)
       total_area<-pnorm(q = std_err,mean = 0,sd = 1)-(1-pnorm(q = std_err,mean = 0,sd = 1))
       
       
       #set up vectors
       points<-NULL
       centerline<-NULL
       UCL<-NULL
       zone_a_up<-NULL
       zone_ab_up<-NULL
       zone_bc_up<-NULL
       LCL<-NULL
       zone_a_low<-NULL
       zone_ab_low<-NULL
       zone_bc_low<-NULL
       
       order<-NULL
       
       est_sig<-NULL#only need for alternate limits
       
       
       if(att_lim_calc==1){#exact either binomial or Poisson
         for (j in set_id){
           if(loc_center_type==1){#mean
             if(att_type==1 || att_type==4){#p or u centerlines
              center<-sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             } else {#np or c centerlines
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
               center_set<-n_bar_set*sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             }
           } else if (loc_center_type == 2){#median
              center<-median(plot_data[5][which(plot_data$Sets==j),])
              center_set<-median(plot_data[5][which(plot_data$Sets==j),])
           }
           else if(loc_center_type==3){#known parameter
             center<-known_param
             center_set<-known_param
             n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
           }
           set_obs<-unique(plot_data$Sample[plot_data$Sets==j])
           for(i in set_obs){#for each point
             if(att_type==2 || att_type==3){#per-point mean estimate np
               center<-center_set*plot_data$n[i]/n_bar_set
             }
             
             if(att_type==1 || att_type==2){#p chart or np
               if(att_type==1){#p chart
                 n_upper<-qbinom(p = (1-total_area)/2,size = plot_data$n[i],prob = center,lower.tail = F)+.5
                 n_lower<-qbinom(p = (1-total_area)/2,size = plot_data$n[i],prob = center,lower.tail = T)-.5
                 UCL_t<-n_upper/plot_data$n[i]
                 LCL_t<-n_lower/plot_data$n[i]
               } else {#np chart
                 n_upper<-qbinom(p = (1-total_area)/2,size = plot_data$n[i],prob = center_set/n_bar_set,lower.tail = F)+.5
                 n_lower<-qbinom(p = (1-total_area)/2,size = plot_data$n[i],prob = center_set/n_bar_set,lower.tail = T)-.5
                 UCL_t<-n_upper
                 LCL_t<-n_lower
               }
               if(LCL_t<0){LCL_t<-NA} 
             }#end p-chart
             else{#c or u
               if(att_type==3 || att_type==4){#c chart or u
                 if(att_type==4){#u
                   n_upper<-qpois(p = (1-total_area)/2,lambda = center*plot_data$n[i],lower.tail = F)+.5
                   n_lower<-qpois(p = (1-total_area)/2,lambda = center*plot_data$n[i],lower.tail = T)-.5
                   UCL_t<-n_upper/plot_data$n[i]
                   LCL_t<-n_lower/plot_data$n[i]
                 } else {#c
                   n_upper<-qpois(p = (1-total_area)/2,lambda = center_set*(plot_data$n[i]/n_bar_set),lower.tail = F)+.5
                   n_lower<-qpois(p = (1-total_area)/2,lambda = center_set*(plot_data$n[i]/n_bar_set),lower.tail = T)-.5
                   UCL_t<-n_upper
                   LCL_t<-n_lower
                 }
                 if(LCL_t<0){LCL_t<-NA}
               }
             }
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end exact
       
       if(att_lim_calc==2){#normal approximation
         for (j in set_id){
           if(loc_center_type==1){#mean
             if(att_type==1 || att_type==4){#p or u centerlines
               center<-sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             } else {#np or c centerlines
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
               center_set<-n_bar_set*sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             }
           } else if (loc_center_type == 2){#median
             center<-median(plot_data[5][which(plot_data$Sets==j),])
             center_set<-median(plot_data[5][which(plot_data$Sets==j),])
           }
             else if(loc_center_type ==3){
               center<-known_param
               center_set<-known_param
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
             }
           
           set_obs<-unique(plot_data$Sample[plot_data$Sets==j])
           for(i in set_obs){#for each point
             if(att_type==2 || att_type==3){#per-point mean estimate np
               center<-center_set*plot_data$n[i]/n_bar_set
             }
            
             if(att_type==1 || att_type==2){#p chart or np
               if(att_type==1){#p chart
                 n_upper<-center+3*sqrt(center*(1-center)/plot_data$n[1])
                 n_lower<-center-3*sqrt(center*(1-center)/plot_data$n[1])
                 UCL_t<-n_upper
                 LCL_t<-n_lower
               } else {#np chart
                 n_upper<-center+3*sqrt(center*(1-(center_set/n_bar_set)))
                 n_lower<-center-3*sqrt(center*(1-(center_set/n_bar_set)))
                 UCL_t<-n_upper
                 LCL_t<-n_lower
               }
               if(LCL_t<0){LCL_t<-NA} 
             }#end p-chart
             else{#c or u
               if(att_type==3 || att_type==4){#c chart or u
                 if(att_type==4){#u
                   n_upper<-center+3*sqrt(center/plot_data$n[i])
                   n_lower<-center-3*sqrt(center/plot_data$n[i])
                   UCL_t<-n_upper
                   LCL_t<-n_lower
                 } else {#c
                   n_upper<-center+3*sqrt(center_set)
                   n_lower<-center-3*sqrt(center_set)
                   UCL_t<-n_upper
                   LCL_t<-n_lower
                 }
                 if(LCL_t<0){LCL_t<-NA}
               }
             }
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end normal approx
       
       if(att_lim_calc==3){#ave MR
         for (j in set_id){
           if(loc_center_type==1){#mean
             if(att_type==1 || att_type==4){#p or u centerlines
               center<-sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             } else {#np or c centerlines
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
               center_set<-n_bar_set*sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             }
           } else if(loc_center_type==2){#median
             center<-median(plot_data[5][which(plot_data$Sets==j),])
             center_set<-median(plot_data[5][which(plot_data$Sets==j),])
           }else if(loc_center_type==3){#known parameter
             center<-known_param
             center_set<-known_param
             n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
           }
           set_obs<-unique(plot_data$Sample[plot_data$Sets==j])
           MR_set<-mean(abs(diff(plot_data[,5][plot_data$Sets==j])))#based on MR
           est_sig_set<-MR_set/spc.constant.calculation.d2(sample.size = 2)
           for(i in set_obs){#for each point
             if(att_type==2 || att_type==3){#per-point mean estimate np and c
               center<-center_set*plot_data$n[i]/n_bar_set
             }
            
                 n_upper<-center+3*est_sig_set
                 n_lower<-center-3*est_sig_set
                 UCL_t<-n_upper
                 LCL_t<-n_lower
               
               if(LCL_t<0){LCL_t<-NA} 
             
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end ave MR
       
       
       if(att_lim_calc==4){#median MR
         for (j in set_id){
           if(loc_center_type==1){#mean
             if(att_type==1 || att_type==4){#p or u centerlines
               center<-sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             } else {#np or c centerlines
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
               center_set<-n_bar_set*sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             }
           } else if(loc_center_type==2){#median
             center<-median(plot_data[5][which(plot_data$Sets==j),])
           } else if(loc_center_type==3){
             center<-known_param
             center_set<-known_param
             n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
           }
           set_obs<-unique(plot_data$Sample[plot_data$Sets==j])
           MR_set<-median(abs(diff(plot_data[,5][plot_data$Sets==j])))#based on MR
           est_sig_set<-MR_set/spc.constant.calculation.d4(sample.size = 2)
           for(i in set_obs){#for each point
             if(att_type==2 || att_type==3){#per-point mean estimate np and c
               center<-center_set*plot_data$n[i]/n_bar_set
             }
             
             n_upper<-center+3*est_sig_set
             n_lower<-center-3*est_sig_set
             UCL_t<-n_upper
             LCL_t<-n_lower
             
             if(LCL_t<0){LCL_t<-NA} 
             
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end median MR
       
       if(att_lim_calc==5){#std
         for (j in set_id){
           if(loc_center_type==1){#mean
             if(att_type==1 || att_type==4){#p or u centerlines
               center<-sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             } else {#np or c centerlines
               n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
               center_set<-n_bar_set*sum(plot_data$Count[which(plot_data$Sets==j)])/sum(plot_data$n[which(plot_data$Sets==j)])#to account for weighted average
             }
           } else if(loc_center_type==2){#median
             center<-median(plot_data[5][which(plot_data$Sets==j),])
           }
           else if(loc_center_type==3){
             center<-known_param
             center_set<-known_param
             n_bar_set<-mean(plot_data$n[which(plot_data$Sets==j)])
           }
           set_obs<-unique(plot_data$Sample[plot_data$Sets==j])
           
           est_sig_set<-sd(plot_data[,5][which(plot_data$Sets==j)])
           for(i in set_obs){#for each point
             if(att_type==2 || att_type==3){#per-point mean estimate np and c
               center<-center_set*plot_data$n[i]/n_bar_set
             }
             
             n_upper<-center+3*est_sig_set
             n_lower<-center-3*est_sig_set
             UCL_t<-n_upper
             LCL_t<-n_lower
             
             if(LCL_t<0){LCL_t<-NA} 
             
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end std
       
       if(att_lim_calc==8){#custom
         
           center<-loc_center_custom
           
           set_obs<-unique(plot_data$Sample)
           for(i in set_obs){#for each point
             
                 UCL_t<-loc_upper_custom
                 LCL_t<-loc_lower_custom
            
             order<-c(order,i)
             UCL<-c(UCL,UCL_t)
             LCL<-c(LCL,LCL_t)
             centerline<-c(centerline,center)
             zone_a_up<-c(zone_a_up,UCL_t)
             ac_up<-UCL_t-center
             zone_ab_up<-c(zone_ab_up,center+(2/3)*ac_up)
             zone_bc_up<-c(zone_bc_up,center+(1/3)*ac_up)
             if(is.na(LCL_t)){LCL_t<-0}
             ac_low<-center-LCL_t
             zone_a_low<-c(zone_a_low,LCL_t)
             zone_ab_low<-c(zone_ab_low,center-(2/3)*ac_low)
             zone_bc_low<-c(zone_bc_low,center-(1/3)*ac_low)
           }#end i loop
         # }#end j loop
         
         #combine and sort
         lim_dat<-cbind(order,LCL,centerline,UCL,zone_a_up,zone_ab_up,zone_bc_up,zone_a_low,zone_ab_low,zone_bc_low)[order(order),]
         plot_data<-cbind(plot_data,lim_dat)[-6]
         plot_data<-as.data.frame(plot_data[order(Sample),])
         
         control_vio_att<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = plot_data[[5]],
                                                              center.line = plot_data$centerline,
                                                              control.limits.ucl = plot_data$UCL,
                                                              zone.a.upper = plot_data$zone_a_up,
                                                              zone.ab.upper = plot_data$zone_ab_up,
                                                              zone.bc.upper = plot_data$zone_bc_up,
                                                              control.limits.lcl = plot_data$LCL,
                                                              zone.a.lower = plot_data$zone_a_low,
                                                              zone.ab.lower = plot_data$zone_ab_low,
                                                              zone.bc.lower = plot_data$zone_bc_low)
       }#end custom
       
       
       #plot att
       #########################################################################
       
       ###final chart
       #bring together chart elements into a dataframe
       
       outside<-control_vio_att[["rule.results"]][["outside.limits"]]
       runs<-control_vio_att[["rule.results"]][["runs"]]
       trends<-control_vio_att[["rule.results"]][["trends"]]
       alternating<-control_vio_att[["rule.results"]][["alternating"]]
       zone_a<-control_vio_att[["rule.results"]][["zone.a"]]
       consec_c<-control_vio_att[["rule.results"]][["consecutive.zone.c"]]
       consec_ab<-control_vio_att[["rule.results"]][["consecutive.zone.ab"]]
       
       #plot_order<-factor(facet,levels = c(x_name,disp_name))#needed so that the charts are in the right order
       
       #assemble data for final plot first one is reactive and available outside of the plotting subroutine
       att_plot_data_r<<-reactive(data.frame(plot_data,
                                         outside,
                                         runs,
                                         trends,
                                         alternating,
                                         zone_a,
                                         consec_c,
                                         consec_ab
                                         ))#[order(-xtfrm(facet),x_label),])
       plot_data_change_att<<-plot_data_change_att+1
       att_plot_data_p<-att_plot_data_r()#this one will be modified for plotting
       
       ooc_att<-input$ooc_rules_att
       if(is.null(ooc_att)){ooc_att<-c(1,2,3,4)}#added these since these inputs are lazy and NULL until clicked on - shouldn't see NULL after that set
       
       
       for(i in 1:(k_obs)){#loop through points
         if(att_plot_data_p$outside[i]==TRUE && is.element(1,ooc_att)){
           att_plot_data_p$outside[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$outside[i]<-NA}
         if(att_plot_data_p$runs[i]==TRUE && is.element(2,ooc_att)){
           att_plot_data_p$runs[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$runs[i]<-NA}
         if(att_plot_data_p$trends[i]==TRUE && is.element(3,ooc_att)){
           att_plot_data_p$trends[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$trends[i]<-NA}
         if(att_plot_data_p$alternating[i]==TRUE && is.element(4,ooc_att)){
           att_plot_data_p$alternating[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$alternating[i]<-NA}
         if(att_plot_data_p$zone_a[i]==TRUE && is.element(5,ooc_att)){
           att_plot_data_p$zone_a[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$zone_a[i]<-NA}
         if(att_plot_data_p$consec_c[i]==TRUE && is.element(6,ooc_att)){
           att_plot_data_p$consec_c[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$consec_c[i]<-NA}
         if(att_plot_data_p$consec_ab[i]==TRUE && is.element(7,ooc_att)){
           att_plot_data_p$consec_ab[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$consec_ab[i]<-NA}
         if(att_plot_data_p$zone_a_b[i]==TRUE && is.element(8,ooc_att)){
           att_plot_data_p$zone_a_b[i]<-att_plot_data_p[i,5]
         } else {att_plot_data_p$zone_a_b[i]<-NA}
       }
       
       #set columns with no OOC as numeric to avoid error
       att_plot_data_p$outside<-as.numeric(att_plot_data_p$outside)
       att_plot_data_p$runs<-as.numeric(att_plot_data_p$runs)
       att_plot_data_p$trends<-as.numeric(att_plot_data_p$trends)
       att_plot_data_p$alternating<-as.numeric(att_plot_data_p$alternating)
       att_plot_data_p$zone_a<-as.numeric(att_plot_data_p$zone_a)
       att_plot_data_p$consec_c<-as.numeric(att_plot_data_p$consec_c)
       att_plot_data_p$consec_ab<-as.numeric(att_plot_data_p$consec_ab)
       att_plot_data_p$zone_a_b<-as.numeric(att_plot_data_p$zone_a_b)
       
       
       #plot_data_p<-plot_data_p[order(-xtfrm(facet),x_label),]
       
       #plot_data_p$plot_order<-factor(plot_data_p$facet,levels = c(x_name,disp_name))#needed so that the charts are in the right order
       
       #requested OOCs
       #x_chart_options<-c(1,2,3,4)
       att_chart_options<-input$att_chart_options
       
       #make the subtitle
       if(att_type==1 || att_type==2){
       subtitle<-paste(names(choice_att_charts)[as.numeric(att_type)],":: Limits from",names(choice_att_b_limits)[as.numeric(att_lim_calc)])
       }
         
       if(att_type==3 || att_type==4){
         subtitle<-paste(names(choice_att_charts)[as.numeric(att_type)],":: Limits from",names(choice_att_p_limits)[as.numeric(att_lim_calc)])
       }
       
       
       diff_t<-c(0,diff(att_plot_data_p$Sets))
       set_plot<-1
       for(i in seq(1,(k_obs))){
         if(i==1){next}
         if(diff_t[i]!=0){
           set_plot[i]<-set_plot[i-1]+1
         }else {set_plot[i]<-set_plot[i-1]}
       }
       
       #cbind(att_plot_data_p,set_plot)
       
       #base plot
       if(att_type==1){
         y="p"
       }
       if(att_type==2){
         y="np"
       }
       if(att_type==3){
         y="c"
       }
       if(att_type==4){
         y="u"
       }
         
       
       p<-ggplot(att_plot_data_p,aes(x=Sample,y=.data[[y]]))+
         theme_gray(base_size = font_size)#11 is default, but may be too small for some exports
       if(loc_center_type!=3){
         p<-p+
         labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = subtitle)
       } else{
           if(att_type==1){
             p<-p+
               labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = substitute(paste(subtitle," :: ",pi," known to be = ",known_param)))
           }
         if(att_type==2){
           p<-p+
             labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = substitute(paste(subtitle," :: n",pi," known to be = ",known_param)))
         }
         if(att_type==3){
           p<-p+
             labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = substitute(paste(subtitle," :: ",lambda," known to be = ",known_param)))
         }
         if(att_type==4){
           p<-p+
             labs(x="Samples",y=y_lab,title="Statistical Process Control Chart",subtitle = substitute(paste(subtitle," :: ",lambda,"/n known to be = ",known_param)))
         }
         }
       
       #zones
       if(is.element(9,ooc_att) || is.element(6,att_chart_options)){
         trans<-90
         rgb_outer<-col2rgb(color[2])
         rgb_mid<-col2rgb(color[7])
         rgb_inner<-col2rgb(color[3])
         
         outer_col<-rgb(red = rgb_outer[1],green = rgb_outer[2],blue = rgb_outer[3],alpha = trans, maxColorValue = 255)
         mid_col<-rgb(red = rgb_mid[1],green = rgb_mid[2],blue = rgb_mid[3],alpha = trans, maxColorValue = 255)
         inner_col<-rgb(red = rgb_inner[1],green = rgb_inner[2],blue = rgb_inner[3],alpha = trans, maxColorValue = 255)
         
         outer_col<-
           
           p<-p+
           geom_ribbon(aes(ymin=zone_a_low,ymax=zone_a_up, group=set_plot),fill=outer_col)+#outer third
           geom_ribbon(aes(ymin=zone_ab_low,ymax=zone_ab_up, group=set_plot),fill=mid_col)+
           geom_ribbon(aes(ymin=zone_bc_low,ymax=zone_bc_up, group=set_plot),fill=inner_col)
       }
       
       #lines and points
       p<-p+geom_point(color=color[4])
       if(is.element(1,att_chart_options)){
         p<-p+geom_line(aes(group=set_plot),color=color[4])
       }
       if(is.element(3,att_chart_options)){
         p<-p+geom_line(aes(y=centerline, group=set_plot),color=color[3])#add centerline
       }
       
       #limits
       if(is.element(2,att_chart_options)){
         p<-p+
           geom_line(aes(y=UCL, group=set_plot),color=color[2],linetype=5)+#add cl
           geom_line(aes(y=LCL, group=set_plot),color=color[2],linetype=5)#add cl
       }
       
       #ooc points
       # if(is.element(1,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=outside,label="O"),nudge_x = .75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=outside),color=color[2],shape=8)#add points outside
       }
       # }
       # if(is.element(2,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=runs,label="R"),nudge_x = -.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=runs),color=color[2],shape=8)#runs
       }
       # }
       # if(is.element(3,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=trends,label="T"),nudge_y = .75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=trends),color=color[2],shape=8)#trends
       }
       # }
       # if(is.element(4,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=alternating,label="A"),nudge_y = -.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=alternating),color=color[2],shape=8)
       }
       # }
       # if(is.element(5,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=zone_a,label="Z-a"),nudge_y = .75,nudge_x=.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=zone_a),color=color[2],shape=8)
       }
       # }
       # if(is.element(6,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=consec_c,label="C-c"),nudge_y = -.75,nudge_x=.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=consec_c),color=color[2],shape=8)
       }
       # }
       # if(is.element(7,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=consec_ab,label="C-ab"),nudge_y = .75,nudge_x=-.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=consec_ab),color=color[2],shape=8)
       }
       # }
       # if(is.element(8,ooc)){
       if(is.element(5,att_chart_options)){
         p<-p+geom_text(aes(y=zone_a_b,label="Z-ab"),nudge_y = -.75,nudge_x=-.75,color=color[2])
       }
       if(is.element(4,att_chart_options)){
         p<-p+geom_point(aes(y=zone_a_b),color=color[2],shape=8)
       }
       # }
       
       if (inherits(try(ggplot_build(p)), "try-error")) {#this is a final test to make sure the plot actually plots
         plot <- ggplot()
         return()
         }
       
       # ggsave(paste("spc_plot.",input$download_spc_x_format,sep=""),p)
       p#final graph
       
       #########################################################################
       
     })
     
     output$download_spc_att<-downloadHandler(
       filename=function(){paste("spc_plot.",input$download_spc_att_format,sep="")},
       content=function(file){
         file.copy(from = paste("spc_plot.",input$download_spc_att_format,sep=""),to = file,overwrite = TRUE)
       }
     )
     
     output$att_table_out<-DT::renderDataTable({
       dat<-att_plot_data_r()
       R<-input$spc_att_decimals
       
       #need these to trigger recalculation if any of them change
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_att_data_type
       UI1<-as.numeric(input$spc_att_UI1)
       UI2<-as.numeric(input$spc_att_UI2)
       req(UI1)
       att_type<-input$spc_att_loc_type
       att_lim_calc<-input$spc_att_loc_lim
       upper_custom<-input$custom.att.upper
       center_custom<-input$custom.att.center
       lower_custom<-input$custom.att.lower
       sets<-as.numeric(input$spc_att_set)
       std_err<-as.numeric(input$std_err_att)
       known_sig<-input$known_sig_att
       center_type<-input$spc_att_loc
       
       ro(DT::datatable(data = dat,options=list(dom="t",paging=FALSE),rownames = F),R)
     })
     
     output$hover_info_att <- renderUI({
       req(input$spc_att_loc_type)
       #req(input$spc_var_disp_type)
       R<-input$spc_att_decimals
       hover <- input$plot_hover_att
       if(is.null(hover)){return()}
       data<-att_plot_data_r()
       point <- nearPoints(df = data, coordinfo = hover,xvar =  "Sample",yvar = names(data)[5], threshold = 5, maxpoints = 1, addDist = TRUE)
       if (nrow(point) == 0) return(NULL)
       
       
       # calculate distance from left and bottom side of the picture in pixels
       left_px <- hover$coords_css$x
       top_px <- hover$coords_css$y
       
       
       # create style property for tooltip
       # background color is set so tooltip is a bit transparent
       # z-index is set so we are sure are tooltip will be on top
       style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
                       "left:", left_px + 2, "px; top:", top_px + 2, "px;")
       
       # actual tooltip created as wellPanel
       wellPanel(
         style = style,
         p(HTML(paste0(
           "<span style='display:block; text-transform:capitalize; text-align:center'>",point$facet,"</span>",
           "<b> Point: </b>", ro(point$Sample), "<br/>",
           "<b> Measure: </b>", ro(point[[5]],R), "<br/>",
           if(length(unique(att_plot_data_r()$Sets))>1){
             paste0("<b> Set: </b>", point$Set, "<br/>")
           },
           "<b> UCL: </b>", ro(point$UCL,R), "<br/>",
           "<b> Centerline: </b>", ro(point$centerline,R), "<br/>",
           "<b> LCL: </b>", ro(point$LCL,R))))
       )
     })
     
     output$limit_analysis_att<-renderUI({
       #stuff that can change to trigger this output
       data<-res_filter$filtered()#all data
       req(data)
       data_type<-input$spc_att_data_type
       UI1<-as.numeric(input$spc_att_UI1)
       UI2<-as.numeric(input$spc_att_UI2)
       req(UI1)
       att_type<-input$spc_att_loc_type
       #disp_type<-input$spc_var_disp_type
       #span<-input$spc_mr_span
       upper_custom<-input$custom.att.upper
       center_custom<-input$custom.att.center
       lower_custom<-input$custom.att.lower
       
       sets<-as.numeric(input$spc_att_set)
       known_sig<-input$known_sig_att
       
       run<-plot_data_change#did the reactive plot_data_r()change if so trigger this
       #ind_chart<-input$spc_var_ind_or_mean
       
       dat<-plot_data_r()
       
       #needed for output
       #dat<-plot_data_r()
       R<-input$spc_att_decimals
       center_type<-as.numeric(input$spc_att_loc)
       known_param<-input$known_param
       
       att_lim_calc<-as.numeric(input$spc_att_loc_lim)
       
       std_err<-as.numeric(input$std_err_att)
       
       if(att_type==1 || att_type==2){
         choice<-choice_att_b_limits
       } else{choice<-choice_att_p_limits}
       
       output<-HTML(c(
         "<h4>Limit Calculation Summary</h4>",
         "<table>",
         "<tr><td><u>",names(choice_att_charts)[as.numeric(att_type)]," Chart</u></td>",
         "<td></td></tr>",
         "<tr><td>Limits from:</td><td style='text-align:left'>",names(choice[att_lim_calc]),"</td></tr>",
         "<tr><td>Centerline:</td><td style='text-align:left'>",if(att_lim_calc==7){"None"}else if(att_lim_calc==8){"Custom"}else if(center_type==3){paste("Known to be = ",known_param)} else {names(choice_x_centerline)[center_type]},"</td></tr>",
         "<tr><td>Standard Errors Used: </td><td style='text-align:left'>",std_err,"</td></tr>",
         "</table>",
         "<br/>"
         
         
       )#end c
       )#end HTML
       
       output
     })
     
     output$spc_att_loc<-renderUI({
       chart_type<-input$spc_att_loc_type
       req(chart_type)
       
       if(chart_type==1){
         choice_att_centerline<-(1:3)
         names(choice_att_centerline)<-c(
           "Mean",
           "Median",
           "Known \U03c0"
         )
         output<-selectInput(inputId = "spc_att_loc",label = "Centerline",choices = choice_att_centerline)
       }
        else if(chart_type==2){
         choice_att_centerline<-(1:3)
         names(choice_att_centerline)<-c(
           "Mean",
           "Median",
           "Known n\U03c0"
         )
         output<-selectInput(inputId = "spc_att_loc",label = "Centerline",choices = choice_att_centerline)
       }
       else if(chart_type==3){
         choice_att_centerline<-(1:3)
         names(choice_att_centerline)<-c(
           "Mean",
           "Median",
           "Known \U03bb"
         )
         output<-selectInput(inputId = "spc_att_loc",label = "Centerline",choices = choice_att_centerline)
       }
       else if(chart_type==4){
         choice_att_centerline<-(1:3)
         names(choice_att_centerline)<-c(
           "Mean",
           "Median",
           "Known \U03bb/n"
         )
         output<-selectInput(inputId = "spc_att_loc",label = "Centerline",choices = choice_att_centerline)
       }
     })
     
     # output$download_scat<-downloadHandler(
     #   filename=function(){paste("spc_plot.",input$download_scat_format,sep="")},
     #   content=function(file){
     #     file.copy(from = paste("spc_plot.",input$download_scat_format,sep=""),to = file,overwrite = TRUE)
     #   }
     # )
     
     
     
     #MSA##############################################################
     
     output$msa_UI1<-renderUI({
       data_type<-input$msa_data_type
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       
       if((data_type==1)){
         # choices<-seq(1:ncol(res_filter$filtered()))
         # names(choices)<-names(res_filter$filtered())
         # output<-pickerInput(inputId = "spc_att_UI1",
         #                     label = "Select Count Column",
         #                     multiple=F,
         #                     options=list(`actions-box` = TRUE),
         #                     choices = choices)
       }
       if((data_type==2)){
         choices<-seq(1:ncol(res_filter$filtered()))
         names(choices)<-names(res_filter$filtered())
         output<-pickerInput(inputId = "msa_UI1",
                             label = "Select Appraiser Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       } 
       
       output
         
     })
     
     output$msa_UI2<-renderUI({
       data_type<-input$msa_data_type
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-input$msa_UI1
       req(UI1)
       
       
       if((data_type==1)){
         # choices<-seq(1:ncol(res_filter$filtered()))
         # names(choices)<-names(res_filter$filtered())
         # output<-pickerInput(inputId = "spc_att_UI1",
         #                     label = "Select Count Column",
         #                     multiple=F,
         #                     options=list(`actions-box` = TRUE),
         #                     choices = choices)
       }
       if((data_type==2)){
         #take out those already selected
         fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-choices[temp]
         
         output<-pickerInput(inputId = "msa_UI2",
                             label = "Select Part Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       
       output
       
     })
     
     
     
     
     
     
     output$msa_UI3<-renderUI({
       data_type<-input$msa_data_type
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-as.numeric(input$msa_UI1)
       UI2<-as.numeric(input$msa_UI2)
       req(UI2)
       
       if((data_type==1)){
         # choices<-seq(1:ncol(res_filter$filtered()))
         # names(choices)<-names(res_filter$filtered())
         # output<-pickerInput(inputId = "spc_att_UI1",
         #                     label = "Select Count Column",
         #                     multiple=F,
         #                     options=list(`actions-box` = TRUE),
         #                     choices = choices)
       }
       if((data_type==2)){
         #take out those already selected
         fact_selected<-c(UI1,UI2)
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-choices[temp]
         
         output<-pickerInput(inputId = "msa_UI3",
                             label = "Select Trial Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       
       output
     })
     
     output$msa_UI4<-renderUI({
       data_type<-input$msa_data_type
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-as.numeric(input$msa_UI1)
       UI2<-as.numeric(input$msa_UI2)
       UI3<-as.numeric(input$msa_UI3)
       req(UI3)
       if((data_type==1)){
         # choices<-seq(1:ncol(res_filter$filtered()))
         # names(choices)<-names(res_filter$filtered())
         # output<-pickerInput(inputId = "spc_att_UI1",
         #                     label = "Select Count Column",
         #                     multiple=F,
         #                     options=list(`actions-box` = TRUE),
         #                     choices = choices)
       }
       if((data_type==2)){
         #take out those already selected
         fact_selected<-c(UI1,UI2,UI3)
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-choices[temp]
         
         output<-pickerInput(inputId = "msa_UI4",
                             label = "Select Measurement Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       
       output
     })
     
     #msa_UI5
     output$msa_UI5<-renderUI({
       data_type<-input$msa_data_type
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-as.numeric(input$msa_UI1)
       UI2<-as.numeric(input$msa_UI2)
       UI3<-as.numeric(input$msa_UI3)
       UI4<-as.numeric(input$msa_UI4)
       req(UI4)
       if((data_type==1)){
         # choices<-seq(1:ncol(res_filter$filtered()))
         # names(choices)<-names(res_filter$filtered())
         # output<-pickerInput(inputId = "spc_att_UI1",
         #                     label = "Select Count Column",
         #                     multiple=F,
         #                     options=list(`actions-box` = TRUE),
         #                     choices = choices)
       }
       if((data_type==2)){
         #take out those already selected
         fact_selected<-c(UI1,UI2,UI3,UI4)
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-choices[temp]
         
         output<-pickerInput(inputId = "msa_UI5",
                             label = "Select True Value Column",
                             multiple=F,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       
       output
     })
     
     output$msa_out<-renderUI({
       req(res_filter$filtered())
       file<-res_filter$filtered()
       UI1<-as.numeric(input$msa_UI1) #appraiser
       UI2<-as.numeric(input$msa_UI2) #part
       UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}
       level<-input$msa_level #1=interval or 2=nominal
       type<-input$msa_type #1=potential 2=short 3=long
       standard<-input$msa_stand #logical if there is a standard present
       calc<-input$msa_calc #1=range 2=s 3=anova
       use_range<-input$msa_range_b#logical true is spec
       spec_range<-input$msa_range#if !use_range this is range
       USL<-input$msa_USL
       LSL<-input$msa_LSL
       sigmas<-input$msa_sigmas#false is 5.15
       conf<-input$conf_msa
       R<-input$deci_msa
       diagnostic<-input$msa_diagnostic
       
       if(sigmas){sigma<-6} else {sigma<-5.15}
       
       req(UI4)
       
       
       
       if(use_range){spec_range<-USL-LSL}
       
       data<-cbind(file[UI1],file[UI2],file[UI3],file[UI4])
       
       names(data)<-c("Appraiser","Part","Trial","Measures")
       
       if(!is.numeric(data$Part) || !is.numeric(data$Trial) || !is.numeric(data$Measures))(return(HTML("Need numeric data")))#check for appropriate data
       
       #sort
       data$Appraiser<-factor(data$Appraiser,levels=unique(data$Appraiser),labels = paste0("Appraiser ",unique(data$Appraiser)))#factor(data$Appraiser,labels = "Appraiser ")
       
       data<-data[with(data,order(Appraiser,Trial,Part)),]
       
       msa_data_r<<-reactive({
         req(UI1,UI2,UI3,UI4)
         data
         })
       
       app_id<-unique(data$Appraiser)
       app_num(length(app_id))
       trials<-unique(data$Trial)
       parts<-unique(data$Part)
       
       by_ap_part<-group_by(.data = data,Appraiser,Part)
       
       if(calc==1){#range calculation
         R_bar<-NULL
         X_bar<-NULL
         by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures))
         for(app in app_id){
           R_bar[app]<-mean(by_ap_part$Range[by_ap_part$Appraiser==app])
           X_bar[app]<-mean(by_ap_part$Measures[by_ap_part$Appraiser==app])
         }
         R_t<-mean(R_bar)
         R_x<-max(X_bar)-min(X_bar)
         
         sig_rpd(R_x/d2.star(g = 1,m = length(app_id)))
         if(length(app_id)==1){sig_rpd(0)}
         sig_rpt(R_t/d2.star(g = length(parts)*length(app_id),m = length(trials)))
         sig_e(sqrt(sig_rpt()^2+sig_rpd()^2))
         pct_EV<-NA
         pct_AV<-NA
         pct_RR<-NA
         if(!is.na(spec_range)){
           pct_EV<-100*sigma*sig_rpt()/spec_range
           pct_AV<-100*sigma*sig_rpd()/spec_range
           pct_RR<-100*sigma*sig_e()/spec_range
         }
         
         output_header<-c(
           "<h4>Range Potential MSA</h4><br/>",
           "Confidence Level = ",conf*100,"%<br/><br/>",
           "<u>Specifications</u><br/>",
           if(!use_range){c("Range = ",spec_range,"<br/>")} else
           {c("USL = ",USL,"<br/>LSL = ",LSL,"<br/>")},
           "<br/><u>Overall Summary Results</u>",
           "<table style='margin-left:auto;margin-right:auto'>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPT}=$")),"</td><td>",ro(sig_rpt(),R),"</td><td></td><td>%EV = ",ro(pct_EV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPD}=$")),"</td><td>",ro(sig_rpd(),R),"</td><td></td><td>%AV = ",ro(pct_AV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{e}=$")),"</td><td>",ro(sig_e(),R),"</td><td></td><td>%RR = ",ro(pct_RR,1),"%</td></tr></table><br/>"
         )#end of html header
         
       }#end range calculation
       
       else if(calc==2){#s calculation
         
         R_bar<-NULL
         X_bar<-NULL
         s_bar<-NULL
         by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures),s=sd(Measures))
         for(app in app_id){
           R_bar[app]<-mean(by_ap_part$Range[by_ap_part$Appraiser==app])
           X_bar[app]<-mean(by_ap_part$Measures[by_ap_part$Appraiser==app])
           s_bar[app]<-mean(by_ap_part$s[by_ap_part$Appraiser==app])
         }
         s_t<-mean(by_ap_part$s)
         R_x<-max(X_bar)-min(X_bar)
         
         sig_rpd(R_x/d2.star(g = 1,m = length(app_id)))
         if(length(app_id)==1){sig_rpd(0)}
         sig_rpt(s_t/spc.constant.calculation.c4(sample.size = length(trials)))#g = length(parts)*length(app_id),m = length(trials))})
         sig_e(sqrt(sig_rpt()^2+sig_rpd()^2))
         pct_EV<-NA
         pct_AV<-NA
         pct_RR<-NA
         if(!is.na(spec_range)){
           pct_EV<-100*sigma*sig_rpt()/spec_range
           pct_AV<-100*sigma*sig_rpd()/spec_range
           pct_RR<-100*sigma*sig_e()/spec_range
         }
         
         output_header<-c(
           "<h4>Standard Deviation Potential MSA</h4><br/>",
           "Confidence Level = ",conf*100,"%<br/><br/>",
           "<u>Specifications</u><br/>",
           if(!use_range){c("Range = ",spec_range,"<br/>")} else
           {c("USL = ",USL,"<br/>LSL = ",LSL,"<br/>")},
           "<br/><u>Overall Summary Results</u>",
           "<table style='margin-left:auto;margin-right:auto'>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPT}=$")),"</td><td>",ro(sig_rpt(),R),"</td><td></td><td>%EV = ",ro(pct_EV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPD}=$")),"</td><td>",ro(sig_rpd(),R),"</td><td></td><td>%AV = ",ro(pct_AV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{e}=$")),"</td><td>",ro(sig_e(),R),"</td><td></td><td>%RR = ",ro(pct_RR,1),"%</td></tr></table><br/>"
         )#end of html header
         
       }#end s calculation
       
       else if(calc==3){#anova calc
         #handle entering range rather than spec
         if (!use_range){
           LSL<-0
           USL<-LSL+spec_range
         }
         
         s_bar<-NULL
         R_bar<-NULL
         X_bar<-NULL
         by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures),s=sd(Measures))
         for(app in app_id){
           R_bar[app]<-mean(by_ap_part$Range[by_ap_part$Appraiser==app])
           X_bar[app]<-mean(by_ap_part$Measures[by_ap_part$Appraiser==app])
           s_bar[app]<-mean(by_ap_part$s[by_ap_part$Appraiser==app])
         }
         R_t<-mean(R_bar)
         R_x<-max(X_bar)-min(X_bar)
         s_t<-mean(by_ap_part$s)
         
         anova_pot<-msa.continuous.repeatability.reproducibility(measurement = data$Measures,
                                                                 part = data$Part,
                                                                 appraiser = data$Appraiser,
                                                                 conf.level.interaction = conf,
                                                                 stat.lsl = LSL,
                                                                 stat.usl = USL
                                                                 # ,
                                                                 # n.sigma=sigmas
         )
         
         sig_rpt(anova_pot[["ev.full"]][2,3])
         sig_rpd(anova_pot[["ev.full"]][3,3])
         sig_e(anova_pot[["ev.full"]][1,3])
         sig_part_app(anova_pot[["ev.full"]][5,3])
         sig_app(anova_pot[["ev.full"]][4,3])
         pct_EV<-NA
         pct_AV<-NA
         pct_RR<-NA
         pct_EV<-anova_pot[["ev.full"]][2,6]*(sigma/6) # last bit accommodates selecting 5.15 sigma since output is 6
         pct_AV<-anova_pot[["ev.full"]][3,6]*(sigma/6)
         pct_RR<-anova_pot[["ev.full"]][1,6]*(sigma/6)
         #output summary ######change to the study variability table?
         output_header<-c(
           "<h4>ANOVA Potential MSA</h4><br/>",
           "Confidence Level = ",conf*100,"%<br/><br/>",
           "<u>Specifications</u><br/>",
           if(!use_range){c("Range = ",spec_range,"<br/>")} else
           {c("USL = ",USL,"<br/>LSL = ",LSL,"<br/>")},
           "<br/><u>Overall Summary Results</u>",
           "<table style='margin-left:auto;margin-right:auto'>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPT}=$")),"</td><td>",ro(sig_rpt(),R),"</td><td></td><td>%EV = ",ro(pct_EV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{RPD}=$")),"</td><td>",ro(sig_rpd(),R),"</td><td></td><td>%AV = ",ro(pct_AV,1),"%</td></tr>",
           "<tr><td>",paste(withMathJax("$\\sigma_{e}=$")),"</td><td>",ro(sig_e(),R),"</td><td></td><td>%RR = ",ro(pct_RR,1),"%</td></tr></table><br/>"
           
         )#end of summary
         
         #output distinct categories and discrimination ratio
         #took these out since there is no assumption that the parts are randomly selected from a single process - moved this to the misclassification graph
         # distinct_cat<-c("Distinct Categories: ",ro(anova_pot[["ev.full.number.distinct.categories"]],R))
         # disc_ratio<-c("<br/>Discrimination Ratio: ",ro(anova_pot[["ev.full.discrimination.ratio"]],R))
         # 
         # output_header<-c(output_header,distinct_cat,disc_ratio)
         
         #output ANOVA table and components into header
         msa_anova<-paste0(
           "<h5><u>ANOVA Source Table</u></h5>",
           "<table style='margin-left:auto;margin-right:auto'><tr><th>Source</th><th>df</th><th>SS</th><th>MS</th><th>F</th><th>p</th></tr>")
         
         #rows<-seq(1:length(anova_pot[["summary.aov.full"]][[1]]))
         if(length(app_id)==1){#this accounts for single appraiser, note there is a bug in lolcat that makes the name 3 rather than Total
           rows<-seq(1,3)
           rownames(anova_pot[["summary.aov.full"]][[1]])[3]<-"Total"
           } else{rows<-seq(1,5)}
         
         for(row in rows){
           msa_anova<-paste0(msa_anova,
                             "<tr><td>",rownames(anova_pot[["summary.aov.full"]][[1]])[row],
                             "</td><td>",anova_pot[["summary.aov.full"]][[1]]$Df[row],
                             "</td><td>",ro(anova_pot[["summary.aov.full"]][[1]]$`Sum Sq`[row],R),
                             "</td><td>",if(is.na(anova_pot[["summary.aov.full"]][[1]]$`Mean Sq`[row])){""}else{ro(anova_pot[["summary.aov.full"]][[1]]$`Mean Sq`[row],R)},
                             "</td><td>",if(is.na(anova_pot[["summary.aov.full"]][[1]]$`F value`[row])){""}else{ro(anova_pot[["summary.aov.full"]][[1]]$`F value`[row],R)},
                             "</td><td>",if(is.na(anova_pot[["summary.aov.full"]][[1]]$`Pr(>F)`[row])){""}else{ro(anova_pot[["summary.aov.full"]][[1]]$`Pr(>F)`[row],R)},
                             if(!is.na(anova_pot[["summary.aov.full"]][[1]]$`Pr(>F)`[row]) && anova_pot[["summary.aov.full"]][[1]]$`Pr(>F)`[row]<(1-conf)){"*"}else{""},
                             "</td>"
           )
         }
         
         output_header<-c(output_header,msa_anova,"</table><br/>")
         
         #output components of variance 
         msa_comp_var<-paste0(
           "<h5><u>Components of Variation Table</u></h5>",
           "<table style='margin-left:auto;margin-right:auto'><tr><th>Source</th><th>Comp. Variance</th><th>% Variance</th><th>Comp. s</th><th>Study Variance</th><th>% Study
             Variance</th><th>% Tolerance</th></tr>"
         )
         
         rows<-seq(1,nrow(anova_pot[["ev.full"]]))
         cols<-seq(1,ncol(anova_pot[["ev.full"]]))
         
         for (row in rows){
           if(length(app_id)==1){
             if(row == 3 || row == 4 || row ==5){
               next
             }
           }
           msa_comp_var<-paste0(msa_comp_var,
                                "<tr><td>",rownames(anova_pot[["ev.full"]])[row],"</td>")
           for(col in cols){
             msa_comp_var<-paste0(msa_comp_var,
                                  "<td>",ro(anova_pot[["ev.full"]][row,col],R))
             
             if(col==2 || col==6){#add % in correct columns
               msa_comp_var<-paste0(msa_comp_var,"%")
             }#end add %
             
             msa_comp_var<-paste0(msa_comp_var,"</td>")
             
           }#end columns in row
           msa_comp_var<-paste0(msa_comp_var,"</tr>")
         }#end row
         
         msa_comp_var<-paste0(msa_comp_var,"</table><br/>")
         
         output_header<-c(output_header,msa_comp_var)
         
       }#end anova
       
       
       
         # msa_change<<-reactive({
         #   req(UI1,UI2,UI3,UI4,type,calc)
         # sig_e()
         #   })#signal a change in the msa calculation
         
         msa_init({
           req(sig_e())
           sig_e()
         })
       
       if(!diagnostic){return(HTML(output_header))}
       
       #if you want diagnostics, here we go
       
       #repeatability within appraiser
       html_title<-c("<h4>Diagnostic Analysis</h4>")
       
       rep_analysis<-matrix(nrow = 0,ncol = 9)#repeatability within appraiser
       colnames(rep_analysis)<-c("Trials","n","r","p(r)","t(Var)","p(Var)","Diff","t(Means)","p(Means)")
       
       for (i in app_id){#within appraiser
         test_combis<-combn(length(trials),2)
         test_num<-length(test_combis)/2
         tests<-seq(1,test_num)
         app_data<-data[data$Appraiser==i,]
         for(j in tests){#across trials
           cor_this<-cor.pearson.r.onesample(x = app_data$Measures[app_data$Trial==test_combis[1,j]],y =app_data$Measures[app_data$Trial==test_combis[2,j]],null.hypothesis.rho = 0,conf.level = conf)
           t_var_this<-variance.test.twosample.dependent(g1 = app_data$Measures[app_data$Trial==test_combis[1,j]],g2 = app_data$Measures[app_data$Trial==test_combis[2,j]],conf.level = conf)
           t_this<-t.test.twosample.dependent(x1 = app_data$Measures[app_data$Trial==test_combis[1,j]],x2 = app_data$Measures[app_data$Trial==test_combis[2,j]],null.hypothesis.difference = 0,conf.level = conf)
           rep_analysis<-rbind(rep_analysis,c(
             paste0("m",test_combis[1,j]," vs m",test_combis[2,j]),
             ro(cor_this[["estimate"]][["sample.size"]],R),
             ro(cor_this[["estimate"]][["sample.r"]],R),
             ro(cor_this[["p.value"]],R),
             ro(t_var_this[["statistic"]][["t statistic"]],R),
             ro(t_var_this[["p.value"]],R),
             ro(t_this[["estimate"]][["sample.mean"]],R),
             ro(t_this[["statistic"]][["t statistic"]],R),
             ro(t_this[["p.value"]],R)
           )
           )
           rownames(rep_analysis)[nrow(rep_analysis)]<-i
           
         }#end trials loop
       }#end appraiser loop
       #rep_analysis #has the complete repeatability within appraisers analysis in a matrix
       
       app_rep<-NULL
       app_repr<-NULL#in case one appraiser
       apps<-1
       #repeatability across appraisers
       if(length(app_id)!=1){#multiple appraiser
         
          app_combis<-combn(app_id,2)
         
       
       
       #output_repeat_ap<-NULL
       #if(length(app_id)!=1){#skip if one appraiser
       
       app_rep<-matrix(nrow=0,ncol=8)#repeatability across appraisers
       if(calc==1 || calc==2){
         colnames(app_rep)<-c("n","r(Ranges)","p(r)","t(Var R)","p(Var R)","Rmin/Rmax","t(Ranges)","p(Ranges)")
       }
       if(calc==3){
         colnames(app_rep)<-c("n","r(s)","p(r)","t(Var s)","p(Var s)","s min/s max","t(s)","p(s)")
       }
       
         
         
      
       app_repr<-matrix(nrow=0,ncol=8)#reproducibility across appraisers
       colnames(app_repr)<-c("n","r","p(r)","t(Var)","p(Var)","Diff","t(Means)","p(Means)")
       
       
         
         app_num<-length(app_combis)/2
       
       apps<-seq(1,app_num)
       for(i in apps){
         
         if(calc==1){
           cor_this<-cor.pearson.r.onesample(x = by_ap_part$Range[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],y = by_ap_part$Range[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.rho = 0,conf.level = conf)
           t_var_this<-variance.test.twosample.dependent(g1 = by_ap_part$Range[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],g2 = by_ap_part$Range[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],conf.level = conf)
           t_this<-t.test.twosample.dependent(x1 = by_ap_part$Range[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],x2 = by_ap_part$Range[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.difference = 0,conf.level = conf)
           R_maxmin<-min(R_bar[app_combis[1,i]],R_bar[app_combis[2,i]])/max(R_bar[app_combis[1,i]],R_bar[app_combis[2,i]])
         }
         
         if(calc==2 || calc == 3){
           cor_this<-cor.pearson.r.onesample(x = by_ap_part$s[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],y = by_ap_part$s[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.rho = 0,conf.level = conf)
           t_var_this<-variance.test.twosample.dependent(g1 = by_ap_part$s[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],g2 = by_ap_part$s[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],conf.level = conf)
           t_this<-t.test.twosample.dependent(x1 = by_ap_part$s[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],x2 = by_ap_part$s[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.difference = 0,conf.level = conf)
           R_maxmin<-min(s_bar[app_combis[1,i]],s_bar[app_combis[2,i]])/max(s_bar[app_combis[1,i]],s_bar[app_combis[2,i]])
         }
         
         app_rep<-rbind(app_rep,c(
           cor_this[["estimate"]][["sample.size"]],
           cor_this[["estimate"]][["sample.r"]],
           cor_this[["p.value"]],
           t_var_this[["statistic"]][["t statistic"]],
           t_var_this[["p.value"]],
           R_maxmin,
           t_this[["statistic"]][["t statistic"]],
           t_this[["p.value"]]
         )
         )
         rownames(app_rep)[nrow(app_rep)]<-paste0(app_combis[1,i]," vs ",app_combis[2,i])
         #reproducibility across appraiser
         
         cor_this<-cor.pearson.r.onesample(x = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],y = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.rho = 0,conf.level = conf)
         t_var_this<-variance.test.twosample.dependent(g1 = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],g2 = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],conf.level = conf)
         t_this<-t.test.twosample.dependent(x1 = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[1,i] & by_ap_part$Trial==1],x2 = by_ap_part$Mean[by_ap_part$Appraiser==app_combis[2,i] & by_ap_part$Trial==1],null.hypothesis.difference = 0,conf.level = conf)
         
         app_repr<-rbind(app_repr,c(
           cor_this[["estimate"]][["sample.size"]],
           cor_this[["estimate"]][["sample.r"]],
           cor_this[["p.value"]],
           t_var_this[["statistic"]][["t statistic"]],
           t_var_this[["p.value"]],
           t_this[["estimate"]][["sample.mean"]],
           t_this[["statistic"]][["t statistic"]],
           t_this[["p.value"]]
         )
         )
         
         rownames(app_repr)[nrow(app_repr)]<-paste0(app_combis[1,i]," vs ",app_combis[2,i])
         
       }
       
     }#end multi appraiser
       
       # app_rep has the repeatabilty across appraiser
       # app_repr has the reproducibility across appraiser
       #have all information for output for potential study
       #potential study html output
       
       app_rep<-ro(app_rep,R)
       app_repr<-ro(app_repr,R)
       repeat_width<-seq(1,9)
       
       
       
       output_repeat_ap<-c("<h5><b><u>Repeatability (Variation Measuring the Same Items Within and Across Appraiser)</b></u></h5>")
       
       for(i in as.numeric(app_id)){#each appraiser
         output_repeat_ap<-c(output_repeat_ap,
                             "<u><b>",rownames(rep_analysis)[(i-1)*test_num+1]," Repeatability Analysis</b></u><br/>",
                             "<table style='margin-left:auto;margin-right:auto'><tr><th>Trials</th><th>n</th><th>r</th><th>p(r)</th><th>t(Var)</th><th>p(Var)</th><th>Diff</th><th>t(Means)</th><th>p(Means)</th></tr>"
         )
         
         for(j in tests){#for each comparison we have a row
           output_repeat_ap<-c(output_repeat_ap,"<tr>")
           for(k in repeat_width){#across table row
             if(k==4 || k==6 || k==9){
               if(as.numeric(rep_analysis[(test_num*(i-1)+j),k]) < (1-conf)){
                 output_repeat_ap<-c(output_repeat_ap,
                                     "<td>",rep_analysis[(test_num*(i-1)+j),k],"*</td>")
               } else {
                 output_repeat_ap<-c(output_repeat_ap,
                                     "<td>",rep_analysis[(test_num*(i-1)+j),k],"</td>")
               }
             } else {
               output_repeat_ap<-c(output_repeat_ap,
                                   "<td>",rep_analysis[(test_num*(i-1)+j),k],"</td>")
             }
             
             
           }#end row of table
           output_repeat_ap<-c(output_repeat_ap,"</tr>")
           
         }#end tests for
         output_repeat_ap<-c(output_repeat_ap,"</table><br/>")
       }#end app_id for
       
       #repeatability by appraiser 
       output_repsys_ap<-NULL
       if(length(app_id)!=1){#single appraiser
       repeat_width<-seq(1,8)
       
       if(calc==1){
         output_repsys_ap<-c(output_repsys_ap,
                             "<br/><u><b>System Repeatability Analysis</b></u><br/>",
                             "<table style='margin-left:auto;margin-right:auto'><tr><th>Appraisers</th><th>n</th><th>r(Range)</th><th>p(r)</th><th>t(Var Range)</th><th>p(Var Range)</th><th>Rmin/Rmax</th><th>t(Range)</th><th>p(Range)</th></tr>"
         )
       }
       if(calc==2 || calc==3){
         output_repsys_ap<-c(output_repsys_ap,
                             "<br/><u><b>System Repeatability Analysis</b></u><br/>",
                             "<table style='margin-left:auto;margin-right:auto'><tr><th>Appraisers</th><th>n</th><th>r(s)</th><th>p(r)</th><th>t(Var s)</th><th>p(Var s)</th><th>s min/s max</th><th>t(s)</th><th>p(s)</th></tr>"
         )
       }
       
       for(j in apps){#for each comparison we have a row
         output_repsys_ap<-c(output_repsys_ap,"<tr><td>",rownames(app_rep)[j],"</td>")
         for(k in repeat_width){#across table row
           if(k==3 || k==5 || k==8){
             if(as.numeric(app_rep[j,k]) < (1-conf)){
               output_repsys_ap<-c(output_repsys_ap,
                                   "<td>",app_rep[j,k],"*</td>")
             } else {
               output_repsys_ap<-c(output_repsys_ap,
                                   "<td>",app_rep[j,k],"</td>")
             }
           } else {
             output_repsys_ap<-c(output_repsys_ap,
                                 "<td>",app_rep[j,k],"</td>")
           }
           
         }#end row of table
         output_repsys_ap<-c(output_repsys_ap,"</tr>")
         
       }#end tests for
       output_repsys_ap<-c(output_repsys_ap,"</table><br/>")
       #}#end app_id for
       }
       #overall repeatability by appraiser and overall
       output_repsys<-NULL
       if(calc==1){
         output_repsys<-c(output_repsys,"<br/>",
                          "<table style='margin-left:auto;margin-right:auto'><tr><th>Appraiser</th><th>Repeated Measures</th><th>n</th><th>",paste(withMathJax("$\\bar{R}$")),"</th><th>",paste(withMathJax("$\\sigma_{EV}$")),"</th><th>",paste0(sigma,withMathJax("$\\sigma_{EV}$")),"</th><th>%EV</th></tr>"
         )
       }
       if(calc==2 || calc==3){
         output_repsys<-c(output_repsys,"<br/>",
                          "<table style='margin-left:auto;margin-right:auto'><tr><th>Appraiser</th><th>Repeated Measures</th><th>n</th><th>",paste(withMathJax("$\\bar{s}$")),"</th><th>",paste(withMathJax("$\\sigma_{EV}$")),"</th><th>",paste0(sigma,withMathJax("$\\sigma_{EV}$")),"</th><th>%EV</th></tr>"
         )
       }
       
       repeat_width<-seq(1,7)
       
       for(i in app_id){
         g<-length(unique(by_ap_part$Part[by_ap_part$Appraiser==i]))
         m<-length(unique(by_ap_part$Trial[by_ap_part$Appraiser==i]))
         if(calc==1){
           std_rpt<-ro(R_bar[i]/d2.star(g = g,m = m),R)
         } else if (calc==2 || calc==3){
           std_rpt<-ro(s_bar[i]/spc.constant.calculation.c4(m),R)
         }
         nt_ev<-ro(sigma*std_rpt,R)
         if(calc==1){
           output_repsys<-c(output_repsys,"<tr><td>",i,"</td>",
                            "<td>",m,"</td>",
                            "<td>",g,"</td>",
                            "<td>",ro(R_bar[i],R),"</td>",
                            "<td>",std_rpt,"</td>",
                            "<td>",nt_ev,"</td>",
                            "<td>",ro(100*nt_ev/spec_range,1),"%</td></tr>"
           )
         }
         if(calc==2 || calc==3){
           output_repsys<-c(output_repsys,"<tr><td>",i,"</td>",
                            "<td>",m,"</td>",
                            "<td>",g,"</td>",
                            "<td>",ro(s_bar[i],R),"</td>",
                            "<td>",std_rpt,"</td>",
                            "<td>",nt_ev,"</td>",
                            "<td>",ro(100*nt_ev/spec_range,1),"%</td></tr>"
           )
         }
       }#end loop through app_id
       
       #add overall row
       g<-length(parts)
       m<-length(trials)
       if(calc==1){
         output_repsys<-c(output_repsys,"<tr><td>","Overall</td>",
                          "<td>",m,"</td>",
                          "<td>",g,"</td>",
                          "<td>",ro(R_t,R),"</td>",
                          "<td>",ro(sig_rpt(),R),"</td>",
                          "<td>",ro(sigma*sig_rpt(),R),"</td>",
                          "<td>",ro(100*sigma*sig_rpt()/spec_range,1),"%</td></tr></table>"
         )
       }
       if(calc==2 || calc==3){
         output_repsys<-c(output_repsys,"<tr><td>","Overall</td>",
                          "<td>",m,"</td>",
                          "<td>",g,"</td>",
                          "<td>",ro(s_t,R),"</td>",#steve
                          "<td>",ro(sig_rpt(),R),"</td>",
                          "<td>",ro(sigma*sig_rpt(),R),"</td>",
                          "<td>",ro(100*sigma*sig_rpt()/spec_range,1),"%</td></tr></table>"
         )
       }
       #output_repsys<-unlist(output_repsys)
       #end of repeatability
       
       #reproducibility
       output_repro_head<-NULL
       output_repro_app<-NULL
       output_system_repro<-NULL
       
       if(length(app_id) != 1){#skip if single appraiser
       output_repro_head<-"<br/><h5><b><u>Reproducibility (Variation in Means of the Same Items Between and Across Appraisers)</b></u></h5>"
       
       output_repro_app<-"<table style='margin-left:auto;margin-right:auto'><tr><th>Trials</th><th>n</th><th>r</th><th>p(r)</th><th>t(Var)</th><th>p(Var)</th><th>Diff</th><th>t(Means)</th><th>p(Means)</th></tr>"
       repeat_width<-seq(1,8)
       
       #reproducibility across operators
       for(i in apps){#each appraiser
         output_repro_app<-c(output_repro_app,"<tr><td>",rownames(app_repr)[i],"</td>")
         
         for(k in repeat_width){#across table row
           if(k==3 || k==5 || k==8){
             if(as.numeric(app_repr[i,k]) < (1-conf)){
               output_repro_app<-c(output_repro_app,
                                   "<td>",app_repr[i,k],"*</td>")
             } else {
               output_repro_app<-c(output_repro_app,
                                   "<td>",app_repr[i,k],"</td>")
             }
           } else {
             output_repro_app<-c(output_repro_app,
                                 "<td>",app_repr[i,k],"</td>")
           }
           
           
         }#end row of table
         output_repro_app<-c(output_repro_app,"</tr>")
       }
       output_repro_app<-c(output_repro_app,"</table>")
       
       
       #######################
       output_system_repro<-c("<br/><u><b>System Reproducibility Analysis</b></u><br/>",
                              "<table style='margin-left:auto;margin-right:auto'><tr><th></th><th>Range</th><th>",paste0(withMathJax("$\\sigma_{AV}$")),"</th><th>",paste0(sigma,withMathJax("$\\sigma_{AV}$")),"</th><th>%AV</th></tr>",
                              "<tr><td>Overall</td><td>",ro(R_x,R),"</td><td>",ro(sig_rpd(),R),"</td><td>",ro(sigma*sig_rpd(),R),"</td><td>",ro(pct_AV,1),"%</td></tr></table>"
       )
       #output_system_repro<-unlist(output_system_repro)
       
       }#end if for not single appraiser
       output_system_all<-c("<br/><u><b>Total System Measurement Error</b></u><br/>",
                            "<table style='margin-left:auto;margin-right:auto'><tr><th></th><th>%EV</th><th>%AV</th><th>",paste0(sigma,withMathJax("$\\sigma_{e}$")),"</th><th>%R&R</th></tr>",
                            "<tr><td>Overall</td><td>",ro(pct_EV,1),"%</td><td>",ro(pct_AV,1),"%</td><td>",ro(sigma*sig_e(),R),"</td><td>",ro(pct_RR,1),"%</td></tr></table>"
       )
       
       #######################
       
       #final output with diagnostics
       
       output<-HTML(c(output_header,html_title,output_repeat_ap,output_repsys_ap,output_repsys,output_repro_head,output_repro_app,output_system_repro,output_system_all))
       sendSweetAlert(title = "Detailed Diagnostics",text = output,html = TRUE,width = "100%",showCloseButton = TRUE,btn_labels = "Close")
       updateSwitchInput(inputId = "msa_diagnostic",value = FALSE)
       HTML(output_header)
       
     })
       
     # d2.star<-function (g=2,m=2){
     #   d2<-spc.constant.calculation.d2(sample.size = m)
     #   d3<-spc.constant.calculation.d3(sample.size = g)
     #   df.v<-1/(-2+2*sqrt(1+2*((d3/d2)^2/g)))
     #   d2+(d2/(4*df.v))
     #   
     # }
     
     d2.star<-function (g=2,m=2){
       #replicate df table
       
       d2.star.tab<-c(1.41421,1.91155,2.23887,2.48124,2.67253,2.82981,2.96288,3.07794,3.17905,3.26909,3.35016,3.42378,3.49116,3.55333,3.61071,3.66422,3.71424,3.76118,3.80537,1.27931,1.80538,2.15069,2.40484,2.60438,2.76779,2.90562,3.02446,3.12869,3.22134,3.30463,3.38017,3.44922,3.51287,3.57156,3.62625,3.67734,3.72524,3.77032,1.23105,1.76858,2.12049,2.37883,2.58127,2.74681,2.88628,3.00643,3.11173,3.20526,3.28931,3.3655,3.43512,3.49927,3.55842,3.61351,3.66495,3.71319,3.75857,1.20621,1.74989,2.10522,2.36571,2.56964,2.73626,2.87656,2.99737,3.10321,3.1972,3.28163,3.35815,3.42805,3.49246,3.55183,3.60712,3.65875,3.70715,3.75268,1.19105,1.73857,2.09601,2.35781,2.56263,2.72991,2.87071,2.99192,3.09808,3.19235,3.27701,3.35372,3.42381,3.48836,3.54787,3.60328,3.65502,3.70352,3.74914,1.18083,1.73099,2.08985,2.35253,2.55795,2.72567,2.8668,2.98829,3.09467,3.18911,3.27392,3.35077,3.42097,3.48563,3.54522,3.60072,3.65253,3.70109,3.74678,1.17348,1.72555,2.08543,2.34875,2.5546,2.72263,2.86401,2.98568,3.09222,3.18679,3.27172,3.34866,3.41894,3.48368,3.54333,3.59888,3.65075,3.69936,3.74509,1.16794,1.72147,2.08212,2.34591,2.55208,2.72036,2.86192,2.98373,3.09039,3.18506,3.27006,3.34708,3.41742,3.48221,3.54192,3.59751,3.64941,3.69806,3.74382,1.16361,1.71828,2.07953,2.3437,2.55013,2.71858,2.86028,2.98221,3.08896,3.1837,3.26878,3.34585,3.41624,3.48107,3.54081,3.59644,3.64838,3.69705,3.74284,1.16014,1.71573,2.07746,2.34192,2.54856,2.71717,2.85898,2.981,3.08781,3.18262,3.26775,3.34486,3.41529,3.48016,3.53993,3.59559,3.64755,3.69625,3.74205,1.15729,1.71363,2.07577,2.34048,2.54728,2.716,2.85791,2.98,3.08688,3.18174,3.2669,3.34406,3.41452,3.47941,3.53921,3.59489,3.64687,3.69558,3.74141,1.1549,1.71189,2.07436,2.33927,2.54621,2.71504,2.85702,2.97917,3.0861,3.181,3.2662,3.34339,3.41387,3.47879,3.53861,3.5943,3.6463,3.69503,3.74087,1.15289,1.71041,2.07316,2.33824,2.5453,2.71422,2.85627,2.97847,3.08544,3.18037,3.26561,3.34282,3.41333,3.47826,3.5381,3.59381,3.64582,3.69457,3.74041,1.15115,1.70914,2.07213,2.33737,2.54452,2.71351,2.85562,2.97787,3.08487,3.17984,3.2651,3.34233,3.41286,3.47781,3.53766,3.59339,3.64541,3.69417,3.74002,1.14965,1.70804,2.07125,2.33661,2.54385,2.7129,2.85506,2.97735,3.08438,3.17938,3.26465,3.34191,3.41245,3.47742,3.53728,3.59302,3.64505,3.69382,3.73969,1.14833,1.70708,2.07047,2.33594,2.54326,2.71237,2.85457,2.97689,3.08395,3.17897,3.26427,3.34154,3.4121,3.47707,3.53695,3.5927,3.64474,3.69351,3.73939,1.14717,1.70623,2.06978,2.33535,2.54274,2.7119,2.85413,2.97649,3.08358,3.17861,3.26393,3.34121,3.41178,3.47677,3.53666,3.59242,3.64447,3.69325,3.73913,1.14613,1.70547,2.06917,2.33483,2.54228,2.71148,2.85375,2.97613,3.08324,3.17829,3.26362,3.34092,3.4115,3.4765,3.5364,3.59216,3.64422,3.69301,3.7389,1.1452,1.7048,2.06862,2.33436,2.54187,2.71111,2.85341,2.97581,3.08294,3.17801,3.26335,3.34066,3.41125,3.47626,3.53617,3.59194,3.644,3.6928,3.73869,1.14437,1.70419,2.06813,2.33394,2.54149,2.71077,2.8531,2.97552,3.08267,3.17775,3.26311,3.34042,3.41103,3.47605,3.53596,3.59174,3.6438,3.6926,3.7385,1.12838,1.69257,2.05875,2.32593,2.53441,2.70436,2.8472,2.97003,3.07751,3.17287,3.25846,3.33598,3.40676,3.47193,3.53198,3.58788,3.64006,3.68896,3.735
       )
       if(g>20){g<-21}
       if(m>20){m<-20} 
         return(d2.star.tab[(m-1)+((g-1)*19)])
       
     }
     
     output$msadangerzone<- renderPlot({msa_dangerzone()})
     msadangerzone_height<-reactive(400*4)
     msadangerzone_width<-reactive(400*8)
     downloadServer('msadangerzone', msa_dangerzone,height = msadangerzone_height,width = msadangerzone_width)
     
     msa_dangerzone<-reactive({
       if(!input$msa_graphs){return()}
       
       proc_mean<-input$proc_mean
       proc_std<-input$proc_std
       sigmas<-input$msa_sigmas#false is 5.15
       R<-input$deci_msa
       calc<-input$msa_calc
       use_range<-input$msa_range_b#logical true is spec
       spec_range<-input$msa_range#if !use_range this is range
       USL<-input$msa_USL
       LSL<-input$msa_LSL
       UI4<-as.numeric(UI4_d())#just for debounce
       
       validate(
         need(sig_e(),"No measurement error calculated"),
         need(proc_mean,"Need to enter a process mean"),
         need(proc_std,"Need to enter a process standard devation without measurement error"),
         need(!(use_range && (is.na(USL) && is.na(LSL))),"Need to enter specifications"),
         need(!(!use_range && is.na(spec_range)),"Need to enter specification range")
       )
       
       if(sigmas){sigma<-6} else {sigma<-5.15}
       
       
       # if(use_range && (is.na(USL) && is.na(LSL))){return()}
       # if(!use_range && is.na(spec_range))(return())
       
       if(!use_range){
         USL<-proc_mean+spec_range/2
         LSL<-proc_mean-spec_range/2
       }
       
       no_USL<-FALSE
       no_LSL<-FALSE
       
       if(use_range && is.na(USL)){
         no_USL<-TRUE
       }
       if(use_range && is.na(LSL)){
         no_LSL<-TRUE
       }
       
       if(use_range){
         spec_range<-USL-LSL
       }
       
       #req(proc_mean,proc_std)
       
       ##############
       
       x_lim<-c(proc_mean-(4*proc_std),proc_mean+(4*proc_std))#width of process
       
       y_dat<-dnorm(x = x_lim,mean = proc_mean,sd = proc_std)
       
       data<-cbind(x_lim,y_dat)
       data<-as.data.frame(data)
       norm_max<-dnorm(x = proc_mean,mean = proc_mean,sd = proc_std)
       
       #####% misclassification
       divisions<-100
       width=(x_lim[2]-x_lim[1])/divisions
       
       x_axis<-seq(x_lim[1],x_lim[2],length.out=divisions)
       
       #estimation is the probability of a part falling at a location times the 
       #probability of being misclassified. Misclassification occurs if the part
       #is really in spec but measuring out of spec or out of spec but measuring in spec
       
       if(!no_LSL){
         prob_misclass_l_in<-pnorm(q = LSL,mean = x_axis[x_axis>=LSL],sd = sig_e(),lower.tail = TRUE)*dnorm(x = x_axis[x_axis>=LSL],mean = proc_mean,sd = proc_std)*width
         prob_misclass_l_out<-pnorm(q = LSL,mean = x_axis[x_axis<LSL],sd = sig_e(),lower.tail = FALSE)*dnorm(x = x_axis[x_axis<LSL],mean = proc_mean,sd = proc_std)*width
         prob_misclass_l<-sum(prob_misclass_l_in,prob_misclass_l_out)
       } else {
         prob_misclass_l<-0
         prob_misclass_l_in<-0
         prob_misclass_l_out<-0
       }
       if(!no_USL){
         prob_misclass_u_in<-pnorm(q = USL,mean = x_axis[x_axis<=USL],sd = sig_e(),lower.tail = FALSE)*dnorm(x = x_axis[x_axis<=USL],mean = proc_mean,sd = proc_std)*width
         prob_misclass_u_out<-pnorm(q = USL,mean = x_axis[x_axis>USL],sd = sig_e(),lower.tail = TRUE)*dnorm(x = x_axis[x_axis>USL],mean = proc_mean,sd = proc_std)*width
         prob_misclass_u<-sum(prob_misclass_u_in,prob_misclass_u_out)
       }else {
         prob_misclass_u<-0
         prob_misclass_u_in<-0
         prob_misclass_u_out<-0
       }
       if(no_USL && no_LSL){
         pct_misclass<-NA
         pct_out_but_in<-NA
       } else{
         pct_misclass<-ro(100*sum(prob_misclass_u+prob_misclass_l),2)
         pct_out_but_in<-ro(100*(sum(prob_misclass_l_out)+sum(prob_misclass_u_out)),2)
         pct_in_but_out<-ro(100*(sum(prob_misclass_l_in)+sum(prob_misclass_u_in)),2)
       }
       
       p<-ggplot(data=data.frame(x_axis),aes(x=x_axis))
       
       if(!no_USL){
         danger<-ggplot_dangerzone(USL,sig_e(),norm_max,divisions)
         
         p<-p+geom_rect(data=danger,aes(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,alpha=alpha),fill=color[3])+
           guides(alpha="none")+
           geom_vline(aes(xintercept=USL),linetype=5,color=color[2])
       }
       
       if(!no_LSL){
         danger<-ggplot_dangerzone(LSL,sig_e(),norm_max,divisions)
         
         p<-p+geom_rect(data=danger,aes(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,alpha=alpha),fill=color[4])+
           guides(alpha="none")+
           geom_vline(aes(xintercept=LSL),linetype=5,color=color[2])
       }
       dis_cat<-msa.postprocess.ev.number.distinct.categories.simple(study.variation.part.part = proc_std,study.variation.total = sig_e())
       dis_rat<-msa.postprocess.ev.number.discrimination.ratio.simple(component.variance.total = proc_std^2+sig_e()^2,component.variance.gage.r.r = sig_e()^2)
         p<-p+
         geom_area(stat="function",fun=dnorm,args=list(mean=proc_mean,sd=proc_std),color=color[4],fill=color[4],alpha=.2)+
         annotate(geom="label",label="Process without Measurement Error",x=proc_mean,y=.25*norm_max)+
         annotate(geom="text",label=paste0("Process Mean = ",proc_mean),x=-Inf,y=1*norm_max,hjust="left")+
         annotate(geom="text",label=paste0("Process s =",proc_std),x=-Inf,y=.95*norm_max,hjust="left")+
         annotate(geom="text",label=paste0("Measurement Error = ",ro(sig_e(),R)),x=-Inf,y=.9*norm_max,hjust="left")+
         annotate(geom="text",label=paste0(sigma," sigmas"),x=-Inf,y=.85*norm_max,hjust="left")+
           annotate(geom="text",label=paste0("Discrete Categories = ",ro(dis_cat,R)),x=-Inf,y=.75*norm_max,hjust="left")+
           annotate(geom="text",label=paste0("Discrimination Ratio = ",ro(dis_rat,R)),x=-Inf,y=.7*norm_max,hjust="left")+
           labs(x="True Value",y="PDF",title="Misclassification Scenario",caption="Assuming the process being measured and the measurement error are in control and normally distributed",subtitle=paste0("Misclassified as in spec = ",pct_out_but_in,"%"," Misclassified as out of spec = ",pct_in_but_out,"%"," Total % Misclassified = ",pct_misclass,"%"))
         
         if(!is.na(spec_range)){
           p<-p+
             annotate(geom="text",label=paste0(ro(100*sigma*sig_e()/spec_range,1),"%R&R"),x=-Inf,y=.8*norm_max,hjust="left")
         }
         
         if(!no_USL){
           p<-p+
             annotate(geom="label",label="USL",x=USL,y=.4*norm_max)+
             annotate(geom="label",label="USL Danger Zone",x=USL,y=norm_max/2)
         }
         
         if(!no_LSL){
           p<-p+
             annotate(geom="label",label="LSL",x=LSL,y=.4*norm_max)+
             annotate(geom="label",label="LSL Danger Zone",x=LSL,y=norm_max/2)
         }
       
       p
       
     })
     
     ggplot_dangerzone<-function(mean,sd,max,divisions=100){
       x_steps<-seq(mean-4*sd,mean+4*sd,length.out=divisions+1)
       alpha_steps<-dnorm(x_steps[-(divisions+1)],mean=mean,sd=sd)
       alpha_steps[divisions/2]<-2*alpha_steps[divisions/2]#make it more transparent by giving one higher value at the mean
       y_min<-rep(0,divisions)
       y_max<-rep(max,divisions)
       rect_grad<-data.frame(xmin=x_steps[-(divisions+1)],
                             xmax=x_steps[-1],
                             alpha=alpha_steps,
                             ymin=y_min,
                             ymax=y_max)
     }
     
     
     output$msavarcompgraph<-renderPlot({msa_var_comp_graph()})
     msavarcompgraph_width<-reactive(400*4)
     msavarcompgraph_height<-reactive(400*4)
     downloadServer('msavarcompgraph', msa_var_comp_graph,height = msavarcompgraph_height,width = msavarcompgraph_width)
     
     
     msa_UI1<-reactive({
       input$msa_UI1
     })
     
     UI1_d<-debounce(msa_UI1,millis = 500)#this tries to keep the charts from drawing as the UI is rendering
     
     msa_UI2<-reactive({
       input$msa_UI2
     })
     
     UI2_d<-debounce(msa_UI2,millis = 500)#this tries to keep the charts from drawing as the UI is rendering
     
     msa_UI3<-reactive({
       input$msa_UI3
     })
     
     UI3_d<-debounce(msa_UI3,millis = 500)#this tries to keep the charts from drawing as the UI is rendering
     
     msa_UI4<-reactive({
       input$msa_UI4
     })
     
     UI4_d<-debounce(msa_UI4,millis = 500)#this tries to keep the charts from drawing as the UI is rendering
     
     msa_var_comp_graph<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       #if(!exists("sigma_e()")){return()}
       #if(!exists("msa_change()")){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#as.numeric(input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       go<-msa_init()
       
       #change<-msa_change()
       data<-msa_data_r()
       validate(need(all(!is.na(data)),"Missing data"))
       
       req(msa_init(),calc,UI1,UI2,UI3,UI4,data)#sig_e(),
       
       if(!is.numeric(sig_e()) || sig_e()==0){return()}
       
       if(calc==1 || calc==2){
         sig_rpd_2<-sig_rpd()^2
         sig_rpt_2<-sig_rpt()^2
         sig_e_2<-sig_e()^2
         pct_rpd<-ro(100*sig_rpd_2/sig_e_2,2)
         pct_rpt<-ro(100*sig_rpt_2/sig_e_2,2)
         
         data<-as.data.frame(rbind(pct_rpt,pct_rpd))
         data<-cbind(x=c("Total Measurement Variance","Total Measurement Variance"),y=data,Group=c("Repeatability","Reproducibility"))
         colnames(data)<-c("x","y","Source")
         
         p<-ggplot(data=data,aes(x=x,y=y,fill=Source,label=y))+
           geom_bar(stat="identity")+
           geom_label(aes(group=Source),fill="white",label=paste0(data$y,"%"),position=position_stack(vjust=.5))+
           scale_y_continuous(labels=function (x) paste0(x,"%"))+
           scale_fill_manual(values=color[-1])+
           labs(title="Components of Variation",x="",y="% of Measurement Error Variance")
       }
       else if(calc==3){
         if(is.na(sig_rpd())){
           sig_rpd_2<-0
           sig_app_2<-0
           sig_part_app_2<-0
         } else {
             sig_rpd_2<-sig_rpd()^2
             sig_app_2<-sig_app()^2
             sig_part_app_2<-sig_part_app()^2
         }
         
         sig_rpt_2<-sig_rpt()^2
         sig_e_2<-sig_e()^2
         
         pct_rpd<-ro(100*sig_rpd_2/sig_e_2,2)
         pct_rpt<-ro(100*sig_rpt_2/sig_e_2,2)
         pct_app<-ro(100*sig_app_2/sig_e_2,2)
         pct_part_app<-ro(100*sig_part_app_2/sig_e_2,2)
         
         data<-as.data.frame(rbind(pct_rpt,pct_rpd,pct_app,pct_part_app))
         x<-factor(c("Measurement Variance","Measurement Variance","Reproducibility","Reproducibility"),levels=c("Measurement Variance","Reproducibility"))
         Source<-factor(c("Repeatability","Reproducibility","Appraiser","Appraiser x Part"),levels=c("Repeatability","Reproducibility","Appraiser","Appraiser x Part"))
         data<-cbind(x,y=data,Source)
         colnames(data)<-c("x","y","Source")
         
         p<-ggplot(data=data,aes(x=x,y=y,fill=Source,label=y))+
           geom_bar(stat="identity")+
           geom_label(aes(group=Source),fill="white",label=paste0(data$y,"%"),position=position_stack(vjust=.5))+
           scale_y_continuous(labels=function (x) paste0(x,"%"))+
           scale_fill_manual(values=color[-1])+
           labs(title="Components of Variation",x="",y="% of Measurement Error Variance")
       }
       
       p
     })
     
     msa_scatter<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       go<-msa_init()
       R<-input$deci_msa
       conf<-input$conf_msa
       
       #change<-msa_change()
       data<-msa_data_r()
       
       if(is.atomic(data)){return(HTML("Need data"))}
       
       req(msa_init(),calc,UI1,UI2,UI3,UI4,data)
       
       if(!is.numeric(data$Part) || !is.numeric(data$Trial) || !is.numeric(data$Measures))(return(HTML("Need numeric data")))#check for appropriate data
       
       by_ap_part<-group_by(.data = data,Appraiser,Part)
       by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures),sd=sd(Measures))
       by_ap_part$Appraiser<-factor(by_ap_part$Appraiser)
       
       plot_data<-by_ap_part[which(by_ap_part$Trial==1),][-4][-3]
       plot_data$Appraiser<-factor(plot_data$Appraiser)
       if(nrow(plot_data)/length(unique(plot_data$Appraiser))<3){return()}#error trap for r calculation must have 3 obs per appraiser
       app_id<-as.factor(unique(by_ap_part$Appraiser))
       msa_lm<-NULL
       msa_r<-NULL
       msa_p<-NULL
       loop<-0
       
       if(calc==1){
         p<-ggplot(data = plot_data,aes(x=Mean,y=Range,color=Appraiser,shape=Appraiser,linetype=Appraiser))
         for(i in app_id){
            loop<-loop+1
           # msa_lm<-lm(Range~Mean,data = plot_data[which(plot_data$Appraiser==i),])
           r<-cor.pearson.r.onesample(x = plot_data$Mean[which(plot_data$Appraiser==i)],y = plot_data$Range[which(plot_data$Appraiser==i)])
           msa_r[i]<-ro(r[["estimate"]][["sample.r"]],R)
           msa_p[i]<-ro(r[["p.value"]],R)
           # p<-p+geom_abline(slope=msa_lm[["coefficients"]][["Mean"]],intercept=msa_lm[["coefficients"]][["(Intercept)"]])
           p<-p+geom_smooth(method="lm",se=FALSE)
         }
         min_x<-min(plot_data$Mean)
         max_y<-max(plot_data$Range)
         max_x<-max(plot_data$Mean)
         min_y<-min(plot_data$Range)
       }else if(calc==2){
         p<-ggplot(data = plot_data,aes(x=Mean,y=sd,color=Appraiser,shape=Appraiser,linetype=Appraiser))#,color=color)
         for(i in app_id){
           # msa_lm<-lm(sd~Mean,data = plot_data[which(plot_data$Appraiser==i),])
           r<-cor.pearson.r.onesample(x = plot_data$Mean[which(plot_data$Appraiser==i)],y = plot_data$sd[which(plot_data$Appraiser==i)])
           msa_r[i]<-ro(r[["estimate"]][["sample.r"]],R)
           msa_p[i]<-ro(r[["p.value"]],R)
           #p<-p+geom_abline(slope=msa_lm[["coefficients"]][["Mean"]],intercept=msa_lm[["coefficients"]][["(Intercept)"]])
           p<-p+geom_smooth(method="lm",se=FALSE)
         }
         min_x<-min(plot_data$Mean)
         max_y<-max(plot_data$sd)
         max_x<-max(plot_data$Mean)
         min_y<-min(plot_data$sd)
       }else if(calc==3){
         p<-ggplot(data = plot_data,aes(x=Mean,y=sd,color=Appraiser,linetype=Appraiser))#best for anova
         for(i in app_id){
           # msa_lm<-lm(sd~Mean,data = plot_data[which(plot_data$Appraiser==i),])
           r<-cor.pearson.r.onesample(x = plot_data$Mean[which(plot_data$Appraiser==i)],y = plot_data$sd[which(plot_data$Appraiser==i)])
           msa_r[i]<-ro(r[["estimate"]][["sample.r"]],R)
           msa_p[i]<-ro(r[["p.value"]],R)
           # p<-p+geom_abline(slope=msa_lm[["coefficients"]][["Mean"]],intercept=msa_lm[["coefficients"]][["(Intercept)"]])
           p<-p+geom_smooth(method="lm",se=FALSE)
         }
         min_x<-min(plot_data$Mean)
         max_y<-max(plot_data$sd)
         max_x<-max(plot_data$Mean)
         min_y<-min(plot_data$sd)
       }
       
       #add points
       p<-p+geom_point(aes(color=Appraiser,shape=Appraiser),size=5)
       
       #Make annotations
       note<-NULL
       loop<-1
       for(i in app_id){
         note<-paste0(i,
                             ": r = ",msa_r[i],
                             " p = ",msa_p[i],
                             if(msa_p[i]<(1-conf)){"*"}else{""})
         p<-p+annotate(geom = "text",x = min_x,y=max_y-((loop/20)*(max_y-min_y)),label=note,hjust=0)+
           labs(title = "Uniformity of Dispersion",subtitle = "If significant, dispersion changes with magnitude measured")
         loop<-loop+1
       }
       
       p
     })
     
     output$msascatter<-renderPlot({msa_scatter()})
     msascatter_width<-reactive(400*4)
     msascatter_height<-reactive(400*4)
     downloadServer('msascatter', msa_scatter,height = msascatter_height,width = msascatter_width)
     
     output$msabox<-renderPlot({msa_box()})
     msabox_width<-reactive(400*4)
     msabox_height<-reactive(app_num()*400*4)
     downloadServer('msabox', msa_box,height = msabox_height,width = msabox_width)
     
     output$msa_box<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msabox",height = app_num()*400)
     })
     
     msa_box<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       go<-msa_init()
       R<-input$deci_msa
       conf<-input$conf_msa
       
       #change<-msa_change()
       data<-msa_data_r()
       data$Part<-factor(data$Part)
       #data$Appraiser<-factor(data$Appraiser,labels = "Appraiser ")
       
       req(msa_init(),calc,UI1,UI2,UI3,UI4,data)
       
       norm<-input$norm_box
       
       if(norm){
         by_ap_part<-group_by(.data = data,Appraiser,Part)
         by_ap_part<-mutate(by_ap_part,Mean=mean(Measures),Normalized=Measures-Mean)
         data$Normalized<-by_ap_part$Normalized
         title<-"Normalized Plot by Apprasier Boxplot"
       } else(
         title = "Part by Appraiser Boxplot"
       )
       
       if(norm){p<-ggplot(data = data,aes(x=Part,y=Normalized))} else {p<-ggplot(data = data,aes(x=Part,y=Measures))}
       p<-p+geom_boxplot(fill=col_fill)+
         facet_grid(rows=data$Appraiser)+
         labs(title = title)
       
       p
       
     })
     
     output$msacchart1<-renderPlot({msa_cchart1()})
     msacchart1_width<-reactive(400*8)
     msacchart1_height<-reactive(app_num()*400*2)
     downloadServer('msacchart1', msa_cchart1,height = msacchart1_height,width = msacchart1_width)
     
     
     output$msa_cchart1<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msacchart1",height = app_num()*200)
     })
     
     msa_cchart1<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       go<-msa_init()
       R<-input$deci_msa
       conf<-input$conf_msa
       type<-input$msa_type #1=potential 2=short 3=long
       data<-msa_data_r()
       #data$Appraiser<-factor(data$Appraiser,labels = "Appraiser ")
       validate(need(all(!is.na(data)),"Missing data"))
       
         by_ap_part<-group_by(.data = data,Appraiser,Part)
         by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),sd=sd(Measures),Mean=mean(Measures))
         trials<-length(unique(by_ap_part$Trial))
         plot_data<-by_ap_part[which(by_ap_part$Trial==1),][-4][-3]
         
         rows<-nrow(plot_data)
         
         by_ap<-group_by(by_ap_part[which(by_ap_part$Trial==1),],Appraiser)
         by_ap<-mutate(by_ap,Ave_Range=mean(Range),Ave_sd=mean(sd),Ave_Mean=mean(Mean))
         #by_ap<-by_ap[which(by_ap_part$Trial==1),][c(5,6,7)]
         
         plot_data<-ungroup(by_ap)
         #plot_data$Appraiser<-factor(x = plot_data$Appraiser,labels = "Appraiser ")
         
         if(calc==1){#range
           UCL<-plot_data$Ave_Range*spc.constant.calculation.D4(sample.size = trials)
           LCL<-plot_data$Ave_Range*spc.constant.calculation.D3(sample.size = trials)
           plot_data<-cbind(plot_data,"UCL"=UCL,"LCL"=LCL)
           
           ool<-spc.controlviolation.evaluate.rules(control.rules =  spc.rulesets.outside.limits(),chart.series = plot_data$Range,center.line = plot_data$Ave_Range,control.limits.ucl = plot_data$UCL,control.limits.lcl = plot_data$LCL,zone.a.upper = plot_data$UCL,zone.a.lower = plot_data$LCL)
           
           # for (i in seq(1:rows)){
           #   if(ool[["rule.results"]][["outside.limits"]][i]){
           #     ool[["rule.results"]][["outside.limits"]][i]<-plot_data$Range[i]
           #   } else ool[["rule.results"]][["outside.limits"]][i]<-NA
           # }
           ool[["rule.results"]][["outside.limits"]][which(ool[["rule.results"]][["outside.limits"]]==FALSE)]<-NA
           ool[["rule.results"]][["outside.limits"]]<-ool[["rule.results"]][["outside.limits"]]*plot_data$Range
           
           p<-ggplot(data=plot_data,aes(x=Part,y=Range))+
             labs(y="Range Within Part")
           
           
         } else {#sd or ANOVA
           
           UCL<-plot_data$Ave_sd*spc.constant.calculation.B4(sample.size = trials)
           LCL<-plot_data$Ave_sd*spc.constant.calculation.B3(sample.size = trials)
           plot_data<-cbind(plot_data,"UCL"=UCL,"LCL"=LCL)
           
           ool<-spc.controlviolation.evaluate.rules(control.rules =  spc.rulesets.outside.limits(),chart.series = plot_data$sd,center.line = plot_data$Ave_sd,control.limits.ucl = plot_data$UCL,control.limits.lcl = plot_data$LCL,zone.a.upper = plot_data$UCL,zone.a.lower = plot_data$LCL)
           
           # for (i in seq(1:rows)){
           #   if(ool[["rule.results"]][["outside.limits"]][i]){
           #     ool[["rule.results"]][["outside.limits"]][i]<-plot_data$sd[i]
           #   } else ool[["rule.results"]][["outside.limits"]][i]<-NA
           # }
           ool[["rule.results"]][["outside.limits"]][which(ool[["rule.results"]][["outside.limits"]]==FALSE)]<-NA
           ool[["rule.results"]][["outside.limits"]]<-ool[["rule.results"]][["outside.limits"]]*plot_data$sd
           
           p<-ggplot(data=plot_data,aes(x=Part,y=sd))+
             labs(y="Standard Deviation Within Part")
         }
         
         p<-p+
           geom_point(size=3,color=color[4])+
           geom_hline(aes(yintercept = UCL),color=color[2],linetype=5)+
           scale_x_continuous(breaks = plot_data$Part)+
           facet_grid(rows = vars(plot_data$Appraiser))+#plot_data$Appraiser)+
           labs(title="Dispersion within Part Control Chart",subtitle = "Not in time order, only look for points outside of the limits")
         
         if(min(is.na(ool[["rule.results"]][["outside.limits"]]))==0){#need to avoid error if no ooc points
           p<-p+geom_point(aes(y=ool[["rule.results"]][["outside.limits"]]),size=4,color=color[2],shape=8)
         }
         if(!all(is.na(LCL))){
           p<-p+geom_hline(aes(yintercept = LCL),color=color[2],linetype=5)
         }
         
         if(nrow(data)/app_num()<100){
           p<-p+labs(caption="With fewer than 100 observations per appraiser, these limits are likely to change")
         }
       #show graph
       p
     })
     
     msa_chart0<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       
       #if(is.atomic(data)){return(ggplot(data,aes(x,y)+geom_blank()))}
       
       go<-msa_init()
       req(msa_init(),calc,UI1,UI2,UI3,UI4,data)
       sigmas<-input$msa_sigmas#false is 5.15
       if(sigmas){sigma<-6} else {sigma<-5.15}
       use_range<-input$msa_range_b#logical true is spec
       USL<-input$msa_USL
       LSL<-input$msa_LSL
       
       R<-input$deci_msa
       conf<-input$conf_msa
       type<-input$msa_type #1=potential 2=short 3=long
       
       sigma_e<-sig_e()
       #sigma_rpt<-
       
       #if(type==1){return()}#no chart needed for potential
       req(data)
       if(!is.null(USL)){
         data<-cbind(data,USL)
       }
       if(!is.null(LSL)){
         data<-cbind(data,LSL)
       }
       
       #data$Appraiser<-factor(data$Appraiser,labels = "Appraiser ")
       
       by_ap_part<-group_by(.data = data,Appraiser,Part)
       by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures),sd=sd(Measures),norm=Measures-Mean)
       by_ap_part$Appraiser<-factor(by_ap_part$Appraiser,labels = "Appraiser ")
       
       data$Normalized<-by_ap_part$norm
       
       by_ap<-group_by(.data = data,Appraiser)
       by_ap<-mutate(by_ap,Mean=mean(Measures))
       
       
       plot_data<-by_ap_part[which(by_ap_part$Trial==1),][-4][-3]
       app_id<-unique(by_ap_part$Appraiser)
       trials<-unique(data$Trial)
       repeats<-length(trials)
       
       if (calc==1){#range
         disp_bar<-NULL
         disp_UCL<-NULL
         disp_LCL<-NULL
         me_up<-NULL
         me_lo<-NULL
         for(i in app_id){
           disp_bar[i]<-mean(by_ap_part$Range[which(by_ap_part$Appraiser==i)])
           disp_UCL[i]<-disp_bar[i]*spc.constant.calculation.D4(sample.size = repeats)
           disp_LCL[i]<-disp_bar[i]*spc.constant.calculation.D3(sample.size = repeats)
           X_mean<-mean(by_ap_part$Measures[which(by_ap_part$Appraiser==i)])
         }
         
         #create the ST graph
         #data
         
         res_band<-sigma*sigma_e/2
         if(input$msa_jitter){jitter_width=.1}else{jitter_width=0}
         norm<-input$norm_chart0
         
         if(norm){
           by_ap$Mean<-0
           p<-ggplot(data = data,aes(x=Part,y=Normalized))
         } else(p<-ggplot(data = data,aes(x=Part,y=Measures)))
         
         #if(norm){p<-ggplot(data = data,aes(x=Part,y=Normalized))}else(p<-ggplot(data = data,aes(x=Part,y=Measures)))
         if(input$msa_violin){p<-p+geom_violin(aes(group=cut_width(Part,.1)),fill=adjustcolor(col = col_fill,alpha.f = .5),bw="sj")}
           p<-p+geom_jitter(width=jitter_width)+
           stat_summary(geom="point",fun="mean",size=4,color=color[2])+
           facet_grid(rows = data$Appraiser)
           if(norm){
             p<-p+geom_hline(aes(yintercept = by_ap$Mean,linetype="Normalized Average"))+
               scale_linetype_manual("Legend",values=c("Normalized Average"=1,"Measurement Error"=3,"Spec Limit"=4))
           } else{
             p<-p+geom_hline(aes(yintercept = by_ap$Mean,linetype="Average of Parts"))+
               scale_linetype_manual("Legend",values=c("Average of Parts"=1,"Measurement Error"=3,"Spec Limit"=4))
           }
           p<-p+geom_hline(aes(yintercept = by_ap$Mean+res_band,linetype="Measurement Error"),linewidth=1)+
           geom_hline(aes(yintercept = by_ap$Mean-res_band,linetype="Measurement Error"),linewidth=1)+
           labs(title="Measurement Error, Parts, and Specifications",y="Means and Individual Measurements",subtitle="Small dots are individual measurements, large dots are the averages for each part.")+
           theme(legend.position="top")+
           scale_x_continuous(breaks = data$Part)
         
         if(use_range && !norm){
           if(!is.na(USL)){
           p<-p+geom_hline(aes(yintercept = USL,linetype="Spec Limit"),linewidth=.75)
           }
           if(!is.na(LSL)){
             p<-p+geom_hline(aes(yintercept = LSL,linetype="Spec Limit"),linewidth=.75)
           }
         }
           range<-input$msa_range
           if(!use_range && norm && !is.na(range)){
             #range<-input$msa_range
             p<-p+geom_hline(aes(yintercept = -range/2,linetype="Spec Limit"),linewidth=.75)+
               geom_hline(aes(yintercept = range/2,linetype="Spec Limit"),linewidth=.75)
           }
         
         p
         
       } else {#s or ANOVA
         disp_bar<-NULL
         disp_UCL<-NULL
         disp_LCL<-NULL
         me_up<-NULL
         me_lo<-NULL
         for(i in app_id){
           disp_bar[i]<-mean(by_ap_part$sd[which(by_ap_part$Appraiser==i)])
           disp_UCL[i]<-disp_bar[i]*spc.constant.calculation.B4(sample.size = repeats)
           disp_LCL[i]<-disp_bar[i]*spc.constant.calculation.B3(sample.size = repeats)
           X_mean<-mean(by_ap_part$Measures[which(by_ap_part$Appraiser==i)])
         }
         
         #create the ST graph
         #data
         
         res_band<-sigma*sigma_e/2
         
         norm<-input$norm_chart0
         if(input$msa_jitter){jitter_width=.1}else{jitter_width=0}
         
         if(norm){
           by_ap$Mean<-0
         }
         if(norm){p<-ggplot(data = data,aes(x=Part,y=Normalized))}else(p<-ggplot(data = data,aes(x=Part,y=Measures)))
         #p<-ggplot(data = data,aes(x=Part,y=Measures))+
         if(input$msa_violin){p<-p+geom_violin(aes(group=cut_width(Part,.1)),fill=adjustcolor(col = col_fill,alpha.f = .5),bw="sj")}
         p<-p+geom_jitter(width=jitter_width)+
           stat_summary(geom="point",fun="mean",size=4,color=color[2])+
           facet_grid(rows = data$Appraiser)
         
         if(norm){
           p<-p+geom_hline(aes(yintercept = by_ap$Mean,linetype="Normalized Average"))+
             scale_linetype_manual("Legend",values=c("Normalized Average"=1,"Measurement Error"=3,"Spec Limit"=4))
         } else{
           p<-p+geom_hline(aes(yintercept = by_ap$Mean,linetype="Average of Parts"))+
             scale_linetype_manual("Legend",values=c("Average of Parts"=1,"Measurement Error"=3,"Spec Limit"=4))
         }
         
           #geom_hline(aes(yintercept = by_ap$Mean,linetype="Average of Parts"))+
           p<-p+geom_hline(aes(yintercept = by_ap$Mean+res_band,linetype="Measurement Error"),linewidth=1)+
           geom_hline(aes(yintercept = by_ap$Mean-res_band,linetype="Measurement Error"),linewidth=1)+
           labs(title="Measurement Error, Parts, and Specifications",y="Means and Individual Measurements",subtitle="Small dots are individual measurements, large dots are the averages for each part.")+
           #scale_linetype_manual(values=c("Average of Parts"=1,"Measurement Error"=3,"Spec Limit"=4))+
           theme(legend.position="top")+
           scale_x_continuous(breaks = data$Part)
         
           if(use_range && !norm){
             if(!is.na(USL)){
               p<-p+geom_hline(aes(yintercept = USL,linetype="Spec Limit"),linewidth=.75)
             }
             if(!is.na(LSL)){
               p<-p+geom_hline(aes(yintercept = LSL,linetype="Spec Limit"),linewidth=.75)
             }
           }
           range<-input$msa_range
           if(!use_range && norm && !is.na(range)){
             #range<-input$msa_range
             p<-p+geom_hline(aes(yintercept = -range/2,linetype="Spec Limit"),linewidth=.75)+
               geom_hline(aes(yintercept = range/2,linetype="Spec Limit"),linewidth=.75)
           }
         
         p
         
       }
       
     })
     
     output$msa_lt<-renderPlot((
       msa_lt()
     ))
     msalt_width<-reactive(400*8)
     msalt_height<-reactive(app_num()*1600*4)
     downloadServer("msalt", msa_lt,width = msalt_width,height = msalt_height)
     
     msa_lt<-reactive({
       calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       validate(need(all(!is.na(data)),"Missing data"))
       go<-msa_init()
       req(msa_init(),calc,UI1,UI2,UI3,UI4,data)
       sigmas<-input$msa_sigmas#false is 5.15
       if(sigmas){sigma<-6} else {sigma<-5.15}
       use_range<-input$msa_range_b#logical true is spec
       USL<-input$msa_USL
       LSL<-input$msa_LSL
       match_axis<-input$msd_lt_axis
       
       R<-input$deci_msa
       conf<-input$conf_msa
       type<-input$msa_type #1=potential 2=short 3=long
       
       sigma_e<-sig_e()
       #sigma_rpt<-
       
       #if(type==1 || type==1){return()}#no chart needed for potential
       req(data)
       data<-data[order(data$Appraiser,data$Trial),]
       
       ooc_rules<-spc.rulesets.nelson.1984.test.1.2.3.4()
       ooc_rules$runs<-spc.controlviolation.nelson.1984.test2.runs.create(point.count = 8)
       
       by_ap_part<-group_by(.data = data,Appraiser,Part)
       by_ap_part<-mutate(by_ap_part,Range=max(Measures)-min(Measures),Mean=mean(Measures),sd=sd(Measures))
       by_ap_part$Appraiser<-factor(by_ap_part$Appraiser,labels = "Appraiser ")
       
       by_ap<-group_by(.data = data,Appraiser)
       by_ap<-mutate(by_ap,Mean=mean(Measures))
       
       #MR_span(data = ,span = 2)
       
       app_id<-unique(data$Appraiser)
       trials<- max(data$Trial)
       parts<-unique(data$Part)
       data<-cbind(data,UCL=NA,LCL=NA,Mean=NA,ooc_x=NA,ooc_mr=NA,facet=NA)
       
       
       #MR_bar<-matrix(data = NA,nrow = length(app_id),ncol = length(parts))
       #x_bar<-matrix(data = NA,nrow = length(app_id),ncol = length(parts))
       
       for(i in app_id){#each appraiser
         for (j in parts){#each part
           subdat<-data[which(data$Appraiser==i & data$Part==j),]$Measures
           mr<-MR_span(data = subdat)
           mr_bar<-mean(mr[-1])
           x_bar<-mean(subdat)
           facet<-paste0(i,", Part ",j)
           UCL<-x_bar+mr_bar*spc.constant.calculation.A2(sample.size = 2,n.sigma = 3)*sqrt(2)
           LCL<-x_bar-mr_bar*spc.constant.calculation.A2(sample.size = 2,n.sigma = 3)*sqrt(2)
           UCL_mr<-mr_bar*spc.constant.calculation.D4(sample.size = 2,n.sigma = 3)
           ooc_mr<-spc.controlviolation.evaluate.rules(control.rules = spc.rulesets.outside.limits(),chart.series = mr,center.line = mr_bar,control.limits.ucl = UCL_mr,zone.a.upper = UCL_mr)
           if(length(subdat)<3){
             ooc_x<-spc.controlviolation.evaluate.rules(control.rules = spc.rulesets.outside.limits(),chart.series = subdat,center.line = x_bar,control.limits.ucl = UCL,zone.a.upper = UCL,control.limits.lcl = LCL,zone.a.lower = LCL)
           } else {ooc_x<-spc.controlviolation.evaluate.rules(control.rules = ooc_rules,chart.series = subdat,center.line = x_bar,control.limits.ucl = UCL,zone.a.upper = UCL,control.limits.lcl = LCL,zone.a.lower = LCL)}
           
           #ooc_filter<-ooc_mr || ooc_x
           ooc_x<-subdat*ooc_x$overall.results
           ooc_mr<-subdat*ooc_mr$overall.results
           data[which(data$Appraiser==i & data$Part==j),]$UCL<-UCL
           data[which(data$Appraiser==i & data$Part==j),]$LCL<-LCL
           data[which(data$Appraiser==i & data$Part==j),]$Mean<-x_bar
           data[which(data$Appraiser==i & data$Part==j),]$ooc_x<-ooc_x
           data[which(data$Appraiser==i & data$Part==j),]$ooc_mr<-ooc_mr
           data[which(data$Appraiser==i & data$Part==j),]$facet<-facet
         }
       }
       data$ooc_x[data$ooc_x==0]<-NA
       data$ooc_mr[data$ooc_mr==0]<-NA
       data$facet<-factor(data$facet,levels = unique(data$facet),labels = unique(data$facet))
       
       p<-ggplot(data = data,aes(x=Trial,y=Measures))+
         geom_point(color=color[4])+
         geom_line(color=color[4])+
         geom_line(aes(y=UCL),color=color[2],linetype=2)+
         geom_line(aes(y=LCL),color=color[2],linetype=2)+
         geom_line(aes(y=Mean),color=color[3])+
         geom_point(aes(y=ooc_x),color=color[2],shape=8,size=4)+
         geom_point(aes(y=ooc_mr),color=color[6],shape=6,size=4)+
         labs(title="Parts through Time",subtitle="Out of Limits, Runs, Trends, Alternating Values and Out of Moving Range Limits Marked")
       
       if(match_axis){
         p<-p+facet_grid(rows=data$facet)
         } else p<-p+facet_grid(rows=data$facet,scales="free")
       if(max(data$Trial)<25){
         p<-p+labs(caption="With fewer than 25 observations, these limits are likely to change")
       }
       p
     })
     
     
 
     output$msachart0<-renderPlot({msa_chart0()})
     msachart0_width<-reactive(400*8)
     msachart0_height<-reactive(app_num()*400*4)
     downloadServer('msachart0',msa_chart0, height = msachart0_height,width = msachart0_width)
     
     output$msa_cchart0<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(input$msa_UI4) #measures
       #if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msachart0",height = app_num()*400)
     })
     
     output$lt_plot<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msa_lt",height = app_num()*1600)
     })
     
     msa_lt_overall<-reactive({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       validate(need(max(data$Trial)>2,"Not enough data for chart"),
                need(all(!is.na(data)),"Missing data")
                )
       
       ooc_rules<-spc.rulesets.nelson.1984.test.1.2.3.4()
       ooc_rules$runs<-spc.controlviolation.nelson.1984.test2.runs.create(point.count = 8)
       data$Appraiser<-factor(data$Appraiser)
       
       by_ap_trial<-group_by(.data = data,Appraiser,Trial)
       by_ap_trial$Appraiser<-factor(by_ap_trial$Appraiser)
       by_ap_trial<-mutate(by_ap_trial,Mean=mean(Measures),sd=sd(Measures))
       
       plot_data<-by_ap_trial[which(by_ap_trial$Part==1),][-2]
       #plot_data$Appraiser<-factor(plot_data$Appraiser,labels = "Appraiser ")
       temp<-group_by(.data = plot_data,Appraiser)
       temp<-mutate(temp,
                    x_bar=mean(Mean),
                    s_bar=mean(sd),
                    mr_x=MR_span(Mean),
                    mr_s=MR_span(sd),
                    mean_mr_x=mean(mr_x,na.rm=T),
                    mean_mr_s=mean(mr_s,na.rm=T),
                    UCL_x=x_bar+mean_mr_x*spc.constant.calculation.A2(2)*sqrt(2),
                    LCL_x=x_bar-mean_mr_x*spc.constant.calculation.A2(2)*sqrt(2),
                    UCL_s=s_bar+mean_mr_s*spc.constant.calculation.A2(2)*sqrt(2),
                    LCL_s=s_bar-mean_mr_s*spc.constant.calculation.A2(2)*sqrt(2),
                    UCL_mr_x=mean_mr_x*spc.constant.calculation.D4(2)*sqrt(2),
                    LCL_mr_x=mean_mr_x*spc.constant.calculation.D3(2)*sqrt(2),
                    UCL_mr_s=mean_mr_s*spc.constant.calculation.D4(2)*sqrt(2),
                    LCL_mr_s=mean_mr_s*spc.constant.calculation.D3(2)*sqrt(2),
                    ooc_x=spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                              chart.series = Mean,
                                                              center.line = x_bar,
                                                              control.limits.ucl =UCL_x,
                                                              zone.a.upper = UCL_x,
                                                              ontrol.limits.lcl = LCL_x,
                                                              zone.a.lower = LCL_x)$overall.results*Mean,
                    ooc_x_mr=spc.controlviolation.evaluate.rules(control.rules = spc.rulesets.outside.limits(),
                                                                 chart.series = mr_x,
                                                                 center.line = mean_mr_x,
                                                                 control.limits.ucl = UCL_mr_x,
                                                                 zone.a.upper = UCL_mr_x,
                                                                 control.limits.lcl = LCL_mr_x,
                                                                 zone.a.lower = LCL_mr_x)$overall.results*Mean,
                    ooc_s=spc.controlviolation.evaluate.rules(control.rules = ooc_rules,
                                                             chart.series = sd,
                                                             center.line = s_bar,
                                                             control.limits.ucl = UCL_s,
                                                             zone.a.upper = UCL_s,
                                                             control.limits.lcl = LCL_s,
                                                             zone.a.lower = LCL_s)$overall.results*sd,
                    ooc_s_mr=spc.controlviolation.evaluate.rules(control.rules = spc.rulesets.outside.limits(),
                                                                 chart.series = mr_s,
                                                                 center.line =mean_mr_s,
                                                                 control.limits.ucl = UCL_mr_s,
                                                                 zone.a.upper = UCL_mr_s,
                                                                 control.limits.lcl = LCL_mr_s,
                                                                 zone.a.lower = LCL_mr_s)$overall.results*sd
                    
                    )
       
       
       plot_data<-temp
       
       plot_data$ooc_x[plot_data$ooc_x==0]<-NA
       plot_data$ooc_x_mr[plot_data$ooc_x_mr==0]<-NA
       plot_data$ooc_s[plot_data$ooc_s==0]<-NA
       plot_data$ooc_s_mr[plot_data$ooc_s_mr==0]<-NA
       
       #plot_data<-cbind(plot_data,ooc_x=ooc_x,ooc_s=ooc_s,ooc_x_mr=ooc_x_mr,ooc_s_mr=ooc_s_mr)
       
       #reform data for factor app and chart type
       trials<-max(plot_data$Trial)
       #app_num<-app_num()
       temp<-cbind.data.frame(Appraiser=c(plot_data$Appraiser,plot_data$Appraiser),
                              trial=c(plot_data$Trial,plot_data$Trial),
                              chart=c(rep("Mean",trials*app_num()),rep("s",trials*app_num())),
                              point=as.numeric(c(plot_data$Mean,plot_data$sd)),
                              UCL=as.numeric(c(plot_data$UCL_x,plot_data$UCL_s)),
                              LCL=as.numeric(c(plot_data$LCL_x,plot_data$LCL_s)),
                              Mean=as.numeric(c(plot_data$x_bar,plot_data$s_bar)),
                              ooc=as.numeric(c(plot_data$ooc_x,plot_data$ooc_s)),
                              ooc_mr=as.numeric(c(plot_data$ooc_x_mr,plot_data$ooc_s_mr))
                              )
                        
       factor<-paste0(temp$Appraiser," ",temp$chart)
       levels<-as.data.frame(unique(factor))
       order<-c(seq(from=1,to=app_num()*2,by=2),seq(from=2,to=app_num()*2,by=2))
       levels<-cbind(levels,order)
       levels<-levels[order(order),]
       temp<-cbind(temp,facet=factor)
       temp$facet<-factor(temp$facet,levels=levels$`unique(factor)`,labels=levels$`unique(factor)`,ordered = TRUE)
       
       p<-ggplot(data = temp,aes(x=trial,y=point,group=1))+
           geom_point(aes(y=point),color=color[4])+
           geom_line(aes(y=point),color=color[4])+
           geom_line(aes(y=Mean),color=color[3])+
           geom_line(aes(y=UCL),color=color[2],linetype=2)+
           geom_line(aes(y=LCL),color=color[2],linetype=2)+
           geom_point(aes(y=ooc),color=color[2],shape=8,size=4)+
           geom_point(aes(y=ooc_mr),color=color[6],shape=6,size=4)+
         facet_grid(row=vars(facet),scales="free")+
         labs(title="Average and Standard Deviation by Trial - MR Limits",subtitle="Out of Limits, Runs, Trends, Alternating Values and Out of Moving Range Limits Marked",x="Trial",y="Measures")
       
       if(max(data$Trial)<25){
         p<-p+labs(caption="With fewer than 25 observations, these limits are likely to change")
       }
       
       p
       
     })
     
     output$msa_lt_overall<-renderPlot({msa_lt_overall()})
     msaltoverall_height<-reactive(app_num()*400*4)
     msaltoverall_width<-reactive(400*8)
     downloadServer('msa_lt_overall', msa_lt_overall,height = msaltoverall_height,width = msaltoverall_width)
     
     output$lt_plot_2<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msa_lt_overall",height = app_num()*400)
     })
     
     observe({
       type<-input$msa_type
       req(type)
       if(type==1){
         updateRadioButtons(inputId = "msa_calc",selected = 1)
       } else
       if(type==3){
         updateRadioButtons(inputId = "msa_calc",selected = 2)
       }
     })
     
     observeEvent(input$msa_details,{
       flag<-input$msa_details
       type<-input$msa_type
       if(!flag){return()}
       req(type)
       
       if(type==1){
         title="Potential Study Details"
         desc<-"A <b>potential study</b> is a quick way to determine if a particular measurement system has a chance of being useful. A potential study is not sufficient by itself to guarantee long- or even short-term performance.<br/><br/>In a potential study 10 or more specimens are measured by one or more appraisers or systems two or three times."
       }
       else if(type==2){
         title="Short-Term Study Details"
         desc<-"A <b>short-term study</b> is to gather more information on a measurement system with some minimal information about stability through time. It provides more information and better estimates than a potential study. A short-term study does not monitor a process through time.<br/><br/>In a short-term study 25 specimens are measured by one or more appraisers four to eight times each."
       }
       else if(type==3){
         title="Long-Term Study Details"
         desc<-"A <b>long-term study</b> is to continually monitor a measurement system to assure that its results are stable through time and that the measurement system error is known. A long-term study can signal when it is time to recalibrate a measurement device and rule out measurement error as a source of nonconformance.<br/><br/>In a long-term study 8 or more parts are retained and measured periodically. After 25 measures, control limits can be established and used going forward."
       }
       
       sendSweetAlert(title = title,text = HTML(desc),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
       updateCheckboxInput(inputId = "msa_details",value = FALSE)
     })
     
     
     msa_linearity<-reactive({
       #needs to be conditonal in UI
       #calc<-input$msa_calc #1=range 2=s 3=anova
       level<-input$msa_level
       if(level==2){return()}
       # UI1<-as.numeric(input$msa_UI1) #appraiser
       UI1<-as.numeric(UI1_d())#input$msa_UI1) #appraiser
       UI2<-as.numeric(UI2_d())#input$msa_UI2) #part
       UI3<-as.numeric(UI3_d())#input$msa_UI3) #trial
       
       # UI2<-as.numeric(input$msa_UI2) #part
       # UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(UI4_d())#input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-res_filter$filtered()#all data
       go<-msa_init()
       #req(msa_init(),calc,UI1,UI2,UI3,UI4,data)
       #sigmas<-input$msa_sigmas#false is 5.15
       #if(sigmas){sigma<-6} else {sigma<-5.15}
       #use_range<-input$msa_range_b#logical true is spec
       #USL<-input$msa_USL
       #LSL<-input$msa_LSL
       TV_col<-as.numeric(input$msa_UI5)
       R<-input$deci_msa
       conf<-input$conf_msa
       
       req(level,UI2,UI3,UI4,data,TV_col,R,conf,sig_e(),data,msa_data_r())
       
       
       
       TV<-na.omit(cbind(data[TV_col],data[UI2]))
       names(TV)<-c("TV","Part")
       TV<-TV[order(TV$Part),]
       if(length(unique(msa_data_r()$Part)) != nrow(TV)){return("Standards need to match Parts")}
       #diff<-msa_data_r()$Measures-TV$TV
       
       msa_data<-msa_data_r()[order(msa_data_r()$Appraiser,msa_data_r()$Trial,msa_data_r()$Part),]
      
      test_data<-merge(x = msa_data,y = TV,by="Part")#data.frame(cbind(Appraiser=msa_data$Appraiser,Measures=msa_data$Measures,TV=TV$TV,Part=msa_data$Part))
      test_data<-test_data[order(test_data$Appraiser,test_data$Trial,test_data$Part),]
      #names(test_data)<-c("Appraiser","Measures","TV","Parts")
      #test_data$Appraiser<-factor(test_data$Appraiser,labels = "Appraiser ")
      
      test_data$Bias<-test_data$Measures-test_data$TV
      all_combos<-expand.grid(TV$TV,TV$TV)
      all_combos$diff<-abs(all_combos[1]-all_combos[2])
      TV_width<-min(all_combos$diff[which(all_combos$diff>0),])
      
      test_data$lower<-NULL
      test_data$upper<-NULL
      model_text<-NULL
      bias_text<-NULL
      test_data$fit<-NA
      test_data$lwr<-NA
      test_data$upr<-NA
      test_data$se_fit_l<-NA
      test_data$se_fit_u<-NA
      corr_eq<-c(rep(NA,app_num()))
      
      for (i in unique(as.numeric(test_data$Appraiser))){#seq(1,app_num())
        subdat<-test_data[which(as.numeric(test_data$Appraiser)==i),]
        model<-lm(data = subdat,formula = Bias~TV)
        test<-cor.pearson.r.onesample(x = subdat$TV,y = subdat$Bias,null.hypothesis.rho = 0,conf.level = conf)
        pred<-predict(model,interval="prediction",level=conf,se.fit=TRUE)
        ave_bias<-t.test.onesample(x = subdat$Bias,null.hypothesis.mean = 0,conf.level = conf)
        model_text[i]<-paste0("Model ",i,": Bias = ",ro(model[["coefficients"]][["(Intercept)"]],R)," + ",ro(model[["coefficients"]][["TV"]],R)," * True Value ",": r = ",ro(test[["estimate"]][["sample.r"]],R)," : r\u00b2 = ",ro(test[["estimate"]][["r.squared"]],R)," : p(r=0) = ",ro(test[["p.value"]],R))
        bias_text[i]<-paste0("Average bias = ",ro(ave_bias[["estimate"]][["sample.mean"]],R)," : ",conf*100,"%CI = ",ro(ave_bias[["conf.int"]][1],R)," to ",ro(ave_bias[["conf.int"]][2],R)," : p(Bias=0) = ",ro(ave_bias[["p.value"]],R))
        if(test[["p.value"]] < (1-conf)){
          model_text[i]<-paste0(model_text[i],"*")
          model_corr<-lm(data = subdat,formula = TV~Measures)
          corr_eq[i]<-paste0("Correction Model ",i,": True Value = ",ro(model_corr[["coefficients"]][["(Intercept)"]],R)," + ",ro(model_corr[["coefficients"]][["Measures"]],R)," * Measured Value")
        }
        if(ave_bias[["p.value"]] < (1-conf)){
          bias_text[i]<-paste0(bias_text[i],"*")
        }
        test_data$fit[which(as.numeric(test_data$Appraiser)==i)]<-pred$fit[,1]
        test_data$lwr[which(as.numeric(test_data$Appraiser)==i)]<-pred$fit[,2]
        test_data$upr[which(as.numeric(test_data$Appraiser)==i)]<-pred$fit[,3]
        test_data$se_fit_l[which(as.numeric(test_data$Appraiser)==i)]<-pred$fit[,1]-pred$se.fit
        test_data$se_fit_u[which(as.numeric(test_data$Appraiser)==i)]<-pred$fit[,1]+pred$se.fit
      }
      model_labels<-data.frame(Appraiser=unique(test_data$Appraiser),label=model_text)
      bias_labels<-data.frame(Appraiser=unique(test_data$Appraiser),label=bias_text)
      correction_equation<-data.frame(Appraiser=unique(test_data$Appraiser),label=corr_eq)
      
      yscale_max<-max(test_data$Bias)
      yscale_range<-max(test_data$Bias)-min(test_data$Bias)
      x_mid<-(max(test_data$TV)-min(test_data$TV))*.5+min(test_data$TV)
      #test_data$Appraiser<-factor(test_data$Appraiser,labels = "Appraiser ")
      if(input$msa_jitter_line){jitter_width<-.1*TV_width}else{jitter_width=0}
        
      p<-ggplot(data=test_data,aes(x=TV,y=Bias))+
        facet_grid(rows=vars(Appraiser))+
        geom_hline(yintercept = 0)+
        geom_ribbon(aes(x=TV,ymin=se_fit_l,ymax=se_fit_u),fill="grey80")
        if(input$msa_violin_line){p<-p+geom_violin(aes(group=cut_width(TV,TV_width)),fill=adjustcolor(col = col_fill,alpha.f = .5),bw="sj")}
        p<-p+geom_line(aes(x=TV,y=fit),linetype="solid",color=color[1])+
        geom_line(aes(x=TV,y=lwr),linetype="dashed",color=col_fill_highlight)+
        geom_line(aes(x=TV,y=upr),linetype="dashed",color=col_fill_highlight)+
        #geom_point()+
        geom_jitter(width=jitter_width)+
        stat_summary(fun="mean", geom="point", size=4,color=color[2])+
        labs(title = "Bias Analysis: Measures - True Value",x="True Value")+
        geom_label(data=model_labels,mapping = aes(x=-Inf,y=Inf,label=label),hjust=0,vjust="top")+
        geom_label(data=bias_labels,mapping = aes(x=-Inf,y=yscale_max-(.05*yscale_range),label=label),hjust=0,vjust="top")+
        geom_label(data=correction_equation,mapping = aes(x=-Inf,y=yscale_max,label=label),hjust=0,vjust="top")+
        annotate(geom = "text",x = Inf,y=0,label="Bias = 0",hjust="right",vjust="top")
      
      #final plot
       p
     })
     
     output$msa_linearity<-renderPlot({
       msa_linearity()
     })
     
     output$msa_linearity_2<-renderUI({
       level<-input$msa_level
       if(level==2){return()}
       UI1<-as.numeric(input$msa_UI1) #appraiser
       UI2<-as.numeric(input$msa_UI2) #part
       UI3<-as.numeric(input$msa_UI3) #trial
       UI4<-as.numeric(input$msa_UI4) #measures
       if(length(UI4)==0 || UI3 == UI4){return(HTML("Waiting"))}#stop if the UI is still rendering
       data<-msa_data_r()
       go<-msa_init()
       req(msa_init(),UI1,UI2,UI3,UI4,data)
       
       #app<-length(unique(msa_data_r()$Appraiser))
       plotOutput("msa_linearity",height = app_num()*400)
     })
     linearityplot_height<-reactive(app_num()*400*4)
     linearityplot_width<-reactive(400*8)
     downloadServer("linearityPlot", msa_linearity,height = linearityplot_height,width = linearityplot_width)
     
     output$msa_d_1<-renderUI({
       data<-res_filter$filtered()
       req(data)
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       output<-pickerInput(inputId = "msa_d_UI1",
                           label = "Select Appraisers",
                           multiple=T,
                           options=list(`actions-box` = TRUE),
                           choices = choices)
     
     output
       
     })
     
     #the following works for when internal consistency is set up
     
     # observeEvent(c(input$msa_d_UI1,input$msa_d_internal), {#this is to add UI for selecting the repeated measures in the discrete gauge analysis, columns are on the selected data not loaded data
     #   data<-res_filter$filtered()
     #   req(data)
     #   UI1<-as.numeric(input$msa_d_UI1)
     #   do_internal<-input$msa_d_internal
     #   req(UI1)#,do_internal
     #   choices<-seq(1:ncol(data))#all columns
     #   names(choices)<-names(data)
     #   
     #   #take out those already selected
     #   fact_selected<-UI1
     #   temp<-seq_along(choices)
     #   temp<-temp[-fact_selected]
     #   choices<-choices[temp]
     #   sel_apps_names<-names(data)[UI1]
     #   
     #   num<-length(UI1)
     #   #keep everything in column numbers from data
     #   
     #     #adds<-seq(1,num)
     #   
     #   #delete any unneeded UI elements
     #   #if not doing internal consistency, delete all those UI elements
     #   if(!do_internal){
     #     for(i in fact_selected){
     #       #removeUI(selector = paste0("div:has(> #d_assessor",i,"control-label)"),immediate = TRUE)
     #       removeUI(selector = paste0("div:has(> #d_assessor",i,")"),immediate = TRUE)
     #       removeUI(selector = paste0("label[for~=\'d_assessor",i,"\']"),immediate = TRUE)
     #     }
     #     msa_d_assessor_num<<-NULL
     #     return()
     #   }
     #   #first remove current UI
     #       #
     #   if(!is.null(msa_d_assessor_num)){#if it is null it is the first time adding UI so we don't need this
     #     not_need<-msa_d_assessor_num[! msa_d_assessor_num %in% fact_selected]
     #     for (i in not_need){
     #       removeUI(selector = paste0("div:has(> #d_assessor",i,")"),immediate = TRUE)
     #       removeUI(selector = paste0("label[for~=\'d_assessor",i,"\']"),immediate = TRUE)
     #       }}
     #   
     #   #add new UI but skip ones that are already there
     #   position<-0
     #     for (i in fact_selected){
     #       position<-position+1
     #       if(i %in% msa_d_assessor_num){next}
     #       
     #       here<-ifelse(i==fact_selected[1],"#d_assessor0",paste0("div:has(> #d_assessor",fact_selected[position-1],")"))
     #       insertUI(
     #         selector=here,
     #         where="afterEnd",
     #         ui=pickerInput(inputId = paste0("d_assessor",i),
     #                        label = paste0("Select Repeated Measures for ",names(data)[i]),
     #                        multiple=T,
     #                        options=list(`actions-box` = TRUE),
     #                        choices = choices),
     #         immediate = TRUE
     #       )
     #     }
     #     msa_d_assessor_num<<-UI1
     #   
     #   # else if(num<msa_d_assessor_num){#subtract
     #   #   subs<-seq(num+1,msa_d_assessor_num)
     #   #   for (i in subs){
     #   #     removeUI(selector = paste0("div:has(>#d_assessor",i,")"))
     #   #   }
     #   #   msa_d_assessor_num<<-num
     #   #   }
     #   
     # })
     
     # output$msa_d_2<-renderUI({#make a UI element to select which columns are repeated measures, used as the location to add more UI in function above
     #   req(res_filter$filtered())
     #   UI1<-as.numeric(input$msa_d_UI1)
     #   req(UI1,input$msa_d_internal)
     #   choices<-seq(1:ncol(res_filter$filtered()))
     #   names(choices)<-names(res_filter$filtered())
     # 
     #   #take out those already selected
     #   fact_selected<-UI1
     #   temp<-seq(1:length(choices))
     #   temp<-temp[-fact_selected]
     #   choices<-choices[temp]
     #   sel_apps_names<-choices[UI1]
     # 
     #   output<-pickerInput(inputId = "d_assessor1",
     #                       label = "Select Repeated Measures for each Appraiser",
     #                       multiple=T,
     #                       options=list(`actions-box` = TRUE),
     #                       choices = list(sel_apps_names=choices))
     # 
     #   output
     # 
     # })
     
     # 
     # output$msa_d_3<-renderUI({
     #   req(res_filter$filtered())
     #   UI1<-as.numeric(input$msa_d_UI1)
     #   UI2<-as.numeric(input$msa_d_UI2)
     #   req(UI1,UI2)
     #   choices<-seq(1:ncol(res_filter$filtered()))
     #   names(choices)<-names(res_filter$filtered())
     #   
     #   #take out those already selected
     #   fact_selected<-c(UI1,UI2)
     #   temp<-seq(1:length(choices))
     #   temp<-temp[-fact_selected]
     #   choices<-choices[temp]
     #   
     #   output<-pickerInput(inputId = "msa_d_UI3",
     #                       label = "Select Data Column",
     #                       multiple=F,
     #                       options=list(`actions-box` = TRUE),
     #                       choices = choices)
     #   
     #   output
     #   
     # })
     
     output$msa_d_standard_ID<-renderUI({#returns the name of the element of appraiser for standard
       data<-res_filter$filtered()
       UI1<-as.numeric(input$msa_d_UI1)
       req(data,UI1)
       need_stand<-input$msa_d_standard
       req(need_stand==TRUE)
       
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       #take out those already selected
       fact_selected<-UI1
       temp<-seq(1:length(choices))
       temp<-temp[-fact_selected]
       choices<-choices[temp]
       
       #List of appraisers
       
       #app_list<-names(data[UI1])
       
       output<-pickerInput(inputId = "msa_d_stand_id",label = "Select Standard",choices = choices,multiple = F,options=list(`actions-box` = TRUE,style = "btn-success"))
       
       output
       
     })
     
     output$msa_out_d<-renderUI({
       UI1<-as.numeric(input$msa_d_UI1) #the column ID of the appraiser
       # UI2<-as.numeric(input$msa_d_2) #the column ID of the part
       # UI3<-as.numeric(input$msa_d_3) #the column ID of the data
       data<-res_filter$filtered()
       req(UI1,data)
       stand<-input$msa_d_standard #logical for if the standard is to be set
       stand_ID<-input$msa_d_stand_id #the column ID of the standard
       type<-input$msa_d_type#1=fixed  2=random
       
       if(length(UI1)==1 && length(stand_ID)==0){return()}#error trap
       
       diagnostic<-input$msa_diagnostic_d #logical to show details
       xtab<-input$msa_d_xtab #logical to show crosstabs
       R<-input$deci_msa_d #decimal places
       conf<-input$conf_msa_d #confidence
       
       #create complete independent data table for use in overall kappa and Light's G
       data_temp<-data[UI1]#selected appraisers data
       indep_data<-transform.dependent.format.to.independent.format(data_temp)
       indep_data<-cbind(ID=rep(1:nrow(data),length(UI1)),indep_data)#adds specimen ID
       
       #create matrices for appraisers
       app_names<-names(data[UI1])
       app_combos<-combn(UI1,2) #combo table for all appraisers
       num_compare<-length(app_combos)/2 #the number of comparisons between appraisers
       
       app_tables<-list() #initializing: the index is the combo number
       kappa_out<-list()#initializing: the index is the combo number
       mcnemar_out<-list() #initializing: the index is the combo number
       merged_compare<-list()#initializing a place to put more than three category results, index is the combo number
       dep_data<-list()#initializing dependent data for some of the kappa functions #this is a list where each element is each appraiser comparison
       
       categories <- sort(unique(unlist(data[UI1]))) #different categories, sorted
       num_cat<-length(categories)#number of different categories
       
       
       
       for (i in seq(1:num_compare)){
         app_tables[[i]]<-table(data[,app_combos[1,i]],data[,app_combos[2,i]])
         colnames(app_tables[[i]])<-paste0(names(data[app_combos[2,i]])," = ",colnames(app_tables[[i]]))
         rownames(app_tables[[i]])<-paste0(names(data[app_combos[1,i]])," = ",rownames(app_tables[[i]]))
         #dependent form for Fleiss' kappa function
           dep_data_temp<-data[c(app_combos[1,i],app_combos[2,i])]
           dep_data[[i]]<-transform.dependent.format.to.independent.format(data = dep_data_temp)
           dep_data[[i]]<-cbind(ID=seq(1,nrow(data)),dep_data[[i]])
           
         #calculate kappa
         if(type==1){#fixed Light's extension
           kappa_out[[i]]<-cor.cohen.kappa.onesample.1969.fleiss(observed.frequencies = app_tables[[i]],conf.level = conf, alternative = "greater")
         } else {#random, Fleiss'
           kappa_out[[i]]<-cor.cohen.kappa.onesample.1971.fleiss(subject = dep_data[[i]]$ID,rater = dep_data[[i]]$cell,rating = dep_data[[i]]$measure,conf.level = conf, alternative = "greater")
         }
         
         #calculate symmetry with McNemar's
         
         if(num_cat==2){#if two categories, mcnemar
           mcnemar_out[[i]]<-proportion.test.mcnemar.simple(b = app_tables[[i]][1,2],c = app_tables[[i]][2,1],conf.level = conf)
           }
         
         else{#if more than two categories, most significant matched cell difference for symmetry AND category vs. not
           #scan all McNemar and find most significant one, this is within num_compare
           mc_compare<-combn(x = seq(1,length(categories)),m = 2) #comparisons for the McNemar's tests
           mc_num<-length(mc_compare)/2 #number of comparisons for the McNemar's tests
           mc_temp<-list() #temporary place to store McNemar's tests
           mc_min<-1 #current lowest p-value of the mc_temp tests
           mc_sig<- 1 #ID of the current most significant McNemar test for reading after the loop
           
           for(j in 1:mc_num){
             b=app_tables[[i]][mc_compare[1,j],mc_compare[2,j]]
             c=app_tables[[i]][mc_compare[2,j],mc_compare[1,j]]
             test_err<-try(proportion.test.mcnemar.simple(b = b,c = c,conf.level = conf),silent = TRUE)
             if(inherits(test_err,'try-error')){#catch when mcnemar's throws a bogus error
               mc_temp[[j]]<-1
               mc_temp[[j]][["p.value"]]<-1
               }
             else {mc_temp[[j]]<-test_err}
             if(mc_temp[[j]][["p.value"]] < mc_min ){
               mc_sig<-j
               mc_min<-mc_temp[[j]][["p.value"]]
               }
           }
           
           mcnemar_out[[i]]<-mc_temp[[mc_sig]]
           
           #ratchet through each category vs merged other categories
           cat_analysis<-list()#initialize, kappa with index is the category vs all others
           cat_analysis_mc<-list()#initialize, mcnemars with index is the category vs all others
           
           for(k in 1:length(categories)){
             merge1<-apply(X = app_tables[[i]][,-k],1,sum)
             inter1<-cbind(app_tables[[i]][,k],merge1)
             merge2<-apply(X=inter1[-k,],2,sum)
             versusothers<-rbind(inter1[k,],merge2)
             cat_analysis[[k]]<-cor.cohen.kappa.onesample.1969.fleiss(observed.frequencies = versusothers)
             test_err2<-try(proportion.test.mcnemar.simple(b = versusothers[1,2],c = versusothers[2,1]),silent = TRUE)
             if(inherits(test_err2,'try-error')){#catch when mcnemar's throws a bogus error
               cat_analysis_mc[[k]]<-1
               cat_analysis_mc[[k]][["p.value"]]<-1
             }
             cat_analysis_mc[[k]]<-test_err2
           }#end merged
           merged_compare[[i]]<-c(cat_analysis,cat_analysis_mc)
           }#end more than two categories
         
       }#end appraiser to appraiser tests
       
       #if more than two appraisers, calculate average and overall kappa
       kappa_out
       agree_sum<-0
       disagree_sum<-0
       if(length(UI1)>2){
         #average is average for agree, disagree
         for (table in 1:num_compare){#go through each app_table
           #(sum(app_tables[[1]][1,1],app_tables[[2]][1,1],app_tables[[3]][1,1])+sum(app_tables[[1]][2,2],app_tables[[2]][2,2],app_tables[[3]][2,2]))/3
           agree_sum<-agree_sum+(sum(app_tables[[i]][1,1],app_tables[[i]][2,2]))#will only work with 2x2 need to generalize
           disagree_sum<-disagree_sum+(sum(app_tables[[i]][1,2],app_tables[[i]][2,1]))#will only work with 2x2 need to generalize
           
         }
         
         #overall is the ones where everyone agreed
         #create a single list something like this temp<-Map(c,dep_data[[1]],dep_data[[2]],dep_data[[3]]) nope duplicates
       }
       
       
       #app_tables
       
       #calculate G
       if(stand){
         req(stand_ID)
         if(is.null(stand_ID)){break}
         dep_data<-cbind(data[as.numeric(c(UI1,stand_ID))])
         light_data<-transform.dependent.format.to.independent.format(data = dep_data)
         light_data<-cbind(ID=seq(1,nrow(data)),light_data)
         val_out<-list()#initializing: the index is the column number for the appraiser
         val_sym_out<-list()#initializing: the index is the column number for the appraiser
         #kappa for each appraiser vs standard
         for (i in UI1){
           val_dat<-table(data[,i],data[,as.numeric(stand_ID)])
           val_out[[i]]<-cor.cohen.kappa.onesample.1969.fleiss(observed.frequencies = val_dat)
           test_err3<-try(proportion.test.mcnemar.simple(b = val_dat[1,2],c = val_dat[2,1]),silent = TRUE)
           if(inherits(test_err3,'try-error')){#catch when mcnemar's throws a bogus error{
             val_sym_out[[i]]<-1
             val_sym_out[[i]][["p.value"]]<-1
           } else{
             val_sym_out[[i]]<-test_err3
             }
         }
         
         #overall Light's G
         
         #re-form data for cor.light.onesample.1971
         stand_name<-names(data)[as.numeric(stand_ID)]
         
         # for (i in UI1){
         #   apname<-names(data)[i]
         #   subdat<-subset(light_data,cell==apname | cell==stand_name)
         #   val_out[[i]]<-cor.light.g.onesample(subject = subdat$ID,rater = subdat$cell,rating = subdat$measure,rater.standard = stand_name)
         # }
         light_out<-cor.light.g.onesample(subject = light_data$ID,rater = light_data$cell,rating = light_data$measure,rater.standard = stand_name)
         n_col_dep_data<-ncol(dep_data)
         t_m<-0
         for (i in 1:(n_col_dep_data-1)){
           t_m<-t_m+length(which(dep_data[i]==dep_data[n_col_dep_data]))
         }
         p_agree_G<-t_m/(2*nrow(dep_data))
       }
       
       #form into output
       
       if(type==1){#Light's fixed
         output<-HTML(paste0(
           "<h2>Measurement System Analysis Nominal or Ordinal Data<h2>",
           "<p>Confidence Level = ",conf*100,"%<p>",
           "<h3>Appraisers<h3>",
           "<p>",names(data)[UI1],"</p><br/>"
         )
         )
         
         #loop through tests add to the two output HTML
         conc_appraisers<-HTML(paste0(
           "<h3>Concordance Analysis Between Appraisers</h3>",
           "<table><tr><th>Group</th><th>n</th><th>n(Agree)</th><th>n(Disagree)</th><th>p(Agree)</th><th>p(Disagree)</th><th>p(Chance)</th><th>",withMathJax("$\\kappa_{max}$"),"</th><th>CI(low)</th><th>",withMathJax("$\\kappa$"),"</th><th>CI(high)</th><th>",withMathJax("$p(\\kappa)$"),"</th><th>",withMathJax("$p(Sym)$"),"</th></tr>"
           )
         )
         valid_appraisers<-HTML(paste0(
           "<h3>Validity Analysis (Concordance with Standard)</h3>",
           "<table><tr><th>Group</th><th>n</th><th>n(Agree)</th><th>n(Disagree)</th><th>p(Agree)</th><th>p(Disagree)</th><th>p(Chance)</th><th>",withMathJax("$\\kappa_{max}$"),"</th><th>CI(low)</th><th>",withMathJax("$\\kappa$"),"</th><th>CI(high)</th><th>",withMathJax("$p(\\kappa)$"),"</th><th>",withMathJax("$p(Sym)$"),"</th></tr>"
         )
         )
         for(i in 1:num_compare){#go through all appraiser comparisons
           conc_appraisers<-HTML(paste0(conc_appraisers,"<tr><td>",names(data[app_combos[1,i]])," vs ",names(data[app_combos[2,i]]),
                                   "<td>",kappa_out[[i]][["estimate"]][["n"]],"</td>",
                                   "<td>",kappa_out[[i]][["estimate"]][["n.agree"]],"</td>",
                                   "<td>",kappa_out[[i]][["estimate"]][["n.disagree"]],"</td>",
                                   "<td>",ro(kappa_out[[i]][["estimate"]][["p_o"]],R),"</td>",
                                   "<td>",ro(1-kappa_out[[i]][["estimate"]][["p_o"]],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["estimate"]][["p_c"]],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["estimate"]][["kappa.max"]],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["conf.int"]][1],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["estimate"]][["kappa"]],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["conf.int"]][2],R),"</td>",
                                   "<td>",ro(kappa_out[[i]][["p.value"]],R),if(kappa_out[[1]][["p.value"]]<(1-conf)){"*"}else{""},"</td>",
                                   "<td>",ro(mcnemar_out[[i]][["p.value"]],R),if(mcnemar_out[[i]][["p.value"]]<(1-conf)){"*"}else{""},"</td></tr>"
                                   )
                                 )
           
         }
         if(stand){
           for (i in UI1){
             valid_appraisers<-HTML(paste0(valid_appraisers,"<tr><td>",names(data[i])," vs Standard",
                                           "<td>",val_out[[i]][["estimate"]][["n"]],"</td>",
                                           "<td>",val_out[[i]][["estimate"]][["n.agree"]],"</td>",
                                           "<td>",val_out[[i]][["estimate"]][["n.disagree"]],"</td>",
                                           "<td>",ro(val_out[[i]][["estimate"]][["p_o"]],R),"</td>",
                                           "<td>",ro(1-val_out[[i]][["estimate"]][["p_o"]],R),"</td>",
                                           "<td>",ro(val_out[[i]][["estimate"]][["p_c"]],R),"</td>",
                                           "<td>",ro(val_out[[i]][["estimate"]][["kappa.max"]],R),"</td>",
                                           "<td>",ro(val_out[[i]][["conf.int"]][1],R),"</td>",
                                           "<td>",ro(val_out[[i]][["estimate"]][["kappa"]],R),"</td>",
                                           "<td>",ro(val_out[[i]][["conf.int"]][2],R),"</td>",
                                           "<td>",ro(val_out[[i]][["p.value"]],R),if(val_out[[i]][["p.value"]]<(1-conf)){"*"}else{""},"</td>",
                                           "<td>",ro(val_sym_out[[i]][["p.value"]],R),if(val_sym_out[[i]][["p.value"]]<(1-conf)){"*"}else{""},"</td></tr>"
             )
             )
           }
           valid_appraisers<-HTML(paste0(valid_appraisers,"</table>"))
           }
         conc_appraisers<-HTML(paste0(conc_appraisers,"</table>"))
         
         if(num_cat>2){
           #generate category analyses output
           #note about symmetry
           conc_appraisers<-HTML(paste0(conc_appraisers,"<br/><p><i>The symmetry p-value above is the most significant matched cell difference in the group.</i>"))
           conc_appraisers<-HTML(paste0(conc_appraisers,
             "<h4>Category Analysis Between Appraisers</h4>",
             "<table><tr><th>Comparison</th><th>n</th><th>n(Agree)</th><th>n(Disagree)</th><th>p(Agree)</th><th>p(Disagree)</th><th>p(Chance)</th><th>",withMathJax("$\\kappa_{max}$"),"</th><th>CI(low)</th><th>",withMathJax("$\\kappa$"),"</th><th>CI(high)</th><th>",withMathJax("$p(\\kappa)$"),"</th><th>",withMathJax("$p(Sym)$"),"</th></tr>"
             )
           )
           
           for (i in 1:num_compare){#loop through appraiser comparisons
             conc_appraisers<-HTML(paste0(conc_appraisers,
                                          "<tr><th>",names(data[app_combos[1,i]])," vs ",names(data[app_combos[2,i]]),"</th></tr>"
                                          ))
             for (j in 1:length(categories)){#loop through category analyses
               conc_appraisers<-HTML(paste0(conc_appraisers,
                        "<tr><td>",categories[j]," vs. Not</td>",
                        "<td>",merged_compare[[i]][[j]][["estimate"]][["n"]],"</td>",
                        "<td>",merged_compare[[i]][[j]][["estimate"]][["n.agree"]],"</td>",
                        "<td>",merged_compare[[i]][[j]][["estimate"]][["n.disagree"]],"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["estimate"]][["p_o"]],R),"</td>",
                        "<td>",ro(1-merged_compare[[i]][[j]][["estimate"]][["p_o"]],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["estimate"]][["p_c"]],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["estimate"]][["kappa.max"]],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["conf.int"]][1],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["estimate"]][["kappa"]],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["conf.int"]][2],R),"</td>",
                        "<td>",ro(merged_compare[[i]][[j]][["p.value"]],R),if(merged_compare[[i]][[j]][["p.value"]]<(1-conf)){"*"},"</td>",
                        "<td>",ro(merged_compare[[i]][[num_cat+j]][["p.value"]],R),if(merged_compare[[i]][[num_cat+j]][["p.value"]]<(1-conf)){"*"},"</td></tr>"
                        )
               )
               
             }#end category analysis
             
           }#end appraiser comparisons
           conc_appraisers<-HTML(paste0(conc_appraisers,"</table>"))
           }
         #validity tests
         if(stand){
           # val_out
           # val_sym_out
           # light_out
           # p_agree_G
           
           valid_appraisers<-HTML(paste0(valid_appraisers,
                                         "<br/><h3>Overall System Validity</h3>",
                                         "<table><tr><th>n</th><th>p(Agree)</th><th>p(Disagree)</th><th>G</th><th>p(G)</th></tr>",
                                         "<tr><td>",nrow(data),"</td>",
                                         "<td>",ro(p_agree_G,R),"</td>",
                                         "<td>",ro(1-p_agree_G,R),"</td>",
                                         "<td>",ro(light_out[["estimate"]][["G"]],R),"</td>",
                                         "<td>",ro(light_out[["p.value"]],R),if(light_out[["p.value"]]<conf){"*"},"</td>",
                                         "</tr></table>"
                                         ))
         } else(valid_appraisers<-NULL)
         
         
       }#end Light's output generation
       else{#Fleiss random
         
       }

       #output
       output<-HTML(c(conc_appraisers,valid_appraisers))
       output
     })
     
     output$dist_test_subtypes<-renderUI({
       type<-input$dist_test_type #distribution to be tested
       
       if(type==1){#Poisson
         output<-radioButtons(inputId = "dist_test_type_result",label = "Select Test",choices = c("Poisson Dispersion Test"=1))
       }
       else if(type==2){#normal
         output<-radioButtons(inputId = "dist_test_type_result",label = "Select Test",choices = c("Anderson-Darling"=2,"Shapiro-Wilk"=3,"Lin-Mudholkar"=4,"Skewness and Kurtosis"=5,"D'Agostino's Omnibus"=9))
       }
       else if(type==3){#expo
         output<-radioButtons(inputId = "dist_test_type_result",label = "Select Test",choices = c("Shapiro-Wilk"=6,"MVP"=7,"Anderson-Darling"=8))
       }
       
       output
     })
     
     output$dist_test_UI1<-renderUI({
       type<-input$dist_test_data_type
       data<-res_filter$filtered()
       req(type,data)
       
       if(type==1){#columns
         choices<-seq(1:ncol(data))
         names(choices)<-names(data)
         output<-pickerInput(inputId = "dist_testUI1",
                             label = "Select Columns",
                             multiple=T,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
       else {#factor
         choices<-seq(1:ncol(data))
         names(choices)<-names(data)
         output<-pickerInput(inputId = "dist_testUI1",
                             label = "Select Factor(s)",
                             multiple=T,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
         
       }
       output
       
     })
     
     output$dist_test_UI2<-renderUI({
       type<-input$dist_test_data_type
       data<-res_filter$filtered()
       UI1<-input$dist_testUI1
       req(type,data,UI1)
       
       choices<-seq(1:ncol(data))
       names(choices)<-names(data)
       
       if(type==1){NULL}
       
       else {#list data columns
         fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
         temp<-seq(1:length(choices))
         temp<-temp[-fact_selected]
         choices<-choices[temp]
         
         output<-pickerInput(inputId = "dist_testUI2",
                             label = "Select Data",
                             multiple=T,
                             options=list(`actions-box` = TRUE),
                             choices = choices)
       }
     })
     
     output$dist_test_out<-renderUI({
       test<-input$dist_test_type_result
       conf<-input$dist_test_conf
       R<-input$dist_test_decimals
       data<-res_filter$filtered()
       data_type<-input$dist_test_data_type
       UI1<-as.numeric(input$dist_testUI1)#columns if data_type==1 factors if not
       UI2<-as.numeric(input$dist_testUI2)#NULL if data_type==1, data columns if not
       req(test,data,UI1,R,data_type)
       if(data_type==2){
         req(UI2)
       }
       
       #init
       #result<-list()
       output<-NULL
       
       if (test==1){#Poisson
         output<-paste0("<h3>Poisson Dispersion Test</h3>",
                             "<table><tr><th>ID</th><th>Sample Mean</th><th>Sample Variance</th><th>\U1D6D8\U00B2</th><th>df</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-poisson.dist.test(data[[i]])
             output<-paste0(output,
                                 "<tr><td>",names(data[i]),"</td>",
                                 "<td>",ro(result[["estimate"]][["sample mean"]],R),"</td>",
                                 "<td>",ro(result[["estimate"]][["sample variance"]],R),"</td>",
                                 "<td>",ro(result[["statistic"]][["chi.square"]],R),"</td>",
                                 "<td>",ro(result[["parameter"]][["degrees of freedom"]],R),"</td>",
                                 "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
                          )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #sub_data<-data[i]#need this   subset(x = data,c1==1 & c2==1 & c3==1)     subset(x = data,eval(parse(text=sel)))      sel<-"c1==1 & c2==1 & c3==1"
               result<-poisson.dist.test(sub_data[[i]])
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",ro(result[["estimate"]][["sample mean"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["sample variance"]],R),"</td>",
                              "<td>",ro(result[["statistic"]][["chi.square"]],R),"</td>",
                              "<td>",ro(result[["parameter"]][["degrees of freedom"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
             }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         
       }#end of Poisson
       else if (test==2){#A-D
         ####################################
         output<-paste0("<h3>Anderson-Darling Normality Test</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>A\U00B2*</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-anderson.darling.normality.test(data[[i]])
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["estimate"]][["AA"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #sub_data<-data[i]#need this   subset(x = data,c1==1 & c2==1 & c3==1)     subset(x = data,eval(parse(text=sel)))      sel<-"c1==1 & c2==1 & c3==1"
               result<-anderson.darling.normality.test(sub_data[[i]])
               n<-length(na.omit(sub_data[[i]]))
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["estimate"]][["AA"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
         
       }
       else if (test==3){#S-W
         ####################################
         output<-paste0("<h3>Shapiro-Wilk Normality Test</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>W</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-shapiro.wilk.normality.test(data[[i]])
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #sub_data<-data[i]#need this   subset(x = data,c1==1 & c2==1 & c3==1)     subset(x = data,eval(parse(text=sel)))      sel<-"c1==1 & c2==1 & c3==1"
               result<-shapiro.wilk.normality.test(sub_data[[i]])
               n<-length(na.omit(sub_data[[i]]))
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
         
       }
       else if (test==4){#L-M
         ####################################
         output<-paste0("<h3>Lin-Mudholkar Normality Test (Only tests skewness)</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>r</th><th>z</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-lin.mudholkar.normality.test(data[[i]])
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",ro(result[["estimate"]][["sample.size"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["r"]],R),"</td>",
                            "<td>",ro(result[["statistic"]][["z statistic"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               n<-length(na.omit(sub_data[[i]]))
               if(n<10){
                 output<-paste0(output,
                                "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                                "<td colspan='4'>Ten points recommended to calculate Lin-Mudholkar: n = ",n,"</td></tr>"
                                )
                 next
               }
               #validate(need(n>10,paste0("Ten points recommended to calculate Lin-Mudholkar: ", "n = ",n)))
               result<-lin.mudholkar.normality.test(sub_data[[i]])
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",ro(result[["estimate"]][["sample.size"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["r"]],R),"</td>",
                              "<td>",ro(result[["statistic"]][["z statistic"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
       }
       else if (test==5){#S-K
         ####################################
         output<-paste0("<h3>Skewness and Kurtosis Normality Tests with ",conf*100,"% Confidence Intervals</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>g\U2083(low)</th><th>g\U2083</th><th>g\U2083(high)</th><th>p(Skew)</th><th>g\U2084(low)</th><th>g\U2084</th><th>g\U2084(high)</th><th>p(Kurt)</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-skewness.test(x = data[[i]],conf.level = conf,alternative = "two.sided")
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["conf.int"]][1],R),"</td>",
                            "<td>",ro(result[["statistic"]][["skewness"]],R),"</td>",
                            "<td>",ro(result[["conf.int"]][2],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td>"
             )
             result<-kurtosis.test(x = data[[i]],conf.level = conf,alternative = "two.sided")
             output<-paste0(output,
                            "<td>",ro(result[["conf.int"]][1],R),"</td>",
                            "<td>",ro(result[["statistic"]][["kurtosis"]],R),"</td>",
                            "<td>",ro(result[["conf.int"]][2],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #sub_data<-data[i]#need this   subset(x = data,c1==1 & c2==1 & c3==1)     subset(x = data,eval(parse(text=sel)))      sel<-"c1==1 & c2==1 & c3==1"
               result<-skewness.test(x = sub_data[[i]],conf.level = conf,alternative = "two.sided")
               n<-length(na.omit(sub_data[[i]]))
               if(is.nan(result[["p.value"]])){
                 result[["p.value"]]<-999
               }
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["conf.int"]][1],R),"</td>",
                              "<td>",ro(result[["statistic"]][["skewness"]],R),"</td>",
                              "<td>",ro(result[["conf.int"]][2],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td>"
               )
               result<-kurtosis.test(x = sub_data[[i]],conf.level = conf,alternative = "two.sided")#check - i am getting p-values when mvpstats does not
               if(is.nan(result[["p.value"]])){
                 result[["p.value"]]<-999
               }
               output<-paste0(output,
                              "<td>",ro(result[["conf.int"]][1],R),"</td>",
                              "<td>",ro(result[["statistic"]][["kurtosis"]],R),"</td>",
                              "<td>",ro(result[["conf.int"]][2],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
       }
       ######################################
       #D'Agostino's omnibus
       else if (test==9){
         ####################################
         output<-paste0("<h3>D'Angostino's Omnibus Test with ",conf*100,"% Confidence Intervals</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>g\U2083(low)</th><th>g\U2083</th><th>g\U2083(high)</th><th>p(Skew)</th><th>g\U2084(low)</th><th>g\U2084</th><th>g\U2084(high)</th><th>p(Kurt)</th><th>\U1D6D8\U00B2<th>p(\U1D6D8\U00B2)</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-dagostino.normality.omnibus.test(x = data[[i]],conf.level = conf)
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["estimate"]][["g3.lowerci"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g3.skewness"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g3.upperci"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g3.p.value"]],R),if(result[["estimate"]][["g3.p.value"]]<(1-conf)){"*"},"</td>"
             )
             #result<-kurtosis.test(x = data[[i]],conf.level = conf,alternative = "two.sided")
             output<-paste0(output,
                            "<td>",ro(result[["estimate"]][["g4.lowerci"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g4.kurtosis"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g4.upperci"]],R),"</td>",
                            "<td>",ro(result[["estimate"]][["g4.p.value"]],R),if(result[["estimate"]][["g4.p.value"]]<(1-conf)){"*"},"</td>"
             )
             output<-paste0(output,
                            "<td>",ro(result[["statistic"]][["chi.square"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
                            )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #sub_data<-data[i]#need this   subset(x = data,c1==1 & c2==1 & c3==1)     subset(x = data,eval(parse(text=sel)))      sel<-"c1==1 & c2==1 & c3==1"
               result<-dagostino.normality.omnibus.test(x = sub_data[[i]],conf.level = conf)
               n<-length(na.omit(sub_data[[i]]))
               if(is.nan(result[["estimate"]][["g3.p.value"]])){
                 result[["estimate"]][["g3.p.value"]]<-999
               }
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(all_combos[j,,drop=FALSE]),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["estimate"]][["g3.lowerci"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g3.skewness"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g3.upperci"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g3.p.value"]],R),if(result[["estimate"]][["g3.p.value"]]<(1-conf)){"*"},"</td>"
               )
               #result<-kurtosis.test(x = sub_data[[i]],conf.level = conf,alternative = "two.sided")#check - i am getting p-values when mvpstats does not
               if(is.nan(result[["p.value"]])){
                 result[["p.value"]]<-999
               }
                 if(is.nan(result[["estimate"]][["g4.p.value"]])){
                   result[["estimate"]][["g4.p.value"]]<-999
               }
               output<-paste0(output,
                              "<td>",ro(result[["estimate"]][["g4.lowerci"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g4.kurtosis"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g4.upperci"]],R),"</td>",
                              "<td>",ro(result[["estimate"]][["g4.p.value"]],R),if(result[["estimate"]][["g4.p.value"]]<(1-conf)){"*"},"</td>"
               )
               output<-paste0(output,
                              "<td>",ro(result[["statistic"]][["chi.square"]],R),"</td>")
               if(is.na(result[["p.value"]])){
                 output<-paste0(output,
                                "<td>NA</td></tr>"
                 )
                 
               }else{
                 output<-paste0(output,
                                "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
                 )
               }
                              
               
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
       }
       
       ######################################
       else if (test==6){#S-W exp
         ####################################
         req(input$dist_test_mvp_go>dist_test_mvp_count)
         dist_test_mvp_count<<-input$dist_test_mvp_go
         output<-paste0("<h3>Shapiro-Wilk Exponentiality Test</h3>",
                        "<table><tr><th>ID</th><th>n</th><th>W</th><th>p</th><th>Method</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             #result<-shapiro.wilk.exponentiality.test(x = data[[i]],alternative = "two.sided")
             result<-shapiro.exp.test(x = data[[i]])
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td>",
                            "<td>",result[["method"]],"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               #result<-shapiro.wilk.exponentiality.test(x=sub_data[[i]],alternative = "two.sided")
               result<-shapiro.exp.test(x=sub_data[[i]])
               n<-length(na.omit(sub_data[[i]]))
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(this_combo),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td>",
                              "<td>",result[["method"]],"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
         }#end of else (data type 2)
         ####################################
       }
       else if (test==7){#MVP exp
         ####################################
         req(input$dist_test_mvp_go>dist_test_mvp_count)
         dist_test_mvp_count<<-input$dist_test_mvp_go
         output<-paste0("<h3>MVP Exponentiality Test</h3>",
                        "Monte Carlo Estimation",
                        "<table><tr><th>ID</th><th>n</th><th>MVP(E)</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             result<-mvp_exp(x = data[[i]],max_sims = 100000)
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["MVP(E) = "]],R),"</td>",
                            "<td>",ro(result[["p-value"]],R),if(result[["p-value"]]<(1-conf)){"*"},"</td></tr>"
             )
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               result<-mvp_exp(x=sub_data[[i]])
               n<-length(na.omit(sub_data[[i]]))
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(this_combo),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["MVP(E) = "]],R),"</td>",
                              "<td>",ro(result[["p-value"]],R),if(result[["p-value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         ####################################
       }
       else if (test==8){#A-D exp
         ####################################
         x_min<-input$dist_test_zero#TRUE is use min from data
         output<-paste0("<h3>Anderson-Darling Exponentiality Test</h3>",
                        if(x_min){"Using data minimum as origin"},
                        "<br>Zeroes excluded if present",
                        "<table><tr><th>ID</th><th>n</th><th>W</th><th>p</th></tr>")
         if(data_type==1){#columns
           for (i in UI1){
             if(x_min){data[i]<-data[i]-min(na.omit(data[i]))}
             result<-exp_test_ad(x = data[[i]][which(data[[i]]>0)])
             n<-length(na.omit(data[[i]]))
             output<-paste0(output,
                            "<tr><td>",names(data[i]),"</td>",
                            "<td>",n,"</td>",
                            "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                            "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
             )
             
           }
           
         }#end of data type 1
         
         else{#analysis using factors
           all_combos<-unique(data[UI1])
           num_combos<-nrow(all_combos)
           num_factors<-1:length(UI1)
           
           for (i in UI2){#each column with data
             for(j in 1:num_combos){#each combo
               this_combo<-all_combos[j,]
               sel<-paste0("data$",names(data)[UI1],"==","'",this_combo,"'",collapse = " & ")
               sub_data<-data[which(eval(parse(text=sel))),]
               if(x_min){sub_data[i]<-sub_data[i]-min(sub_data[i])}
               result<-exp_test_ad(x=sub_data[[i]][which(sub_data[[i]]>0)])
               n<-length(na.omit(sub_data[[i]]))
               output<-paste0(output,
                              "<tr><td>",paste0(names(data)[i],": ",paste(names(this_combo),"=",this_combo,collapse = ", ")),"</td>",
                              "<td>",n,"</td>",
                              "<td>",ro(result[["statistic"]][["W"]],R),"</td>",
                              "<td>",ro(result[["p.value"]],R),if(result[["p.value"]]<(1-conf)){"*"},"</td></tr>"
               )
             }#end internal loop on combos
           }#end outer loop on data columns
           
           
         }#end of else (data type 2)
         output<-paste0(output,"<td colspan='4' style='text-align:left;'>Note that A-D unfairly rejects if the origin is > 0. If your data have a minimum greater than zero, check the 'Set origin to Xmin box.'")
         ####################################
       }
       
       #make pretty output from result
       output<-HTML(paste0(output,"</table>"))
       
       output
     })
     
     observeEvent(input$dist_test_type_result,{
       updateProgressBar(id = "mvp_exp_prog",value = 0,session = session)

     })
     
     mvp_exp<-function(x,bail=20000,max_sims=1000000){
       #Monte Carlo approach to exponential distribution testing by Michael V. Petrovich
       #The expected value of mvp_e is 1 if the distribution is exponentially distributed
       #mvp_rsd is the random sampling distribution of the MVP(E) statistic
       #filter out na
       x<-na.omit(x)
       samp_mean<-mean(x)
       samp_var<-var(x)
       samp_min<-min(x)
       mvp_e<-(samp_mean-samp_min)^2/samp_var
       n<-length(x)
       mvp_rsd<-rep(NA,max_sims)
       update_inc<-max_sims/100
       
       #early bail if it is clearly not exponential
       for (i in 1:bail){
         #take a sample of size n from theoretical exp dist
         sim<-samp_min+rexp(n = n,rate = samp_mean^-1)
         sum_x<-sum(sim)
         sim_mvp<-((sum_x/n)-min(sim))*((sum_x/n)-min(sim))/{{sum(sim*sim)-sum_x*sum_x/n}/(n-1)}#crazy math speeds it up
         mvp_rsd[i]<-sim_mvp
         if(i/update_inc==trunc(i/update_inc)){#only update a few times
           updateProgressBar(id = "mvp_exp_prog",value = i,total = max_sims,session = session)
           }
       }
       if(length(mvp_rsd[na.omit(mvp_rsd)>mvp_e])==0 || length(mvp_rsd[na.omit(mvp_rsd)>mvp_e])==bail){
           updateProgressBar(id = "mvp_exp_prog",value = 100,session=session)
           return(list("MVP(E) = "=mvp_e,"p-value"=0))
         }
       
       #continue
       for (i in (bail+1):max_sims){
         #take a sample of size n from theoretical exp dist
         sim<-samp_min+rexp(n = n,rate = samp_mean^-1)
         sum_x<-sum(sim)
         sim_mvp<-((sum_x/n)-min(sim))*((sum_x/n)-min(sim))/{{sum(sim*sim)-sum_x*sum_x/n}/(n-1)}#crazy math speeds it up
         mvp_rsd[i]<-sim_mvp
         if(i/update_inc==trunc(i/update_inc)){#only update a few times
           updateProgressBar(id = "mvp_exp_prog",value = i,total = max_sims,session = session)
         }
       }
       
       prop_above<-length(mvp_rsd[mvp_rsd>mvp_e])/max_sims
       prop_below<-length(mvp_rsd[mvp_rsd<mvp_e])/max_sims
       prop <- min(prop_above,prop_below)
       output<-list("MVP(E) = "=mvp_e,"p-value"=prop*2)
       return(output)
     }
     
     shapiro.exp.test<-function(x, bail=20000,nrepl=100000)
       #from package exptest, modified to give two-tailed p-value and have early bail
       #also modified to use lolcat's shapiro.wilk.exponentiality.test() if n<=100
     {
       x<-na.omit(x)
       DNAME <- deparse(substitute(x))
       l<-0
       n<-length(x)
       x<-sort(x)
       y<-mean(x)
       w<-n*(y-x[1])^2/((n-1)*sum((x-y)^2))
       update_inc<-nrepl/100
       
       #look up if n <= 100
       if(n <= 100){
         temp<-shapiro.wilk.exponentiality.test(x = x)
         
         
         prop.above<-NA
         prop.below<-NA
         p.value<-temp[["p.value"]]
         RVAL<-list(statistic=c(W=temp[["statistic"]][["W"]]), p.value=p.value, method="Lookup",data.name = DNAME)
         class(RVAL)<-"htest"
         return(RVAL)
         
       }
       
       for(i in 1:bail)
       {
         s<-rexp(n)
         s<-sort(s)
         y<-sum(s)/n#y<-mean(s)
         #W<-n*(y-s[1])^2/((n-1)*sum((s-y)^2))
         W<-n*(y-s[1])*(y-s[1])/((n-1)*sum((s-y)*(s-y)))
         if (W<w) l=l+1
         if(i/update_inc==trunc(i/update_inc)){#only update a few times
           updateProgressBar(id = "mvp_exp_prog",value = i,total = nrepl,session = session)
         }
       }
       
       if (l==0 || l==bail){
         RVAL<-list(statistic=c(W=w), p.value=0, method="Monte Carlo",data.name = DNAME)
         class(RVAL)<-"htest"
         return(RVAL)
         updateProgressBar(id = "mvp_exp_prog",value = 100,session = session)
         }
       
       for(i in (bail+1):nrepl)
       {
         s<-rexp(n)
         s<-sort(s)
         y<-sum(s)/n#y<-mean(s)
         #W<-n*(y-s[1])^2/((n-1)*sum((s-y)^2))
         W<-n*(y-s[1])*(y-s[1])/((n-1)*sum((s-y)*(s-y)))
         
         if (W<w) l=l+1
         if(i/update_inc==trunc(i/update_inc)){#only update a few times
           updateProgressBar(id = "mvp_exp_prog",value = i,total = nrepl,session = session)
         }
       }
       prop.above<-l/nrepl
       prop.below<-(nrepl-l)/nrepl
       p.value<-min(prop.above,prop.below)*2#two-sided
       RVAL<-list(statistic=c(W=w), p.value=p.value, method="Shapiro-Wilk test for exponentiality",data.name = DNAME)
       class(RVAL)<-"htest"
       return(RVAL)
     }
     
     output$dist_test_plot_select_b<-renderUI({
       if (input$dist_test_type !=1){
         radioGroupButtons(inputId = "dist_test_plot_select",label = "Choose plot type",choices = c("Density"=1,"Q-Q"=2,"P-P"=3),status="success")
       }
       else{
         radioGroupButtons(inputId = "dist_test_plot_select",label = "Choose plot type",choices = c("Histogram"=1,"CDF"=2),status="success")
       }
     })
     
     observeEvent(input$dist_test_info,{
       flag<-input$dist_test_info
       test<-input$dist_test_type_result
       if(!flag){return()}
       req(test)
       
       if(test==1){
         title="Poisson Dispersion Test"
         desc<-paste0("Just because you have rate data doesn't mean you have a Poisson distribution. The <b>Poisson Dispersion Test </b> takes advantage of the fact that for the Poisson distribution, the variance is equal to the mean. The statistic is defined as:",withMathJax("$$D=\\sum_{i=1}^N \\frac{(X_{i}-\\bar X)^2}{\\bar X}$$"),"where D follows approximately a \U1D6D8\U00B2 distribution with N-1 degrees of freedom.")
       }
       else if(test==2){
         title="Anderson-Darling Normality Test"
         desc<-"The <b>Anderson-Darling Normality Test</b> is a EDF (empirical distribution function) test based on the idea that if we hypothesize the data follows a distribution, normal in this case, we can transform the data into a uniform distribution and then test for uniformity with a distance test. It also has a weighting function to penalize deviations in the tails of the distribution, which is often what we are interested in anyway. <br><br>The A-D test was found to be <a href='https://www.researchgate.net/publication/267205556_Power_Comparisons_of_Shapiro-Wilk_Kolmogorov-Smirnov_Lilliefors_and_Anderson-Darling_Tests'>nearly as powerful as the Shapiro-Wilk test</a> for detecting departures from normality when compared against other common tests. <br><br>The A-D test can be used with sample sizes <20 and remains useful into larger sample sizes, though it can reject normality too easily at very large N."
       }
       else if(test==3){
         title="Shapiro-Wilk Normality Test"
         desc<-"The <b>Shapiro-Wilk Normality Test</b> was found to be the <a href='https://www.researchgate.net/publication/267205556_Power_Comparisons_of_Shapiro-Wilk_Kolmogorov-Smirnov_Lilliefors_and_Anderson-Darling_Tests'>most powerful test</a> for detecting departures from normality when compared against other common tests. <br><br>The S-W test can be used with sample sizes <20 and remains useful into larger sample sizes, though it can reject normality too easily at very large N."
       }
       else if(test==4){
         title="Lin-Mudholkar Normality Test"
         desc<-"The <b>Lin-Mudholkar Normality Test</b> is based on the fact that the mean and variance of a random sample are independent if and only if the parent population is normally distributed. <br><br>This test only detects departures from normality for skewness, but it is quite good at that. However, be aware that it is unlikley to reject for kurtosis."
       }
       else if(test==5){
         title="Skewness and Kurtosis Normality Tests"
         desc<-"Skewness is how asymmetrical a distribution is. Kurtosis is how peaked the distribution is. A normal distribution has zero skewness and kurtosis. The <b>Skewness and Kurtosis Tests</b> test the null hypothesis that both are zero. <br><br>These tests are not particularly powerful for smaller sample sizes (say below 20) but can be quite useful at larger sample sizes where more powerful tests reject too easily."
       }
       else if(test==6){
         title="Shapiro-Wilk Exponential Test"
         desc<-paste0("The <b>Shapiro-Wilk Exponential Test</b> is based on the fact that the mean of an exponential distribution is equal to the standard deviation. The statistic is calculated",withMathJax("$$W(E)=\\frac{n(\\bar{X}-X_{min})^2}{[(n-1)s]^2}$$"),"If the sample size is \U2264 100, the software refers to a standard lookup table with some interpolation between points. If the sample size is > 100, the software instead will begin a Monte Carlo simulation. First 20,000 samples of the same size as the data are taken from a theoretical exponential distribution with the mean and minimum found in the data, and W statistic is calculated for those samples. If none or all are above the W calculated for the sample, the p-value is estimated to be zero and the simulation stops. If not, more W statistics are calculated and the proportion that fall above and below the test statistic are calculated and the smaller one doubled to generate the final p-value.<br><br>With larger sample sizes, the simulation can take some time.")
       }
       else if(test==7){
         title="MVP Exponential Test"
         desc<-paste0("The <b>MVP Exponential Test</b> is a transform of the Shapiro-Wilk exponential test, but the statistic is more straightforward. The statistic is calculated from the sample data:",withMathJax("$$MVP(E)=\\frac{(\\bar{X}-X_{min})^2}{s^2}$$"),"The expected value of the statistic is 1. <br><br>First 20,000 samples of the same size as the data are taken from a theoretical exponential distribution with the mean and minimum found in the data, and MVP(E) is calculated for those samples. If none or all are above the MVP(E) calculated for the sample, the p-value is estimated to be zero and the simulation stops. If not, more MVP(E) statistics are calculated and the proportion that fall above and below the test statistic are calculated and the smaller one doubled to generate the final p-value. <br><br>With larger sample sizes, the simulation can take some time. <br><br>This test was created by Michael V. Petrovich.")
       }
       else if(test==8){
         title="Anderson-Darling Exponential Test"
         desc<-paste0("The <b>Anderson-Darling Exponential Test</b> is a EDF (empirical distribution function) test based on the idea that if we hypothesize the data follows a distribution, exponential in this case, we can transform the data into a uniform distribution and then test for uniformity with a distance test. <br><br>It also has a weighting function to penalize deviations in the tails of the distribution, which is often what we are interested in anyway. It is a very good test but requires that the origin parameter is zero. It will falsely reject exponential distributions with higher minimums. <br><br>An option is available to shift the data to an origin of zero by subtracting the minimum observation from the data set.")
       }
       else if(test==9){
         title="D'Agostino's Omnibus Normality Test"
         desc<-paste0("The <b>D'Agostino's Omnibus Normality Test</b> is based on the idea that while the RSD of the sample skewness and kurtosis converge to normality, they do so very slowly. D'Agostino suggested a transform that would make the skewness as close to normal as possible and later authors proposed one for kurtosis. By squaring these transformed numbers and adding them together, you end up with an omnibus statistic that is distributed as a \U1D6D8\U00B2 with an expected value of around 2 with 2 degrees of freedom. The results include skewness and kurtosis, their confidence intervals and significance tests, and the omnibus \U1D6D8\U00B2 and it's significance test. It has the same requirement as the skewness and kurtosis tests on which it is based, so it should only be used for samples larger than 20.")
       }
       
       sendSweetAlert(title = title,text = HTML(desc),html = TRUE,showCloseButton = TRUE,btn_labels = "Close",type = "info")
       updateCheckboxInput(inputId = "dist_test_info",value = FALSE)
     })
     
     output$disttestplotout<- renderPlot({dist_test_plot_out()})
     distestplotout_height<-reactive(400*4)
     distestplotout_width<-reactive(400*8)
     downloadServer('disttestplotout', dist_test_plot_out,height = distestplotout_height,width = distestplotout_width)

     
     dist_test_plot_out<-reactive({
       test<-input$dist_test_type_result
       #conf<-input$dist_test_conf
       #R<-input$dist_test_decimals
       data<-res_filter$filtered()
       data_type<-input$dist_test_data_type
       UI1<-as.numeric(input$dist_testUI1)#columns if data_type==1 factors if not
       UI2<-as.numeric(input$dist_testUI2)#NULL if data_type==1, data columns if not
       plot_type<-input$dist_test_plot_select
       req(test,data,UI1,R,data_type,plot_type)
       if(data_type==2){
         req(UI2)
       }
       
       #get data ready for ggplot
       if(data_type==1){#each UI1 column is to be a graph
         plot_data<-data.frame(transform.dependent.format.to.independent.format(data = data[UI1]))
         names(plot_data)<-c("ID","Data")
         plot_data$Data<-as.numeric(plot_data$Data)
       }
       else{#each combo of UI1 for each UI2 is to be a graph
         #all_combos<-unique(data[UI1])
         comboname<-paste0(names(data)[UI1],collapse = ", ")
         ID<-interaction(data[UI1], sep = ", ")
         plot_data<-cbind(ID,transform.dependent.format.to.independent.format(data[UI2]))
         names(plot_data)<-c("ID","var","Data")
       }
       
       #filter out NA
       plot_data<-na.omit(plot_data)
       
       #make graph
       output<-ggplot(data = plot_data, aes(x=Data))
       if(data_type==1){
         output<-output+facet_wrap2(~ID,scales="free",shrink = F)}
       else{
         output<-output+
           facet_wrap2(~ID+var,scales="free",shrink = F)+
           labs(subtitle = comboname)
       }
       
       if(test==1){#poisson, make histogram
         validate(need(expr = as.logical(prod(plot_data$Data==round(plot_data$Data))),message = "Data need to be counts to plot."))
         leg_names<-c("Theoretical"=color[4],"Empirical"=color[2])
         
         if(plot_type==1){
           output<-output + geom_histogram(aes(fill="Empirical"),binwidth = 1,color=color[1])+
             stat_theodensity(distri = "nbinom",geom="point",aes(y=after_stat(count),xend=after_stat(x),yend=0,color="Theoretical"))+#need xend and yend even though it throws a warning
             stat_theodensity(distri = "nbinom",geom="segment",aes(y=after_stat(count),xend=after_stat(x),yend=0),color=color[4],linetype="dashed")+
             ylab("Count")+
             ggtitle("Empirical and Theoretical Histograms")+
             scale_color_manual(values=leg_names)+
             scale_fill_manual(values=leg_names)+
             theme(legend.position = "bottom")+
             labs(color="",fill="")
         }
         else if(plot_type==2){
           leg_names<-c("Theoretical"=color[1],"Empirical"=color[2])
           output<-ggplot()+
             lapply (unique(plot_data$ID), function (i){
               xmin=min(plot_data$Data[plot_data$ID==i])
               xmax=max(plot_data$Data[plot_data$ID==i])
               xlambda=mean(plot_data$Data[plot_data$ID==i])
               geom_step(data=data.frame(ID=i,x=xmin:xmax,y=cumsum(dpois(x = xmin:xmax,lambda = xlambda))), aes(x=x,y=y,color= "Theoretical" ))
             }
             )+
             stat_ecdf(data = plot_data,aes(x=Data,color="Empirical"),geom="point")+
             ylab("CDF")+
             xlab("Data")+
             ggtitle("Empirical and Theoretical Cumulative Density")+
             scale_color_manual(values=leg_names)+
             theme(legend.position = "bottom")+
             labs(color="")
           
           if(data_type==1){
             output<-output+facet_wrap2(~ID,scales="free",shrink = F)}
           else{
             output<-output+
               facet_wrap2(~ID+var,scales="free",shrink = F)+
               labs(subtitle = comboname)
           }
         }
         
       }
       else if(test==9 || (test<6 && test>1)){#normal, make density plot
         if(plot_type==1){
           leg_names<-c("Theoretical"=color[4],"Empirical"=color[2])
           output<-output +
             geom_density(aes(fill="Empirical"),color=color[1],bw="sj",kernel="gaussian")+
             stat_theodensity(aes(color="Theoretical"),distri = "norm")+
             ylab("PDF")+
             ggtitle("Empirical and Theoretical Density Plots")+
             scale_color_manual(values=leg_names)+
             scale_fill_manual(values=leg_names)+
             theme(legend.position = "bottom")+
             labs(color="",fill="")+
             geom_rug(color=color[6],alpha=0.35)
         }
         else if(plot_type==2){#QQ
           output<-output +
             stat_qq(aes(sample=Data),inherit.aes = FALSE,color=color[2])+
             stat_qq_line(aes(sample=Data),inherit.aes = FALSE)+
             ggtitle("Q-Q Plot")+
             ylab("Empirical Quantiles")+
             xlab("Theoretical Quantiles")
         }
         else if(plot_type==3){#PP
           #Create data frame with P-P data
           pp_data<-mutate(plot_data,.by=ID,mean=mean(Data),sd=sd(Data),n=length(Data),p=pnorm(q = Data,mean = mean(Data),sd = sd(Data)))
           pp_data<-arrange(pp_data,ID,p)
           pp_data<-mutate(pp_data,.by = ID,row=row_number())
           pp_data<-mutate(pp_data,x=row/n - 0.5/n)
           
           output<-ggplot(data=pp_data,aes(x=x,y=p))+
             geom_point(color=color[2])+
             geom_abline(slope=1,intercept = 0)+
             xlab("Theoretical Cumulative p")+
             ylab("Empirical Cumulative p")+
             ggtitle("P-P Plot - Normal")+
             xlim(c(0,1))+
             ylim(c(0,1))
           
             if(data_type==1){
               output<-output+facet_wrap2(~ID,scales="free",shrink = F)}
             else{
               output<-output+
                 facet_wrap2(~ID+var,scales="free",shrink = F)+
                 labs(subtitle = comboname)
           }
         }
       }
         else if(test >5){#exponential, make exponential plot
           if(plot_type==1){
             leg_names<-c("Theoretical"=color[4],"Empirical"=color[2])
             output<-output +
               ylab("PDF")+
               geom_density(aes(fill="Empirical"),color=color[1])+
               lapply(unique(plot_data$ID), function(i) {
                 xmin <- min(plot_data$Data[plot_data$ID == i])
                 stat_theodensity(
                   data = ~ subset(.x, ID == i),
                   aes(color="Theoretical",x = stage(Data - xmin, after_stat = x + xmin)),
                   distri = "exp"
                   ,linewidth=1)
               })+
               ggtitle("Empirical and Theoretical Density Plots")+
               scale_color_manual(values=leg_names)+
               scale_fill_manual(values=leg_names)+
               theme(legend.position = "bottom")+
               labs(color="",fill="")+
               geom_rug(color=color[6],alpha=0.35)
           }
           else if(plot_type==2){
             output<-output +
               stat_qq(aes(sample=Data),distribution = qexp,inherit.aes = FALSE,color=color[2])+
               stat_qq_line(aes(sample=Data),distribution = qexp,inherit.aes = FALSE)+
               ggtitle("Q-Q Plot - Exponential")+
               ylab("Empirical Quantiles")+
               xlab("Theoretical Quantiles")
           }
           
           else if(plot_type==3){#PP
             #Create data frame with P-P data
             pp_data<-mutate(plot_data,.by=ID,mean=mean(Data),min=min(Data),n=length(Data),p=pexp(q = Data-min,rate = 1/(mean(Data)-min)))
             pp_data<-arrange(pp_data,ID,p)
             pp_data<-mutate(pp_data,.by = ID,row=row_number())
             pp_data<-mutate(pp_data,x=row/n - 0.5/n)
             
             output<-ggplot(data=pp_data,aes(x=x,y=p))+
               geom_point(color=color[2])+
               geom_abline(slope=1,intercept = 0)+
               xlab("Theoretical Cumulative p")+
               ylab("Empirical Cumulative p")+
               ggtitle("P-P Plot - Exponential with Xmin as Omicron")+
               xlim(c(0,1))+
               ylim(c(0,1))
             
             if(data_type==1){
               output<-output+facet_wrap2(~ID,scales="free",shrink = F)}
             else{
               output<-output+
                 facet_wrap2(~ID+var,scales="free",shrink = F)+
                 labs(subtitle = comboname)
             }
           }
           
         }
         
         #add labels
         output<-output+
           labs(caption="Graphs are only mildly informative. Make your decision using the appropriate test.")
         
         
         output
       })
     
     #UI element of the ANOVA data selection, used either for selecting columns or the factor
     output$ems_factors<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       
       output<-pickerInput(inputId = "factors_ems",
                           label = "Select Factors",
                           multiple=T,
                           choices = choices)
       
       output
       
     })
     
     #UI element of the ANOVA data selection used for selecting the data columns
     output$ems_data<-renderUI({
       req(res_filter$filtered())
       choices<-seq(1:ncol(res_filter$filtered()))
       names(choices)<-names(res_filter$filtered())
       UI1<-input$factors_ems
       req(UI1)
       #take out those already selected
       fact_selected<-as.numeric(unlist(strsplit (x = UI1,split = "\\s+")))
       temp<-seq(1:length(choices))
       temp<-temp[-fact_selected]
       choices<-choices[temp]
       
       output<-pickerInput(inputId = "data_ems",
                           label = "Select Data",
                           multiple=F,
                           choices = choices)
       
       
       output
       
     })
     
     #UI element to detect if the design is unbalanced and show a toggle for a fractional factorial
     output$ems_frac<-renderUI({
       
     })
     
     #function to make multiple radio buttons for fixed or random
     makeradioButton<-function(n){
       data<-res_filter$filtered()
       req(data)
       UI1<-as.numeric(input$factors_ems)
       req(UI1)
       if(length(UI1)<2)return("Need two or more factors or use Oneway ANOVA")
       factor_names<-names(data)[UI1]
       choices<-c("Fixed"="F","Random"="R")
       
       if(n==1){
         radioButtons(inputId = paste0("f_r_factor",n),label=factor_names[n],choices = choices,inline = TRUE)
       }else{
         radioButtons(inputId = paste0("f_r_factor",n),label=factor_names[n],choices = choices,inline = TRUE)
       }
     }
     WidgetVector<-reactive({
       data<-res_filter$filtered()
       req(data)
       UI1<-as.numeric(input$factors_ems)
       factor_names<-names(data)[UI1]
       factor_num<-length(factor_names)
       
       lapply(X=1:factor_num,FUN=makeradioButton)
     })
     
     output$ems_rand_select<-renderUI({
       tagList(WidgetVector())
     })
     
     #function to make multiple  buttons for nesting
     makenestButton<-function(n){
       data<-res_filter$filtered()
       req(data)
       UI1<-as.numeric(input$factors_ems)
       req(length(UI1>1))
       factor_names<-names(data)[UI1]
       if(length(UI1)<2)return()
       
       choices<-factor_names[-n]
       
       if(n==1){
         checkboxGroupInput(inputId = paste0("nest_factor",n),label=paste0(factor_names[n]," nested within"),choices = choices,selected = NA,inline = TRUE)#checkIcon = list(yes = icon("ok",lib = "glyphicon")))
       }else{
         checkboxGroupInput(inputId = paste0("nest_factor",n),label=paste0(factor_names[n]," nested within"),choices = choices,selected = NA,inline = TRUE)#checkIcon = list(yes = icon("ok",lib = "glyphicon")))
       }
     }
     WidgetVector_nest<-reactive({
       data<-res_filter$filtered()
       req(data)
       UI1<-as.numeric(input$factors_ems)
       req(length(UI1)>1)
       factor_names<-names(data)[UI1]
       factor_num<-length(factor_names)
       
       lapply(X=1:factor_num,FUN=makenestButton)
     })
     
     output$ems_nest_select<-renderUI({
       tagList(WidgetVector_nest())
     })
     
     balance_test<-function(factors_names=NULL){
       #test to see if unbalanced from EMSaov
       data<-res_filter$filtered()
       # factors_id<-as.numeric(input$factors_ems)
       # factors_names<-names(data)[factors_id]
       req(factors_names)
       
       EMSflag<-FALSE
       n.table<-NULL
       for(i in 1:length(factors_names)){
         temp<-table(data[,factors_names[i]])
         if(sum(temp!=mean(temp))!=0)
           EMSflag<-TRUE
         n.table<-c(n.table,length(temp))
       }
       return(EMSflag)
     }
     
     ######multiway ANOVA output
     aov_out<-reactive({ #match with ems_pooled<- this calculates the unpooled anova. It is used later in the pooled anova calculations
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       data_id<-as.numeric(input$data_ems)
       conf<-input$ems_conf
       R<-input$ems_dec
       show_ems<-input$ems_ems
       req(data,factors_id,data_id,conf,R)
       disp<-input$ems_disp#logical True is a dispersion test
       disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
       backup_opts<-options()
       options(contrasts=c("contr.sum","contr.poly"))
       
       type<-matrix("F",nrow=length(factors_id))
       rownames(type)<-factors_names
       
       nested=NULL
       if(input$ems_show_mixed_nest){
         req(input$f_r_factor1)
         for (i in 1:length(factors_id)){
           req(input[[paste0("f_r_factor",as.character(i))]])
           type[i]<-input[[paste0("f_r_factor",as.character(i))]]
           nest<-input[[paste0("nest_factor",as.character(i))]]
           if(is.null(nest)){
             nested[i]<-""
           }
           else{
             nested[i]<-nest
           }
         }
       }

       formula<-paste(names(data)[data_id],"~",paste(factors_names,collapse = "*"))
      
         # for(i in 2:length(factors_names)){
         #   formula<-paste(formula,"*",factors_names[i])
         # }
       count_per_cell <-data %>% group_by(across(all_of(factors_names))) %>% summarize(count=n())
       min_count<-min(count_per_cell$count)
       if(disp){#needs to bail if n in a cell = 1
         if(min_count<3){return()}#"Not enough samples within cell to calculate dispersion")}
         if(disp_type==1){
           data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
           colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
           formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADA"),formula)
         } else if(disp_type==2){
           data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
           colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
           formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADM"),formula)
         } else if(disp_type==3){
           data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
           colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
           formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADMn1"),formula)
         }
       }
       data[,factors_names]<-lapply(data[,factors_id],factor)
       #test to see if unbalanced
       EMSflag<-balance_test(factors_names = factors_names)
       
       if(!EMSflag){
         aov_out<-EMSanova_roi(formula = formula(formula),data = data,type = type,nested = nested,level = NULL,approximate = TRUE)
         
         aov_out<-transform(aov_out,Df=as.numeric(Df,SS=as.numeric(SS)),MS=as.numeric(MS),Fvalue=as.numeric(Fvalue))
         
         aov_out<-aov_out[order(rownames(aov_out)),]
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
       } else{#unbalanced due to different sample sizes or dummy levels
         #if mixed or random model, no way to calculate EMS
         if("R" %in% type){
           return("ROIstat can't calculate unbalanced mixed or random effects models")
         }
         unbal<-input$ems_ems#which approach "Unweighted"=1,"Orthogonal Design odd levels"=2,"Weighted"=3
         req(unbal)
         #nested needs to be added here, alarm until added
         if(length(unique(nested)) > 1){return("ROIstat can't calculate unbalanced nested models")}
         if(unbal==1){#unweighted approach
           #generate parts of unweighted ANOVA process
           agg<-do.call(data.frame,aggregate(formula(formula),data=data,FUN=function(x) c(n=length(x), sum=sum(x), mean=mean(x))))
           
           if(disp){
             d_type<-c("ADA","ADM","ADMn1")
             names(agg)[(ncol(agg)-2):ncol(agg)]<-c("n","sum",paste0(names(data)[data_id],"_",d_type[as.numeric(disp_type)]))
           } else{
             names(agg)[(ncol(agg)-2):ncol(agg)]<-c("n","sum",names(data)[data_id])
           }
           ssw<-sum(data[data_id]^2)-sum(agg$sum^2/agg$n)
           
           dfw<-sum(agg$n)-nrow(agg)
           
           msw<-ssw/dfw
           
           n_harm<-nrow(agg)/sum(1/agg$n)
           
           aet<-msw/n_harm
           #add factors
           #Should be missing F since there is no error term
           model<-lm(formula = formula(formula),data = agg)
           #since there is no error term, we will have to create a model with the aet and df
           # ###
           # 
           # # Design matrix from the model
           # X <- model.matrix(model)
           # 
           # # Calculate the standard errors with the new variance
           # # The diagonal elements of the inverse (X'X)
           # inv_XtX <- solve(t(X) %*% X)
           # 
           # # Standard errors for coefficients
           # new_se <- sqrt(aet * diag(inv_XtX))
           # 
           # # Extract and adjust coefficients
           # model_coef <- coef(summary(model))
           # new_coef_summary <- model_coef
           # new_coef_summary[, "Std. Error"] <- new_se
           # new_coef_summary[, "t value"] <- new_coef_summary[, "Estimate"] / new_coef_summary[, "Std. Error"]
           # new_coef_summary[, "Pr(>|t|)"] <- 2 * pt(-abs(new_coef_summary[, "t value"]), df = dfw)
           # 
           # # Create custom summary object
           # custom_summary <- summary(model)
           # custom_summary$coefficients <- new_coef_summary
           # custom_summary$sigma <- sqrt(aet)
           # custom_summary$df[which(custom_summary$df==0)]<-dfw
           # 
           # # Update model object
           # model$coefficients <- new_coef_summary[, "Estimate"]
           # #manufacture stand-in residuals
           # new_residuals<-rnorm(length(model$residuals))
           # scaling_factor<-sqrt(aet/var(new_residuals))
           # new_residuals<-new_residuals*scaling_factor
           # ################################
           # model$residuals <- new_residuals
           # model$fitted.values <- fitted(model)
           # model$df.residual <- dfw
           # model$sigma <- sqrt(aet)
           
           
           ###
           aov_model(lm(formula = formula(formula),data=data))#send weighted out for other functions
           temp<-suppressWarnings(anova(model))
           temp$`F value`<-temp$`Mean Sq`/aet
           temp$`Pr(>F)`<-pf(q = temp$`F value`,df1 = temp$Df,df2 = dfw,lower.tail = FALSE)
           temp['Residuals',]<-c(dfw,ssw,msw,NA,NA)
           temp<-data.frame(temp)
           names(temp)<-c("Df","SS","MS","Fvalue","Pvalue")
           aov_out<-temp
           aov_out<-aov_out[order(rownames(aov_out)),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
           #aov_out
         } else if(unbal==2){#odd-level factorial
           #since it is a factorial, let ems_pool do the work, need rownames of all factors though
           
           selected_effects <- setdiff(all_effects(),input$ems_pool)
           selected_effects <- sub(":","*",selected_effects)
           selected_effects <- paste(selected_effects,collapse= "+")
           new_formula <- paste(names(data)[data_id],"~",selected_effects)
           aov_out<-new_formula
           # temp<-lm(formula = noquote(new_formula), data = data) #case7 gets stuck here, will using just the unselected effects work?
           # temp2<-terms(temp)
           # temp2<-attr(temp2,"term.labels")
           # aov_out<-data.frame(rep(NA,length(temp2)))
           # rownames(aov_out)<-temp2
         } else {#use weighted analysis
           # backup_opts<-options()
           # options(contrasts=c("contr.sum","contr.poly"))

           aov_mod <-lm(formula = formula(formula),data = data)
           aov_model(aov_mod)#send it out for other functions
           aov_out<-as.data.frame(Anova(aov_mod,type=3))
           
           aov_out<-aov_out[order(rownames(aov_out)),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
           aov_out<-aov_out[!rownames(aov_out) %in% "(Intercept)",]
           aov_out$MS<-aov_out$`Sum Sq`/aov_out$Df
           names(aov_out)<-c("SS","Df","Fvalue","Pvalue","MS")
           #options(backup_opts)
         }
       }
       options(backup_opts)
       aov_out
       
       })###end reactive
     
     output$ems_ems_a<-renderUI({
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       req(data,factors_names)

       EMSflag<-balance_test(factors_names = factors_names)
       
       if(EMSflag){
         radioGroupButtons(inputId = "ems_ems",label = "Unbalanced design - select analysis",choices = c("Unweighted"=1,"Fractional Design odd levels"=2,"Weighted"=3),direction = "vertical",status = "danger",checkIcon = list(
           yes = icon("ok", 
                      lib = "glyphicon"),
           no = icon("remove",
                     lib = "glyphicon")))
         
       } else{
         checkboxInput(inputId = "ems_ems",label = "Show EMS",value = FALSE)
       }
     })
       
       ###begin html output
     
     output$ems_table<-renderUI({
       conf<-input$ems_conf
       R<-input$ems_dec
       show_ems<-input$ems_ems
       disp<-input$ems_disp
       
       req(conf,R)
       
       data<-res_filter$filtered()
       data_id<-as.numeric(input$data_ems)
       

       aov_out_l<-aov_out()
       
       #if any n=1 and doing a dispersion test, send an message
       if(is.null(aov_out_l)){return("Not enough samples within cell to calculate dispersion.")}
       
       req(aov_out_l)
       
       #calculate omega sq for fixed
       sst<-sum(na.omit(aov_out_l$SS))
       msw<-aov_out_l['Residual','MS']
       omega<-100*(aov_out_l$SS-(aov_out_l$Df*msw))/(sst+msw)
       
       #calculate ICC for random
       J<-rep(NA,nrow(aov_out_l)-1)
       sum_n<-rep(NA,nrow(aov_out_l)-1)
       sum_nsq<-rep(NA,nrow(aov_out_l)-1)
       msb<-head(aov_out_l$MS,-1)
       row_name<-rownames(aov_out_l)[-nrow(aov_out_l)]
       for(i in 1:(length(row_name))){
         combo<-c(str_split(row_name[i],":",simplify = TRUE))
         combo<-gsub("\\([^)]+\\)", "", x = combo)#fix for nested?
         J[i]<-nrow(unique(data[combo])) #this doesn't work with nested factors without previous step
         sum_n[i]<-sum((data %>% group_by_at(combo) %>% tally)$n)
         sum_nsq[i]<-sum(((data %>% group_by_at(combo) %>% tally)$n)^2)
       }
       K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
       bcv<-(msb-msw)/K_prime
       ICC<-c(100*bcv/(bcv+msw))
       
       #add column for ID'ing random or fixed effects
       aov_out_l$Type<-c(eff_types()$type,"R")
       
       #insert either omega squared or ICC depending on factor type
       aov_out_l$imp<-c(ifelse(eff_types()$type_code==1,omega,ICC),"")
       
       #finish up the importance column
       aov_out_l$imp[as.numeric(sub("<","",aov_out_l$Pvalue,fixed=TRUE))>=(1-conf)]<-0#get rid of insignificant effect importance
       aov_out_l$imp[aov_out_l$imp<0]<-0#get rid of negative numbers
       aov_out_l$imp<-paste0(as.character(ro(as.numeric(aov_out_l$imp,R))),"%")#add percent sign
       aov_out_l["Residuals","imp"]<-""#delete importance from residuals
       
       #calculate %RFC
       
     
       #Assign columns and rows for creating the output table (used to reorder and take out columns)
       out_row<-1:nrow(aov_out_l)
       
       #make source table
       #header
       #label if dispersion or means analysis
       if(disp){
         type<-as.numeric(input$ems_disp_type)#1=ADA, 2=ADM, 3=ADMn1
         type_name<-c("ADA","ADM","ADM<sub>(n-1)</sub>")
         
         output<-paste0("Dependent Variable: ",names(data)[data_id],"<br>Dispersion Analysis based on ",type_name[type])
       } else (
         output<-paste0("Dependent Variable: ",names(data)[data_id],"<br>Means Analysis")
       )
       
       if(!is.logical(show_ems)){#checking to see if it is unbalanced input, for which show_ems will be a number
         unbal<-show_ems
         if(unbal==1){
           approach<-"Unbalanced Design: Unweighted Analysis"
         } else if(unbal==2){
           approach<-"Unbalanced Design: Orthogonal design odd levels - Dummy column(s) subtracted from error term"
         } else{
           approach<-"Unbalanced Design: Weighted Analysis"
         }
         output<-paste0(output,"<br>",approach)
         out_col<-c("SS","Df","MS","Fvalue","Pvalue","Type","imp")
         output<-paste(output,"<table><tr><th><b>Source</b></th><th><b>SS</b></th><th><b>df</b></th><th><b>MS</b></th><th><b>F</b></th><th><b>p</b></th><th><b>Type(F/R)</b></th><th><b>",withMathJax("$$\\omega^2$$")," or ICC</b></th>")
         
       } else
       
       if(is.logical(show_ems) && show_ems){#include ems output
         #out_col<-c(2,1,3,4,5,8,7)
         out_col<-c("SS","Df","MS","Fvalue","Pvalue","Type","imp","EMS")
         output<-paste(output,"<table><tr><th><b>Source</b></th><th><b>SS</b></th><th><b>df</b></th><th><b>MS</b></th><th><b>F</b></th><th><b>p</b></th><th><b>Type(F/R)</b></th><th><b>",withMathJax("$$\\omega^2$$")," or ICC</b></th><th>EMS</b></th>")
       } else {
         #out_col<-c(2,1,3,4,5,8)
         out_col<-c("SS","Df","MS","Fvalue","Pvalue","Type","imp")
         output<-paste(output,"<table><tr><th><b>Source</b></th><th><b>SS</b></th><th><b>df</b></th><th><b>MS</b></th><th><b>F</b></th><th><b>p</b></th><th><b>Type(F/R)</b></th><th><b>",withMathJax("$$\\omega^2$$")," or ICC</b></th>")
       }
       #aov_out_l$Fvalue<-signif(aov_out_l$Fvalue,R)
       aov_out_r<-ro(aov_out_l,R)#rounded from this point on
       
       #make rows
       for(i in out_row){
         output<-paste(output,"<tr><td><b>",rownames(aov_out_r)[i],"</b></td>")
         for(j in out_col){
           if(rownames(aov_out_r)[i]=="Residuals" && (j=="Fvalue" || j=="Pvalue" || j=="imp")){
             output<-paste(output,"<td></td>")
             next(j)
           }
           if((j=="Pvalue" && aov_out_r[i,j]=="") ||(j=="Pvalue" && is.na(aov_out_r[i,j])) ){
             output<-paste(output,"<td></td>")
             next(j)
             }
           if((j=="Pvalue" && as.numeric(gsub(pattern = "<",replacement = "",x = aov_out_r[i,j]))<(1-conf)) ){#accounts for < sign in p-value
             output<-paste(output,"<td bgcolor='yellow'>",aov_out_r[i,j],"*</td>")
           }else{
             output<-paste(output,"<td>",aov_out_r[i,j],"</td>")
           }
         }
         output<-paste(output,
                       #"<td><div class ='checkbox'><label><input id = 'pool_",rownames(aov_out)[i],"' class = 'shiny-input-checkbox shiny-bound-input' type = 'checkbox'></label></div></td>",
                       "</tr>")
       }
       output<-HTML(paste(output,"</table>"))
       
       output
       
     })#end html output
     
     output$ems_primary<-renderUI({#are any sources of primary error?
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       dummy_names<-names(data)
       dummy_names<-dummy_names[!(dummy_names %in% factors_names)]
       data_name<-names(data)[as.numeric(input$data_ems)]
       dummy_names<-dummy_names[!(dummy_names %in% data_name)]
       
       pickerInput(inputId = "ems_primary_col",label = "Dummy Columns (e\U2081 Primary Error)",choices = dummy_names,multiple = TRUE)
       
     })
     
     all_effects <- function()({
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       data_id<-as.numeric(input$data_ems)
       mixed_nest<-input$ems_show_mixed_nest #is the UI for this shown? TRUE = yes
       req(data,factors_id,factors_names,data_id)
       if(length(input$factors_ems)<2){return()}
       
       # # ########generate list of effects, modified from EMSaov
       formula<-paste(names(data)[data_id],"~",factors_names[1])
       
       for(i in 2:length(factors_names)){
         formula<-paste(formula,"*",factors_names[i])
       }
       type<-matrix("F",nrow=length(factors_id))
       rownames(type)<-factors_names
       
       nested=NULL
       level=NULL
       if(mixed_nest){
                req(input$f_r_factor1)
       for (i in 1:length(factors_id)){
         req(input[[paste0("f_r_factor",as.character(i))]])
         type[i]<-input[[paste0("f_r_factor",as.character(i))]]
         nest<-input[[paste0("nest_factor",as.character(i))]]
         if(is.null(nest)){
           nested[i]<-""
         }
         else{
           nested[i]<-nest
         }
       }
       }
       
       formula.t <- as.character(formula(formula))
       Y.name <- formula.t[2]
       data.n <- strsplit(formula.t[3], " \\+ ")[[1]]
       if (data.n[1] == ".") {
         var.list <- colnames(data)[colnames(data) != Y.name]
       }
       else {
         temp1 <- unlist(sapply(data.n, strsplit, " "))
         var.list <- unique(temp1[temp1 != " " & temp1 != "*" &
                                    temp1 != ""])
       }
       if (!is.null(level)) {
         sort.id <- sort.list(level)
         nested <- nested[sort.id]
         level <- level[sort.id]
         var.list <- var.list[sort.id]
       }
       if (!is.null(nested) & ifelse(length(nested) != 0, sum(!is.na(nested)),
                                     0) != 0) {
         nested <- lapply(nested, function(x) {
           xx <- strsplit(x, split = "\\*")[[1]]
           temp <- NULL
           for (i in 1:length(xx)) temp <- c(temp, which(var.list ==
                                                           xx[i]))
           if (length(temp) == 0) {
             return(NA)
           }
           else {
             return(temp)
           }
         })
       }
       else {
         nested <- as.list(rep(NA, length(var.list)))
       }
       
       data <- data[, c(var.list, Y.name)]
       for (i in var.list) {
         data[, i] <- factor(data[, i])
       }
       n <- length(var.list)
       design.M1 <- NULL
       for (i in 1:n) {
         design.M1 <- rbind(design.M1, design.M1)
         temp1 <- rep(c("", var.list[i]), each = 2^(i - 1))
         design.M1 <- cbind(design.M1, temp1)
       }
       design.M1 <- design.M1[-1, , drop = FALSE]
       model.F <- paste(Y.name, "~", paste(apply(design.M1, 1,
                                                 function(x) paste(paste(x[x != ""], collapse = "*"))),
                                           collapse = "+"))
       model.id <- c(apply(design.M1, 1, function(x) paste(paste(x[x !=
                                                                     ""], collapse = ":"))))
       
       model.id<-str_sort(model.id)
       model.id<-model.id[order(str_count(model.id,":"))]
       
       model.id
       
       #########
     })
     
     output$ems_pool<-renderUI({#creates buttons for pooling
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       data_id<-as.numeric(input$data_ems)
       
       req(data,factors_id,factors_names,data_id)
       if(length(input$factors_ems)<2){return()}

       choices <- all_effects()
         
       pickerInput(inputId = "ems_pool",
                   label = "Pool / Exclude from model",
                   choices = list("Selected effects will be excluded from the model"=choices), #model.id,#rownames(head(aov_l,-1)),#row.names(head(aov_out(),-1)),
                   multiple = TRUE,
                   options=list("actions-Box"=TRUE,
                                "title"="Select effects to exclude",
                                "tick-icon"="glyphicon glyphicon-remove"))
       
     })
     
     ####These functions will allow us to make comments as we process something and return those comments later
     # Define the Commentary class
     Commentary <- function() {
       list(text = character())
     }
     
     # Function to add text to the commentary
     add_comment <- function(commentary, new_text) {
       commentary$text <- c(commentary$text, new_text)
       commentary
     }
     
     # Function to report the full commentary
     report_commentary <- function(commentary) {
       paste0(commentary$text, collapse = "\n")
     }
     
     anova_note <- reactiveVal(Commentary())#Initialize here to be available for functions
     
     #This function will re-order interaction terms so that they can be combined or merged
     standardize_interaction <- function(factor) {
       # Split by colon (:) if it's an interaction term
       terms <- unlist(strsplit(factor, ":"))
       # Sort the terms alphabetically and join them with colon
       standardized <- paste(sort(terms), collapse = ":")
       return(standardized)
     }
     
     #########################################################################################################
     
     #Pooled model - needs to be separate from aov_out()
     
     ems_pooled<-reactive({#Match with aov_out<-reactive
       pool_vars<-input$ems_pool
       data<-res_filter$filtered()
       factors_id<-as.numeric(input$factors_ems)
       factors_names<-names(data)[factors_id]
       conf<-input$ems_conf
       backup_opts<-options()
       options(contrasts=c("contr.sum","contr.poly"))
       #check if unbalanced first
       EMSflag<-balance_test(factors_names = factors_names)
       anova_note(NULL)
       #check n per run = 1
       count_per_cell <-data %>% group_by(across(all_of(factors_names))) %>% summarize(count=n())
       min_count<-min(count_per_cell$count)
       if(EMSflag){#the model is unbalanced
         unbal<-input$ems_ems#which approach "Unweighted"=1,"Orthogonal Design odd levels"=2,"Weighted"=3
         req(unbal)
         
         data_id<-as.numeric(input$data_ems)
         disp<-input$ems_disp#logical True is a dispersion test
         disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
         data[,factors_names]<-lapply(data[,factors_id],factor)

         # for unbalanced, aov_out() passes in the formula for the selected model
         formula <- aov_out() # formula is just the selected effects
         #return if being sent an error message
         ########################################################################
         
         formula2<-paste(names(data)[data_id],"~",paste(factors_names,collapse = "*"))#formula2 is all interactions, needed to get unique SS (?)
         
         if(disp){
           #if count per cell is 1 then no dispersion analysis
           if(min_count<3){return(NULL)}#"Not enough samples within cell to calculate dispersion.")}
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADA"),formula)
             formula2<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADA"),formula2)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADM"),formula)
             formula2<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADM"),formula2)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADMn1"),formula)
             formula2<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADMn1"),formula2)
           }
         }
         if(unbal==1){#unweighted means
           #generate parts of unweighted ANOVA process
           agg<-do.call(data.frame,aggregate(formula(formula),data=data,FUN=function(x) c(n=length(x), sum=sum(x), mean=mean(x))))
           
           if(disp){
             d_type<-c("ADA","ADM","ADMn1")
             names(agg)[(ncol(agg)-2):ncol(agg)]<-c("n","sum",paste0(names(data)[data_id],"_",d_type[as.numeric(disp_type)]))
           } else{
             names(agg)[(ncol(agg)-2):ncol(agg)]<-c("n","sum",names(data)[data_id])
           }
           ssw<-sum(data[data_id]^2)-sum(agg$sum^2/agg$n)
           
           dfw<-sum(agg$n)-nrow(agg)
           
           msw<-ssw/dfw
           
           n_harm<-nrow(agg)/sum(1/agg$n)
           
           aet<-msw/n_harm
           
           #Should be missing F since there is no error term
           temp<-lm(formula = formula(formula),data = agg)
           aov_model(temp)#send it out for other functions
           temp<-suppressWarnings(anova)#here should this be Anova type 3?
           temp$`F value`<-temp$`Mean Sq`/aet
           temp$`Pr(>F)`<-pf(q = temp$`F value`,df1 = temp$Df,df2 = dfw,lower.tail = FALSE)
           temp['Residuals',]<-c(dfw,ssw,msw,NA,NA)
           temp<-data.frame(temp)
           names(temp)<-c("Df","SS","MS","Fvalue","Pvalue")
           aov_out<-temp
           aov_out<-aov_out[order(rownames(aov_out)),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
         } else
         if(unbal==2){#unbalanced due to orthogonal array re-coding odd number of levels
           #we know there is at least one dummy level since that is how we got to this branch
           #since balanced designs are handled by EMSaov below
           #case 4, 7, 6 should go through here
           # backup_opts<-options()
           # options(contrasts=c("contr.sum","contr.poly"))
           
           anova_note(isolate(add_comment(anova_note(),"Unbalanced design due to dummy level(s)")))
            
           #generate potentially incorrect anova
           lm_effects <- lm(formula=formula(formula),data=data) 
           aov_lm_effects<-suppressWarnings(Anova(lm_effects,type = 3,singular.ok = TRUE))#suppressWarnings(anova(lm_effects))
           aov_model(lm_effects)#send it out for other functions
           aov_lm_effects$'Mean Sq'<-aov_lm_effects$`Sum Sq`/aov_lm_effects$Df#add in MS column
           e_tot <- aov_lm_effects['Residuals',]#the residuals from aov_lm_effects is e2(replicates) + e1(due to dummy levels)
           
           # get AET using AET chart from DOE Wk4 p.3-7
           # if you have dummy columns, create a model with them in as factors
           # later logic will either add them to the AET or not
           dummy_col_names<-input$ems_primary_col
           dummy_col <- FALSE
           if(isTruthy(dummy_col_names)){
             dummy_col <- TRUE
             formula_w_dummy_col <- paste(formula,"+",paste(dummy_col_names,collapse = "+"))
             lm_w_dummy_col <- lm(formula=formula(formula_w_dummy_col),data=data)
             aov_lm_w_dummy_col <- suppressWarnings(Anova(lm_w_dummy_col,type=3,singular.ok=TRUE))#suppressWarnings(anova(lm_w_dummy_col))
             aov_lm_w_dummy_col$'Mean Sq'<-aov_lm_w_dummy_col$'Sum Sq'/aov_lm_w_dummy_col$Df#add in MS column
           }
            # is it unreplicated?
           agg<-do.call(data.frame,aggregate(formula(formula),data=data,FUN=function(x) c(n=length(x), sum=sum(x), mean=mean(x))))
           names(agg)[seq(from=ncol(agg)-2,to=ncol(agg))] <- c("n","sum","mean")
           if(mean(agg$n)==1){#unreplicated with at least one dummy level
             #is there dummy col? 
             if(dummy_col){#dummy level and dummy column unreplicated
               #add dummy column(s) to dummy level this is example 8 original
               e1<-aov_lm_w_dummy_col['Residuals',]#this is dummy level e1 since it is unreplicated
               dum_SS <- sum(aov_lm_w_dummy_col[dummy_col_names,]$`Sum Sq`)#dummy column
               dum_df <- sum(aov_lm_w_dummy_col[dummy_col_names,]$Df)#dummy column
               e1$`Sum Sq` <- e1$`Sum Sq` + dum_SS
               e1$Df <- e1$Df + dum_df
               e1$`Mean Sq`<-e1$`Sum Sq`/e1$Df
               aov_lm_effects['Residuals',]<-e1#combined dummy level and dummy column e1
               aov_lm_effects$`F value`<-aov_lm_effects$`Mean Sq`/aov_lm_effects['Residuals',]$`Mean Sq`#recalculate F
               aov_lm_effects$`Pr(>F)`<-pf(q = aov_lm_effects$`F value`,df1 = aov_lm_effects$Df,df2 = aov_lm_effects['Residuals',]$Df,lower.tail = FALSE )#recalculate p(F)
               aov_lm_effects <-aov_lm_effects[c(1,2,5,3,4)]#aov_lm_effects <-aov_lm_effects[c(2,1,4,5,3)]
               anova_note(isolate(add_comment(anova_note(),", unreplicated, using dummy column(s) and dummy level(s) as error term")))
               
             } else {#no dummy column, at least one dummy level, unreplicated
               #case 6
               #dummy level goes to AET
               #This should be the original anova
               anova_note(isolate(add_comment(anova_note(),", unreplicated, dummy level(s) added to error term")))
               
               aov_lm_effects <-aov_lm_effects[c(1,2,5,3,4)]#aov_lm_effects <-aov_lm_effects[c(2,1,4,5,3)]#need to calculate unique ss?
             }
             
             
           } else{#replicated with at least a dummy level, case 4 and 7 go through here
             # get unique SS from regression
             data_no_factor<-res_filter$filtered() #use data without factors - what will happen with text levels?
             if(disp){
               data_no_factor<-cbind(data_no_factor,data[ncol(data)])
               names(data_no_factor)[ncol(data_no_factor)]<-names(data)[ncol(data)]
             }
             unique.out<-suppressWarnings(lm(formula = noquote(formula2), data = data_no_factor,singular.ok = TRUE))#unique residual SS from the regression, unique is e2
             #error.term<-suppressWarnings(Anova(unique.out,type = 3,singular.ok = TRUE))#suppressWarnings(anova(unique.out))
             e2<-anova(unique.out)["Residuals",] # error term from unique ss a.k.a. e2
             e2$'Mean Sq' <- e2$`Sum Sq`/e2$Df
             e2<-e2[c(2,1,4,5,3)]
             #e2<-e2[,c(2,1,4,3)] #reorder to have subtraction work
             #is there e1? there is at least a dummy level otherwise we would not be here - get that now
             if (dummy_col){
               #use residual from model with dummy columns
               e1<-aov_lm_w_dummy_col['Residuals',]-e2#this is e1 due to dummy levels, need to add dummy columns - proper MS will be calculated below
               #add dummy col SS and df to e1
               dum_SS <- sum(aov_lm_w_dummy_col[dummy_col_names,]$`Sum Sq`)
               dum_df <- sum(aov_lm_w_dummy_col[dummy_col_names,]$Df)
               e1$`Sum Sq` <- e1$`Sum Sq` + dum_SS
               e1$Df <- e1$Df + dum_df
             } else{#no dummy columns
               e1 <- e_tot - e2 #this e1 is only e1 due to dummy levels - MS will be corrected below
             }
             #e1$MS <- e1$`Sum Sq`/e1$Df
             e1$`Mean Sq`<-e1$`Sum Sq`/e1$Df
             #test significance of MS primary and MS secondary error with F
             F_prime_sec <- e1$`Mean Sq`/e2$`Mean Sq`
             p_F_prime_sec <- pf(q = F_prime_sec,df1 = e1$Df,df2 = e2$Df,lower.tail = FALSE)
             if(p_F_prime_sec <= (1-conf)){#e1 is significant, use e1 as AET
               aov_lm_effects["Residuals",]<- e1
               aov_lm_effects$`F value`<-aov_lm_effects$`Mean Sq`/e1$`Mean Sq` # new F
               aov_lm_effects$`Pr(>F)` <- pf(q = aov_lm_effects$`F value`,df1 = aov_lm_effects$Df,df2 = e1$Df,lower.tail = FALSE) #new p-values
               anova_note(isolate(add_comment(anova_note(),", used e<sub>1</sub> for error term since MSe<sub>1</sub>/MSe<sub>2</sub> was significant, examine alias table for potential confounded factors in unassigned columns")))
               
               aov_lm_effects <-aov_lm_effects[c(1,2,5,3,4)]
               if(e1$Df==1){#significant - is df of primary error 1? if yes, user will need to pool, send message
                 anova_note(isolate(add_comment(anova_note(),", e<sub>1</sub> had 1df so you are allowed to pool insignificant main or interactive effects")))
                 #anova_note()
               }
               #no - use primary error as AET no additional note necessary
             } else{#not significant, pool primary and secondary error and use as AET
               anova_note(isolate(add_comment(anova_note(),", e<sub>1</sub> and e<sub>2</sub> not significantly different, pooled e<sub>1</sub> and e<sub>2</sub>")))
               #anova_note()
               #the original model pooled dummy columns into the error term but didn't include dummy levels
               #so we need to use the new AET and df 
               if (dummy_col){ #use the model with the dummy columns pulled out if present
                 aov_lm_effects <- aov_lm_w_dummy_col[-match(dummy_col_names,rownames(aov_lm_w_dummy_col)),]#this might not be necessary since we have the original model w/out dummy columns
               }
               aov_lm_effects <- aov_lm_effects[-which(rownames(aov_lm_effects)=="Residuals"),]
               aov_lm_effects['Residuals',]<-c(e1$`Sum Sq`+e2$`Sum Sq`,e1$Df+e2$Df,NA,NA,(e1$`Sum Sq`+e2$`Sum Sq`)/(e1$Df+e2$Df))#c(e1$Df+e2$Df,e1$`Sum Sq`+e2$`Sum Sq`,NA,NA,(e1$`Sum Sq`+e2$`Sum Sq`)/(e1$Df+e2$Df))
               aov_lm_effects['Residuals',]$`Mean Sq`<- aov_lm_effects['Residuals',]$`Sum Sq`/aov_lm_effects['Residuals',]$Df
               aov_lm_effects$`F value`<-aov_lm_effects$`Mean Sq`/aov_lm_effects['Residuals',]$`Mean Sq`
               aov_lm_effects$`Pr(>F)`<-pf(q = aov_lm_effects$`F value`,df1 = aov_lm_effects$Df,df2 = aov_lm_effects["Residuals",]$Df,lower.tail = FALSE)
               aov_lm_effects <-aov_lm_effects[c(1,2,5,3,4)]
             }      
           }

           #Prepare anova for passing out of function
           #sort anova - check for error undefined columns selected
           aov_out<-as.data.frame(aov_lm_effects)
           aov_out<-aov_out[order(rownames(aov_out)),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort based on interaction length
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Within Cells")),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]

           
           #options(backup_opts)
           names(aov_out)<-c("SS","Df","MS","Fvalue","Pvalue")
           aov_out
         }#end unbal==2
         else if(unbal==3){#weighted means
           # backup_opts<-options()
           # options(contrasts=c("contr.sum","contr.poly"))

           aov_mod<-lm(formula = formula(formula),data = data)
           aov_model(aov_mod)#send it out for other functions
           aov_out<-as.data.frame(Anova(aov_mod,type=3))
           
           aov_out<-aov_out[order(rownames(aov_out)),]
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
           aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
           aov_out<-aov_out[!rownames(aov_out) %in% "(Intercept)",]
           aov_out$MS<-aov_out$`Sum Sq`/aov_out$Df
           names(aov_out)<-c("SS","Df","Fvalue","Pvalue","MS")
           #options(backup_opts)
         }
         
       }else{#not unbalanced, might have dummy columns but will not have dummy levels - check logic here
         anova_note(isolate(add_comment(anova_note(),"Balanced design")))
         #If a dispersion test and not enough data per cell
         if(input$ems_disp && min_count<2){return()}
         aov_out<-aov_out()#this is the model with all the effects, but not including dummy columns
         req(aov_out)
         #test to see if all pooled variables are present in anova
       req(pool_vars)
       # only balanced models make it here, so no dummy levels. Might have a dummy column though.
       #first, find any variables selected for pooling that are not in aov_out() since that will break PooledANOVA - note this does not include dummy columns

       if(any(!(pool_vars %in%  row.names(aov_out())[-which(row.names(aov_out())=="Residuals")])) ){ #in the case that one of the created effects in the UI selected to pool is not in aov_out() for example there is no interaction effect data in a blocked design, return the non-pooled anova
         #subtract missing pool vars from pool_vars
         anova_note(isolate(add_comment(anova_note(),", the following effects selected to pool were not in the initial ANOVA and will be removed from the pooling list:<br>")))
         anova_note(isolate(add_comment(anova_note(),pool_vars[!(pool_vars %in%  row.names(aov_out())[-which(row.names(aov_out())=="Residuals")])] )))
         anova_note(isolate(add_comment(anova_note(),"<br>")))
         pool_vars<-pool_vars[(pool_vars %in% row.names(aov_out()))]
         if (length(pool_vars)==0){#took out all pooling vars
           anova_note(isolate(add_comment(anova_note(),"<br>All pooling variables removed")))
           aov_out<-aov_out()
         }
       }
       
       #Next, check to see if pooledANOVA returns errors in SS (not in the residuals since there will be pooling)
       if(length(pool_vars)==0){
         test_pool<-aov_out
       } else{
         test_pool<-PooledANOVA_roi(SS.table = aov_out(),del.ID = c(pool_vars,"Residuals"))
         test_pool<-transform(test_pool,Df=as.numeric(Df,SS=as.numeric(SS)),MS=as.numeric(MS),Fvalue=as.numeric(Fvalue),Pvalue=as.numeric(Pvalue))
         #test_pool<-test_pool[order(rownames(test_pool)),]
       }
       if( any(is.na(test_pool[-nrow(test_pool),]$SS==TRUE)) ){#Pooled has returned NAs somewhere not in residuals, use lm to get reduced model
         anova_note(isolate(add_comment(anova_note(),", ANOVA based on reduced model")))
         data<-res_filter$filtered()
         factors_id<-as.numeric(input$factors_ems)
         factors_names<-names(data)[factors_id]
         data_id<-as.numeric(input$data_ems)
         disp<-input$ems_disp#logical True is a dispersion test
         disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
         data[,factors_names]<-lapply(data[,factors_id],factor)
         
         
         temp<-unlist(strsplit(row.names(aov_out)," "))
         temp<-temp[!temp %in% pool_vars]
         temp<-temp[!temp %in% "Residuals"]
         formula<-paste(temp,collapse=" + ")
         formula<-gsub(pattern = ":",replacement = "*",x = formula)
         formula<-paste0(names(data)[data_id]," ~ ",formula)
         
         if(disp){
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADA"),formula)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADM"),formula)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
             formula<-sub(names(data)[data_id],paste0(names(data)[data_id],"_ADMn1"),formula)
           }
         }

         # backup_opts<-options()
         # options(contrasts=c("contr.sum","contr.poly"))
         aov_mod<-lm(formula = formula(formula),data = data)
         aov_model(aov_mod)#send it out for other functions
         #divert from Anova if unreplicated
         if(all(count_per_cell$count==1)){#if unreplicated use 
           aov_out<-suppressWarnings( anova(aov_mod) )
           aov_out<-as.data.frame(aov_out)
           aov_out<-aov_out[-3]
           aov_out<-aov_out[c(2,1,3,4)]
         } else{#if at least a few replicates, use Anova
           aov_out<-suppressWarnings( Anova(aov_mod,type=3,singular.ok=TRUE) )
         }
         
         aov_out$Factor <- rownames(aov_out)#create a factor column
         test_pool$Factor <- rownames(test_pool)#create a factor column
         rownames(aov_out) <- NULL
         rownames(test_pool) <- NULL
         # Ensure 'Factor' is the same format as 'Df' in test_pool
         aov_out$Factor <- gsub("\\s+", "", aov_out$Factor)
         # Apply standardization to interaction terms in both data frames
         aov_out$Factor <- sapply(aov_out$Factor, standardize_interaction)
         test_pool$Factor <- sapply(test_pool$Factor, standardize_interaction)
         # Handle missing interaction terms by adding placeholders
         missing_interactions <- setdiff(aov_out$Factor, test_pool$Factor)
         for (interaction in missing_interactions) {
           test_pool <- rbind(test_pool, data.frame(Df=NA, SS = NA, MS = NA, Fvalue = NA, Pvalue = NA, Sig = NA, EMS = NA,Factor = interaction))
         }
         test_pool_test<-data.frame(EMS=test_pool$EMS,Factor=test_pool$Factor)
         # Merge aov_out_df with test_pool based on matching row names
         aov_out <- aov_out %>%
           left_join(test_pool_test, by = c("Factor" = "Factor"))
         
         #aov_out<-merge(x = aov_out,y = subset(x = aov_out(),select = "EMS"),by = 0,all.x = TRUE)
         rownames(aov_out)<-aov_out$Factor
         aov_out[,'Factor']<-NULL
         #aov_out<-subset(aov_out,select=-Row.names)
         aov_out$MS <- aov_out$`Sum Sq`/aov_out$Df
         names(aov_out)<-c("SS","Df","Fvalue","Pvalue","EMS","MS")
         aov_out<-aov_out[order(rownames(aov_out)),]
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
         #options(backup_opts)
         #aov_out
           
       } else{#EMSaov has not returned NAs, use PooledANOVA
         if(length(pool_vars)==0){#no pooled variables showed up in the anova so don't pool them
           aov_out<-aov_out
         } else {
           aov_out<-test_pool#PooledANOVA_roi(SS.table = aov_out(),del.ID = c(pool_vars,"Residuals"))
           #aov_out<-transform(aov_out,Df=as.numeric(Df,SS=as.numeric(SS)),MS=as.numeric(MS),Fvalue=as.numeric(Fvalue))
           
           aov_out<-aov_out[order(rownames(aov_out)),]
         }
         
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),":"),str_count(string = row.names(aov_out),":")),]#re-sort
         aov_out<-aov_out[order(str_count(string = row.names(aov_out),pattern = "Residuals")),]
       }
       
       # It is possible that there is a dummy column. No dummy levels make it here.
       if(isTruthy(input$ems_primary_col)){
         formula=paste(names(data)[as.numeric(input$data_ems)],"~",paste(row.names(aov_out)[-which(row.names(aov_out)=="Residuals" | row.names(aov_out)=="(Intercept)")],collapse = "+"))
         agg<-do.call(data.frame,aggregate(formula(formula),data=data,FUN=function(x) c(n=length(x), sum=sum(x), mean=mean(x))))
       names(agg)[seq(from=ncol(agg)-2,to=ncol(agg))] <- c("n","sum","mean")
       if(mean(agg$n)==1){#unreplicated
         if(isTruthy(aov_out[nrow(aov_out),]$SS)){
           anova_note(isolate(add_comment(anova_note(),", unreplicated, dummy column(s) added to error term")))
         }
       } else if(isTruthy(input$ems_primary_col)){#replicated with dummy column, no dummy levels, need e1 and e2 to test for significance
         dummy_col_names<-input$ems_primary_col
         anova_note(isolate(add_comment(anova_note(),"replicated, with dummy columns")))
           #dummy_col <- TRUE
           formula_w_dummy_col <- paste(formula,"+",paste(dummy_col_names,collapse = "+"))
           lm_w_dummy_col <- lm(formula=formula(formula_w_dummy_col),data=data)
           aov_lm_w_dummy_col <- suppressWarnings(Anova(lm_w_dummy_col,type=3,singular.ok=TRUE))#suppressWarnings(anova(lm_w_dummy_col))
           aov_lm_w_dummy_col$'Mean Sq'<-aov_lm_w_dummy_col$'Sum Sq'/aov_lm_w_dummy_col$Df#add in MS column
           e2<-aov_lm_w_dummy_col['Residuals',]
           #since there can be no dummy level here, e1 is dummy column error e2 is residual
           dum_SS <- sum(aov_lm_w_dummy_col[dummy_col_names,]$`Sum Sq`)
           dum_df <- sum(aov_lm_w_dummy_col[dummy_col_names,]$Df)
           e1<-data.frame('Sum Sq' = dum_SS, Df = dum_df,check.names = FALSE)
           e1$`Mean Sq`<-e1$`Sum Sq`/e1$Df
         
         #test significance of MS primary and MS secondary error with F
         F_prime_sec <- e1$`Mean Sq`/e2$`Mean Sq`
         p_F_prime_sec <- pf(q = F_prime_sec,df1 = e1$Df,df2 = e2$Df,lower.tail = FALSE)
         if(p_F_prime_sec <= (1-conf)){#e1 is significant, use e1 as AET
           aov_out["Residuals",]$SS<-e1$`Sum Sq`
           aov_out["Residuals",]$Df<-e1$Df
           aov_out["Residuals",]$MS<-e1$`Mean Sq`
           #aov_out["Residuals",c(1,2,3)]<- e1[c(2,1,3)]
           aov_out$Fvalue<-aov_out$MS/aov_out['Residuals',]$MS # new F
           aov_out$Pvalue <- pf(q = aov_out$Fvalue,df1 = aov_out$Df,df2 = aov_out['Residuals',]$Df,lower.tail = FALSE) #new p-values
           anova_note(isolate(add_comment(anova_note(),", used e<sub>1</sub> for error term since MSe<sub>1</sub>/MSe<sub>2</sub> was significant, examine alias table for potential confounded factors in unassigned columns")))
           
           #aov_lm_effects <-aov_lm_effects[c(1,2,5,3,4)]
           if(e1$Df==1){#significant - is df of primary error 1? if yes, user will need to pool, send message
             anova_note(isolate(add_comment(anova_note(),", e<sub>1</sub> had 1df so you are allowed to pool insignificant main or interactive effects")))
             #anova_note()
           }
           #no - use primary error as AET no additional note necessary
         } else{#not significant, pool primary and secondary error and use as AET not correct yet!!!
           anova_note(isolate(add_comment(anova_note(),", e<sub>1</sub> and e<sub>2</sub> not significantly different, pooled e<sub>1</sub> and e<sub>2</sub>")))
           aov_out <- aov_lm_w_dummy_col[-which(rownames(aov_out)=="Residuals"),]
           aov_out['Residuals',]<-c(e1$`Sum Sq`+e2$`Sum Sq`,e1$Df+e2$Df,NA,NA,NA,(e1$`Sum Sq`+e2$`Sum Sq`)/(e1$Df+e2$Df))#c(e1$Df+e2$Df,e1$`Sum Sq`+e2$`Sum Sq`,NA,NA,(e1$`Sum Sq`+e2$`Sum Sq`)/(e1$Df+e2$Df))
           #aov_out['Residuals',]$`Mean Sq`<- aov_out['Residuals',]$`Sum Sq`/aov_out['Residuals',]$Df
           aov_out$Fvalue<-aov_out$MS/aov_out['Residuals',]$MS
           aov_out$Pvalue<-pf(q = aov_out$Fvalue,df1 = aov_out$Df,df2 = aov_out["Residuals",]$Df,lower.tail = FALSE)
           aov_out <-aov_out[c(1,2,6,3,4,5)]
         }      
       #}
       }
       }#end handling dummy column

       options(backup_opts)
         aov_out
       #}
       }#end not unbalanced
       aov_out
     })
       
       output$ems_table_pooled<-renderUI({#html output of pooled anova
         pool_vars<-input$ems_pool
         disp<-input$ems_disp
         req(pool_vars)
         conf<-input$ems_conf
         R<-input$ems_dec
         show_ems<-input$ems_ems
         aov_out_l<-ems_pooled()
         #if any n=1 and doing a dispersion test, send an message
         if(is.null(aov_out_l)){return(HTML("Not enough samples within cell to calculate dispersion."))}
         req(aov_out_l)
         data<-res_filter$filtered()
         data_id<-as.numeric(input$data_ems)
         #for models that come back with an intercept, take that row out
         if("(Intercept)" %in% rownames(aov_out_l)){
           aov_out_l<-aov_out_l[-which(rownames(aov_out_l)=="(Intercept)"),]
         }
         
         #calculate omega sq for fixed
       sst<-sum(na.omit(aov_out_l$SS))
       msw<-aov_out_l[nrow(aov_out_l),'MS']
       omega<-100*(aov_out_l$SS-(aov_out_l$Df*msw))/(sst+msw)
       
       #calculate ICC for random
       J<-rep(NA,nrow(aov_out_l)-1)
       sum_n<-rep(NA,nrow(aov_out_l)-1)
       sum_nsq<-rep(NA,nrow(aov_out_l)-1)
       msb<-head(aov_out_l$MS,-1)
       row_name<-rownames(aov_out_l)[-nrow(aov_out_l)]
       for(i in 1:(length(row_name))){
         combo<-c(str_split(row_name[i],":",simplify = TRUE))
         combo<-gsub("\\([^)]+\\)", "", x = combo)#fix for nested?
         test<-try(nrow(unique(data[combo])))
         if(class(test) == "try-error"){
           J[i]<-0
           sum_n[i]<-0
           sum_nsq[i]<-0
           next(i)
           }
         J[i]<-nrow(unique(data[combo]))
         sum_n[i]<-sum((data %>% group_by_at(combo) %>% tally)$n)
         sum_nsq[i]<-sum(((data %>% group_by_at(combo) %>% tally)$n)^2)
       }
       K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
       bcv<-(msb-msw)/K_prime
       ICC<-c(100*bcv/(bcv+msw))
       
       #add column for ID'ing random or fixed effects
       aov_out_l$Type<-c(eff_types()$type,"R")
       
       #insert either omega squared or ICC depending on factor type
       aov_out_l$imp<-c(ifelse(eff_types()$type_code==1,omega,ICC),"")
       
       #finish up the importance column
       aov_out_l$imp[as.numeric(sub("<","",aov_out_l$Pvalue,fixed=TRUE))>=(1-conf)]<-0#get rid of insignificant effect importance
       aov_out_l$imp[aov_out_l$imp<0]<-0#get rid of negative numbers
       aov_out_l$imp<-paste0(as.character(ro(as.numeric(aov_out_l$imp,R))),"%")#add percent sign
       if( !is.logical(input$ems_ems) && input$ems_ems == 2 && "Within Cells" %in% rownames(aov_out_l)){
         aov_out_l["Within Cells","imp"]<-""#delete importance from residuals
       } else{
         aov_out_l["Residuals","imp"]<-""#delete importance from residuals
       }
       
       #calculate %RFC
       
       
       #Assign columns and rows for creating the output table (used to reorder and take out columns)
       out_row<-1:nrow(aov_out_l)
       
       #make source table
       #header
       #label if dispersion or means analysis
       if(disp){
         type<-as.numeric(input$ems_disp_type)#1=ADA, 2=ADM, 3=ADMn1
         type_name<-c("ADA","ADM","ADM<sub>(n-1)</sub>")
         
         output<-paste0("Dependent Variable: ",names(data)[data_id],"<br>Dispersion Analysis based on ",type_name[type])
       } else (
         output<-paste0("Dependent Variable: ",names(data)[data_id],"<br>Means Analysis")
       )
       if(!is.logical(input$ems_ems)){
         if(input$ems_ems==1){
           output<-paste0(output,"<br>Unbalanced Design: Unweighted Analysis")
         } else
         if(input$ems_ems==2){
         output<-paste0(output,"<br>ANOVA Notes: ",report_commentary(anova_note()))
         } else
           if(input$ems_ems==3){
             output<-paste0(output,"<br>Unbalanced Design: Weighted Analysis")
           }
       } else{
         output<-paste0(output,"<br>ANOVA Notes: ",report_commentary(anova_note()))
       }
       if(is.logical(show_ems) && show_ems){#include ems output
         #out_col<-c(2,1,3,4,5,8,7)
         out_col<-c("SS","Df","MS","Fvalue","Pvalue","Type","imp","EMS")
         output<-paste(output,"<table><tr><th><b>Source</b></th><th><b>SS</b></th><th><b>df</b></th><th><b>MS</b></th><th><b>F</b></th><th><b>p</b></th><th><b>Type(F/R)</b></th><th><b>",withMathJax("$$\\omega^2$$")," or ICC</b></th><th>EMS</b></th>")
       } else {
         #out_col<-c(2,1,3,4,5,8)
         out_col<-c("SS","Df","MS","Fvalue","Pvalue","Type","imp")
         output<-paste(output,"<table><tr><th><b>Source</b></th><th><b>SS</b></th><th><b>df</b></th><th><b>MS</b></th><th><b>F</b></th><th><b>p</b></th><th><b>Type(F/R)</b></th><th><b>",withMathJax("$$\\omega^2$$")," or ICC</b></th>")
       }
       
       #aov_out_l<-transform(aov_out_l,Df=as.numeric(Df,SS=as.numeric(SS)),MS=as.numeric(MS),Fvalue=as.numeric(Fvalue))
       aov_out_r<-ro(aov_out_l,R)#rounded from this point on
       
       #make rows
       for(i in out_row){
         output<-paste(output,"<tr><td><b>",rownames(aov_out_r)[i],"</b></td>")
         for(j in out_col){
           if((rownames(aov_out_r)[i]=="Residuals" || rownames(aov_out_r)[i]== "Within Cells") && (j=="Fvalue" || j=="Pvalue" || j=="imp")){
             output<-paste(output,"<td></td>")
             next(j)
           }
           if(j=="Pvalue" && aov_out_r[i,j]=="" ){
             output<-paste(output,"<td></td>")
             next(j)
           }
           if(is.nan(aov_out_r[i,j])){#catches unreplicated since this causes an error in the next test
             output<-paste(output,"<td>NaN</td>")
             next(j)
           }
           if((j=="Pvalue" && as.numeric(gsub(pattern = "<",replacement = "",x = aov_out_r[i,j]))<(1-conf)) ){#accounts for < sign in p-value
             output<-paste(output,"<td bgcolor='yellow'>",aov_out_r[i,j],"*</td>")
           }else{
             output<-paste(output,"<td>",aov_out_r[i,j],"</td>")
           }
         }
         output<-paste(output,
                       #"<td><div class ='checkbox'><label><input id = 'pool_",rownames(aov_out)[i],"' class = 'shiny-input-checkbox shiny-bound-input' type = 'checkbox'></label></div></td>",
                       "</tr>")
       }
       if(input$ems_show_pool){
         output<-HTML(paste(output,"</table>","<br><br><br><b><u>Pooled Effects</u></b><br><br>",paste0(pool_vars,collapse = " || ")))
       } else{
         output<-HTML(paste(output,"</table>"))
       }
       
       HTML(output)
       
     })
       
       ems_sig_effects <- reactive({#combined graph of significant effects
         
         pool <- input$ems_pool
         data <- res_filter$filtered()
         data_col <- as.numeric(input$data_ems)
         factor_col <- as.numeric(input$factors_ems)
         conf <- input$ems_conf
         req(data,data_col,factor_col)
         data[,factor_col]<-lapply(data[,factor_col],factor)
         disp<-input$ems_disp#logical True is a dispersion test
         p<-plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
         
         if(isTruthy(input$f_r_factor1)){
           for(i in 1:length(factor_col)){
             if(input[[paste0("f_r_factor",as.character(i))]]=="R"){return({
               # Create a blank plot
               plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
               # Add text to the plot
               text(1, 1, "This plot can't display random effects. Examine the interaction plots below", cex = 1.5)
             })}
           }
         }
         #add dispersion data if needed
         if(disp){
           data_id<-as.numeric(input$data_ems)
           factors_id<-as.numeric(input$factors_ems)
           factors_names<-names(data)[factors_id]
           formula<-paste(names(data)[data_id],"~",factors_names[1])
           disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
           
           for(i in 2:length(factors_names)){
             formula<-paste(formula,"*",factors_names[i])
           }
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
             data_col<-ncol(data)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
             data_col<-ncol(data)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
             data_col<-ncol(data)
           }
         }
         
         # Determine which AOV function to use based on input
         aov_out_l <- if (!is.null(pool)) {
           ems_pooled()
         } else {
           aov_out()
         }
         if(any(row.names(aov_out_l) %in% "(Intercept)")){
           aov_out_l <- aov_out_l[!(row.names(aov_out_l) %in% "(Intercept)"),]
         }
         # Find significant effects in the ANOVA
         sig_effects <- rownames(aov_out_l[aov_out_l$Pvalue <= (1 - conf), ])
         sig_effects <- sig_effects[sig_effects != "NA"]
         # If no significant effects, return NULL or an empty plot
         if (length(sig_effects) == 0) {
           return({
             # Create a blank plot
             plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
             # Add text to the plot
             text(1, 1, "No significant effects to plot.", cex = 1.5)
           })
         }
         
         #generate the reduced model only for significant effects (including any main effects that are involved in a significant interaction)all_factors <- names(data)[factor_col]
         interaction_factors <- grep(":", sig_effects, value = TRUE)
         individual_factors <- unique(unlist(strsplit(interaction_factors, ":")))
         filtered_factors <- individual_factors[individual_factors %in% individual_factors]
         # Ensure 'filtered_factors' is a character vector, even if it's empty
         if (is.null(filtered_factors)) {
           filtered_factors <- character(0)
         }
         all_sig_interactions<-sig_effects[grep(pattern = ":",x = sig_effects)]
         sig_main<- setdiff(setdiff(sig_effects,interaction_factors),filtered_factors)#any main effects that are significant and not part of an interaction
         if(isTruthy(all_sig_interactions)){
           formula <- paste( names(data)[data_col],"~", paste(filtered_factors,collapse = "+"),"+",paste(gsub(pattern = ":",replacement = "*",x = all_sig_interactions),collapse = "+") )
         } else{
           formula <- paste( names(data)[data_col],"~", paste(filtered_factors,collapse = "+") )
         }
         
         if(isTruthy(sig_main)){
           if(!isTruthy(all_sig_interactions)){
             formula <- paste(formula,paste(sig_main,collapse = "+"))
           } else{
             formula <- paste(formula,"+",paste(sig_main,collapse = "+"))
           }
           data[c(filtered_factors,sig_main)]<-lapply(data[c(filtered_factors,sig_main)],factor)
         } else{
           data[filtered_factors]<-lapply(data[filtered_factors],factor)
         }

         model <- lm(formula = formula(formula),data = data)#lme? since this is for estimating means, I don't think so
         #or this?
         # data$group<-interaction(data[factor_col])
         # model<-do.call(gls,list(formula, data = data, weights = varIdent(form = ~1 | group)))#this fails for var=0 in a cell
         model_mean_est(model)#send this reduced model out for parameter estimates and settings estimates
         
         #emm<-emmeans(model,formula(substr(x = formula,start = gregexpr(pattern = "~",text = formula),stop = nchar(formula))))
         #emm_sig(emm)
         
         # Split into main effects and interactions that are significant so we know what to graph
         main_effects <- sig_effects[!grepl(":", sig_effects)]
         two_way_interactions <- sig_effects[grepl("^[^:]*:[^:]*$", sig_effects)]
         higher <- sig_effects[str_detect(sig_effects, ".*:.*:.*")]
         if(length(higher)==0){
           higher_present<-FALSE
         } else(higher_present<-TRUE)
         # 
         #take out main effects that are involved in an interaction
         to_keep <- sapply(main_effects, function(x) {
           !any(str_detect(two_way_interactions, fixed(x)))
         })
         
         # Filter main effects
         if(isTruthy(main_effects)){
           main_effects <- main_effects[to_keep]
         }
         #if there are no effects left to graph, i.e. only three-way, return
         if(length(main_effects)==0 && length(two_way_interactions)==0){
           return({
             # Create a blank plot
             plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
             # Add text to the plot
             text(1, 1, "This graph cannot plot three-way or higher interactions. Check interaction plots below.", cex = 1.5)
           })
         }
         #
         # main effects
         
         PANEL=1
         if (length(main_effects) > 0) {
           for (i in main_effects) {
             #create temporary plot
             plot_temp<-emmip(model,
                              formula(paste("~",i)),
                              engine = "ggplot")
             #extract data
             main_data<-ggplot_build(plot_temp)$data[[1]]
             main_data$x<-paste(i,"=",levels(plot_temp[["data"]][[i]])[main_data$x])
             main_data$group<-NA
             main_data$PANEL<-PANEL
             PANEL<-PANEL+1
             if(!exists("plot_data")){
               plot_data<-main_data
             } else{
               plot_data<-rbind(plot_data,main_data)
             }
           }
         }

         #interactions
         if (length(two_way_interactions) > 0) {
           if(exists("plot_data")){#need to add columns for interaction output
             plot_data$shape<-NA
             plot_data$size<-NA
             plot_data$stroke<-NA
             plot_data$fill<-NA
             plot_data<-plot_data[-which(colnames(plot_data)=="flipped_aes")]
             plot_data<-plot_data[-which(colnames(plot_data)=="linewidth")]
           }
           for (i in two_way_interactions) {
             #create temporary plot
             factors<-strsplit(i,":")
             plot_temp<-emmip(model,
                              formula(paste(factors[[1]][1],"~",factors[[1]][2])),
                              engine = "ggplot")
             #extract data
             
             int_data<-ggplot_build(plot_temp)$data[[1]]
             int_data$group<-paste(factors[[1]][1],"=",levels(plot_temp[["data"]][[factors[[1]][1]]])[int_data$group])
             int_data$x<-paste(factors[[1]][2],"=",levels(plot_temp[["data"]][[factors[[1]][2]]])[int_data$x])
             int_data$PANEL<-PANEL
             PANEL<-PANEL+1
             names(int_data)[names(int_data)=="x"]<-"group1"
             names(int_data)[names(int_data)=="group"]<-"x"
             names(int_data)[names(int_data)=="group1"]<-"group"
             if(exists("plot_data")){
               plot_data<-rbind(plot_data,int_data)
             }else {
               plot_data<-int_data
             }
           }
         }
         plot_data<-plot_data[c("group", "x", "y", "PANEL")]
         names(plot_data)<-c("SecondFactor","FirstFactor","y","section")
         plot_data$FirstFactor <- factor(plot_data$FirstFactor)
         plot_data$SecondFactor <- factor(plot_data$SecondFactor)
         
         title<-"Significant Effects - Estimated Marginal Means\n Main effects not included if part of an interaction"
         if(higher_present){
           title<-paste(title," - Significant higher three-way or higher interactions not displayed")
         }
         level_colors<-rep(color[-1],length.out=ceiling(length(unique(plot_data$SecondFactor))/7)*7)
         
         p<-ggplot(plot_data, aes(FirstFactor, y, group = SecondFactor, label = SecondFactor, color=SecondFactor)) +
           scale_color_manual(values=level_colors)+
           geom_line(linewidth=1.5) +
           geom_point(size=4) +
           geom_text(data = . %>% filter(FirstFactor == last(FirstFactor), .by = section),color=color[1]) +
           facet_wrap(~section, nrow = 1, scales = "free_x")+
           xlab("Factor")+
           ylab(names(data)[data_col])+
           theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
           ggtitle(title)+
           labs(subtitle="Based on a reduced model using only significant effects")
        
         if(isTruthy(input$ems_target)){
           p<-p+geom_hline(yintercept=as.numeric(input$ems_target),color=color[2],linetype=2)
         }
         
         return(p)
         
       })
       
       ####
       emssigeffects_height<-reactive(400*4)
       emssigeffects_width<-reactive(400*8)
       
       output$emssigeffects<-renderPlot({
         req(emssigeffects_height(), emssigeffects_width())
         ems_sig_effects()
       },width=800,#do this to get reasonable size on screen and download
       height=400,#
       )
       downloadServer('emssigeffects',ems_sig_effects,height=emssigeffects_height,width=emssigeffects_width)
       ####
       
       output$multi_coeff_est <-renderDT({
         model<-model_mean_est()
         R<-input$ems_dec
         req(model,R)
         coeffs<-ro(data.frame(model$coefficients),R)#rounded
         
         output<-datatable(coeffs,options = list(dom='t',paging=FALSE))
         
         output
       })
       
       output$multi_response_target<-renderDT({
         model<-model_mean_est()
         target<-input$ems_target
         emm<-emmeans(object = model,specs = formula(paste("~",model[["terms"]][[3]][[2]][2])))#use this for predictions, based on the reduced model
         R<-input$ems_dec
         req(emm,target,R)
         tol<-input$multi_response_tol
         if(!isTruthy(tol)){tol<-0}
         
         closest_settings<-summary(emm)[which(abs(summary(emm)$emmean - target) <= tol),]#use this to get combinations that are close to target
         closest_settings<-closest_settings[-c( (ncol(closest_settings)-3): ncol(closest_settings))]#remove SE and CL since currently the model is pooled variance
         closest_settings<-ro(closest_settings,R)
         output<-datatable(closest_settings,,options = list(dom='t',paging=FALSE),rownames = FALSE)
         output
       })
       
       
       # ####Add this later maybe
       # emseffectsizegraph_height<-reactive(400*4)
       # emseffectsizegraph_width<-reactive(400*8)
       # 
       # output$emseffectsizegraph<-renderPlot({
       #   req(emseffectsizegraph_height(), emseffectsizegraph_width())
       #   ems_effect_size_graph()
       # },width=800,#do this to get reasonable size on screen and download
       # height=400,#
       # )
       # downloadServer('emseffectsizegraph',ems_effect_size_graph,height=emseffectsizegraph_height,width=emseffectsizegraph_width)
       # ####
       # 
       # ems_effect_size_graph<-reactive({
       #   emm_in<-emm_model()
       #   data<-as.data.frame(emm_in$contrasts)
       #   conf<-input$ems_conf
       #   req(emm_in,data,conf)
       #   
       #   #also could do Cohen's d d<-eff_size(object = emm_in,sigma = sigma(aov_model()),edf = emm_in[["contrasts"]]@dfargs[["df"]])
       #   z<-qnorm(p = (1-conf)/2,lower.tail = FALSE)
       #   p<-ggplot(data = data,aes(x=contrast,y=estimate))+
       #     geom_point()+
       #     geom_col()+
       #     geom_errorbar(aes(ymin = estimate-(z*SE),ymax=estimate+(z*SE)))+
       #     labs(title = "Practical Importance")+
       #     xlab("Contrast")+
       #     ylab("Effect Size based on Estimated Marginal Means")
       #   p
       # })
       
       ####
       emsmaineffects_height<-reactive(
         ceiling(length(input$factors_ems)/3)*500
         )
       emsmaineffects_width<-reactive(400*2)
       output$emsmaineffects<-renderPlot(ems_main_effects(),width = emsmaineffects_width,height = emsmaineffects_height)
       
       #Download sizes so that we can still use the dynamic sizing but also print to a good size
       download_height<-reactive(emsmaineffects_height()*5)
       download_width<-reactive(emsmaineffects_width()*5)

       downloadServer('emsmaineffects',ems_main_effects,height=download_height,width=download_width)
       ####
       
       ems_main_effects<-reactive({
         data_col<-as.numeric(input$data_ems)
         factor_col<-as.numeric(input$factors_ems)
         target<-input$ems_target
         
         #########
         #select correct data
         data<-res_filter$filtered()
         disp<-input$ems_disp#logical True is a dispersion test
         data[,factor_col]<-lapply(data[,factor_col],factor)
         
         if(disp){
           me_title<-"Main Effects - Dispersion"
           factors_names<-names(data)[factor_col]
           formula<-paste(names(data)[data_col],"~",factors_names[1])
           disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
           
           for(i in 2:length(factors_names)){
             formula<-paste(formula,"*",factors_names[i])
           }
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_col],"_ADA")
             data_col_name<-paste0(names(data)[data_col],"_ADA")
             data_col<-ncol(data)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_col],"_ADM")
             data_col_name<-paste0(names(data)[data_col],"_ADM")
             data_col<-ncol(data)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_col],"_ADMn1")
             data_col_name<-paste0(names(data)[data_col],"_ADMn1")
             data_col<-ncol(data)
           }
         } else{#not dispersion
           me_title<-"Main Effects - Means"
           data_col<-as.numeric(input$data_ems)
           data_col_name<-names(data)[data_col]
         }
         
         p<-data %>%
           pivot_longer(all_of(factor_col)) %>%
           mutate(level=paste(name,"=",value)) %>%
           ggplot(aes(y=!!sym(data_col_name))) +
           stat_boxplot(aes(x=level),geom="errorbar",width=0.5)+
           geom_boxplot(aes(x=level),fill=color[3])+
           stat_summary(aes(x=level),fun="mean",geom="point",size=5)+
           facet_wrap(vars(name),scales="free")+#,ncol=3
           ggtitle(me_title)+
           theme(axis.text.x = element_text(angle = 45,hjust=1),
                 axis.title = element_text(size=rel(1.5)),
                 axis.text = element_text(size=rel(1.5)),
                 plot.title = element_text(size=rel(1.5)),
                 strip.text=element_text(size=rel(1.5))
           )
        
         if(isTruthy(target)){
           p<-p+geom_hline(yintercept=as.numeric(input$ems_target),color=color[2],linetype=2)
         }
         p
         
       })
       
       output$ems_int_sel<-renderUI({
         pool<-input$ems_pool
         if (!is.null(pool)){
           aov_l<-ems_pooled()
         } else(
           aov_l<-aov_out()
         )
         
         req(aov_l)
         
         int_sel<-data.frame(rownames(head(aov_l,-1)))
         int_sel<-deframe(filter(.data = int_sel,(str_count(string = rownames(head(aov_l,-1)),pattern = ":")==1 | str_count(string = rownames(head(aov_l,-1)),pattern = ":")==2)  ))
         names(int_sel)<-int_sel
         int_sel<-list("Interactions"=int_sel)
         disp<-input$ems_disp#logical True is a dispersion test
         if(disp){
           int_title<-"Show Two- and Three-Way Interaction Plots for Dispersion (Observed):"
         } else{
           int_title<-"Show Two- and Three-Way Interaction Plots for Means (Observed):"
           }
         
         pickerInput(inputId = "ems_int_selected",
                     label = int_title,
                     choices = int_sel,
                     multiple = TRUE,
                     options=list("actions-Box"=TRUE,
                                  "title"="Select effects to include"),width = "100%"
                     )
         
         
       })
       
       eff_types<-function(){
         pool<-input$ems_pool
         if (!is.null(pool)){
           aov_l<-ems_pooled()
         } else(
           aov_l<-aov_out()
         )
         factors_sel<-input$factors_ems
         n_factors<-length(factors_sel)
         data<-res_filter$filtered()
         req(aov_l,n_factors)
         if("(Intercept)" %in% rownames(aov_l)){
           aov_l<-aov_l[-which(rownames(aov_l)=="(Intercept)"),]
         }
         #create what effects are random
         effects_f_r<-data.frame(effect=row.names(head(aov_l,-1)))
         row.names(effects_f_r)<-effects_f_r$effect
         effects_f_r$type<-rep("F",nrow(effects_f_r))
         effects_f_r$type_code<-1
         fac_names<-names(data)[as.numeric(factors_sel)]
         if(input$ems_show_mixed_nest){
           for(i in 1:n_factors){#adds effect type to main effects
             effects_f_r[which(gsub("\\(.*?\\)", "", effects_f_r$effect)==fac_names[i]),]$type<-input[[paste0("f_r_factor",i)]]#handles nested factors
             if(effects_f_r$type[i]=="R"){effects_f_r$type_code[i]<-0}
           }
           if(i==nrow(effects_f_r)){return(effects_f_r)}#if main effects only
           else{
             #add effect type to interactions
             for (i in (n_factors+1):nrow(effects_f_r)){
               m_effects<-str_split(string = effects_f_r[i,1],pattern = ":",simplify = TRUE)
               sub_effects<-effects_f_r[m_effects,]
               sub_effects$type_code[sub_effects$type=="R"]<-0
               effects_f_r$type_code[i]<-prod(sub_effects$type_code)
               if(effects_f_r$type_code[i]==0){
                 effects_f_r$type[i]<-"R"
               }
             }
           }
         }
         return(effects_f_r)
       }
       
       gen_twoway_int_plots<-function(fact_a,fact_b){#function to generate one interaction plot
         #select correct data
         data<-res_filter$filtered()
         disp<-input$ems_disp#logical True is a dispersion test
         target<-input$ems_target
         # factor_col<-as.numeric(input$factors_ems)
         # data[,factor_col]<-lapply(data[,factor_col],factor)
         
         req(data,fact_a,fact_b)
         if(disp){
           data_id<-as.numeric(input$data_ems)
           factors_id<-as.numeric(input$factors_ems)
           factors_names<-names(data)[factors_id]
           formula<-paste(names(data)[data_id],"~",factors_names[1])
           disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
           
           for(i in 2:length(factors_names)){
             formula<-paste(formula,"*",factors_names[i])
           }
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
             data_col<-ncol(data)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
             data_col<-ncol(data)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
             data_col<-ncol(data)
           }
         } else{#not dispersion
           data_col<-as.numeric(input$data_ems)
         }
         
         req(data_col)
         

         
         y = names(data)[data_col]
         
         effects_f_r<-eff_types()
         
         if(effects_f_r[paste0(fact_a,":",fact_b),2]=="R"){#random effect
           pool<-input$ems_pool
           if (!is.null(pool)){
             aov_l<-ems_pooled()
           } else(
             aov_l<-aov_out()
           )
           
           msb<-aov_l[paste0(fact_a,":",fact_b),]$MS
           msw<-aov_l["Residual",]$MS
           J<-nrow(unique(data[c(fact_a,fact_b)]))
           sum_n<-sum((data %>% count(!!(sym(fact_a)),!!(sym(fact_b))))$n)
           sum_nsq<-sum(((data %>% count(!!(sym(fact_a)),!!(sym(fact_b))))$n)^2)
           K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
           bcv<-(msb-msw)/K_prime
           bcv<-max(0,bcv)
           ICC<-100*bcv/(bcv+msw)
           
           pop_mean<-mean(data[[data_col]])
           limits<-data.frame(x=c(pop_mean-2*bcv^.5-3*msw^.5,pop_mean,pop_mean+2*bcv^.5+3*msw^.5))
           colors<-c("Population of Means"=as.character(color[5]),"Unexplained Variability"=as.character(color[3]),"Unexplained Variability"=as.character(color[3]))
             
           p<-ggplot(data = limits,aes(x,fill=colors))+
             ylab("PDF(x)")+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean,sd=bcv^.5),aes(fill="Population of Means"),color=color[1])+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean-2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean+2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             labs(title=paste0("Random Effects Post-Hoc for ",fact_a,":",fact_b),fill=" ")+
             scale_fill_manual(values=colors)
           
           ylim<-ggplot_build(p)[["layout"]][["panel_scales_y"]][[1]][["range"]][["range"]][2]
           
           effect_line<-c("95.45% Confidence Interval of Effect"=as.character(color[1]))
           p<-p+geom_segment(aes(x=pop_mean-2*bcv^.5,y=ylim/2,xend=pop_mean+2*bcv^.5,yend=ylim/2,color=effect_line),size=2)+
             scale_color_manual(values = effect_line)+
             labs(color=" ")+
             theme(legend.position = "bottom")+
             annotate("text",x=-Inf,y=Inf,hjust="left",vjust="top",label=paste0("ICC = ",ro(ICC,input$ems_dec),"%"))
           
         } else{#fixed effect
           p<-ggplot(data, aes(x = .data[[fact_a]],
                            y = .data[[y]],
                            color = factor(.data[[fact_b]]),
                            linetype = factor(.data[[fact_b]]),
                            shape=factor(.data[[fact_b]]))
           ) +
             scale_color_manual(values=color[-1])+
             stat_summary(fun = mean,geom="line",linewidth=1.5)+
             stat_summary(fun = mean,geom="point",size=4)+
             ggtitle(paste0("Two-way Interaction ",fact_a,":",fact_b))+
             theme(axis.text.x = element_text(angle = 45,hjust=1),
                   axis.title = element_text(size=rel(1.5)),
                   axis.text = element_text(size=rel(1.5)),
                   plot.title = element_text(size=rel(1.5)),
                   strip.text=element_text(size=rel(1.5)),
                   legend.text=element_text(size=rel(1.5)),
                   aspect.ratio=1
             )
         }
         if(isTruthy(target)){
           p<-p+geom_hline(yintercept=as.numeric(input$ems_target),color=color[2],linetype=2)
         }
         p

       }#end two-way interaction plot
       
       
       output$emsinteractions<-renderUI({ems_interactions()})
       emsinteractions_height<-reactive(400*4)
       emsinteractions_width<-reactive(400*4)
       #downloadServer('emsinteractions', ems_interactions,height = emsinteractions_height,width = emsinteractions_width)
       
       
       ems_interactions<-reactive({#set up multiple interaction plots based on user input
         data<-res_filter$filtered()
         data_col<-as.numeric(input$data_ems)
         factor_col<-as.numeric(input$factors_ems)
         int_selected<-input$ems_int_selected
         req(data,data_col,factor_col,int_selected)
         target<-input$ems_target
         
         if (!is.null(input$ems_int_selected)) { 
           plot_list<-lapply(1:length(int_selected), function(i){
             if(str_count(int_selected[i],pattern = ":")==2){
               fac<-str_split_1(int_selected[i],pattern = ":")[3]
               level<-length(unique(data[[fac]]))
               plotOutput(outputId = paste0("int_plot_",i),height=400*level)
             } else{
               plotOutput(outputId = paste0("int_plot_",i))
             }
           })
           do.call(tagList,plot_list)
         }
       })
       int_select_or_target<-reactive({
         list(input$ems_int_selected,input$ems_target)
       })
       observeEvent(int_select_or_target(),{#generate the interaction plots, must run after ems_interactions
         int_selected<-input$ems_int_selected #user selected interactions
         req(int_selected)
         target<-input$ems_target
         n = length(int_selected)
         format<-input$ems_interaction_dl_format
         
         lapply(int_selected, function(par) {
           
           for (j in 1:n){
             if (par == int_selected[j]) i = j
           }
           factors<-str_split_1(par,pattern = ":") #split the interaction into the factors
           
           if(length(factors)==2){#two-way
             p<-gen_twoway_int_plots(fact_a = factors[1],fact_b = factors[2])
             output[[paste0("int_plot_",i)]]<-renderPlot(p)
               
           } else if(length(factors)==3){#three-way
             p<-gen_threeway_int_plots(fact_a = factors[1],fact_b = factors[2],fact_c = factors[3])
             output[[paste0("int_plot_",i)]]<-renderPlot(p)
             }
           
           #save plot
           
           ggsave(filename = paste0("int_plot_",i,".",format),plot = p)

           })
       },ignoreInit = TRUE,ignoreNULL = TRUE)
       
       gen_threeway_int_plots<-function(fact_a,fact_b,fact_c){#function to generate one 3-way interaction plot
         #select correct data
         data<-res_filter$filtered()
         disp<-input$ems_disp#logical True is a dispersion test
         target<-input$ems_target
         # factor_col<-as.numeric(input$factors_ems)
         # data[,factor_col]<-lapply(data[,factor_col],factor)
         
         if(disp){
           data_id<-as.numeric(input$data_ems)
           factors_id<-as.numeric(input$factors_ems)
           factors_names<-names(data)[factors_id]
           formula<-paste(names(data)[data_id],"~",factors_names[1])
           disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
           
           for(i in 2:length(factors_names)){
             formula<-paste(formula,"*",factors_names[i])
           }
           if(disp_type==1){
             data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_id],"_ADA")
             data_col<-ncol(data)
           } else if(disp_type==2){
             data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_id],"_ADM")
             data_col<-ncol(data)
           } else if(disp_type==3){
             data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
             colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_id],"_ADMn1")
             data_col<-ncol(data)
           }
         } else{#not dispersion
           data_col<-as.numeric(input$data_ems)
         }
         
         req(data,fact_a,fact_b,fact_c,data_col)
         
         y = names(data)[data_col]
         
         effects_f_r<-eff_types()
         
         if(effects_f_r[paste0(fact_a,":",fact_b),2]=="R"){#random effect
           pool<-input$ems_pool
           if (!is.null(pool)){
             aov_l<-ems_pooled()
           } else(
             aov_l<-aov_out()
           )
           
           msb<-aov_l[paste0(fact_a,":",fact_b,":",fact_c),]$MS
           msw<-aov_l["Residual",]$MS
           J<-nrow(unique(data[c(fact_a,fact_b,fact_c)]))
           sum_n<-sum((data %>% count(!!(sym(fact_a)),!!(sym(fact_b)),!!(sym(fact_c))))$n)
           sum_nsq<-sum(((data %>% count(!!(sym(fact_a)),!!(sym(fact_b)),!!(sym(fact_a))))$n)^2)
           K_prime<-(1/(J-1))*(sum_n-(sum_nsq/sum_n))
           bcv<-(msb-msw)/K_prime
           bcv<-max(0,bcv)
           ICC<-100*bcv/(bcv+msw)
           
           pop_mean<-mean(data[[data_col]])
           limits<-data.frame(x=c(pop_mean-2*bcv^.5-3*msw^.5,pop_mean,pop_mean+2*bcv^.5+3*msw^.5))
           colors<-c("Population of Means"=as.character(color[5]),"Unexplained Variability"=as.character(color[3]),"Unexplained Variability"=as.character(color[3]))
           
           p<-ggplot(data = limits,aes(x,fill=colors))+
             ylab("PDF(x)")+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean,sd=bcv^.5),aes(fill="Population of Means"),color=color[1])+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean-2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             geom_area(stat="function",fun=dnorm,args=list(mean=pop_mean+2*bcv^.5,sd=msw^.5),aes(fill="Unexplained Variability"),color=color[3],alpha=.5)+
             labs(title=paste0("Random Effects Post-Hoc for ",fact_a,":",fact_b,":",fact_c
                               ),fill=" ")+
             scale_fill_manual(values=colors)
           
           ylim<-ggplot_build(p)[["layout"]][["panel_scales_y"]][[1]][["range"]][["range"]][2]
           
           effect_line<-c("95.45% Confidence Interval of Effect"=as.character(color[1]))
           p<-p+geom_segment(aes(x=pop_mean-2*bcv^.5,y=ylim/2,xend=pop_mean+2*bcv^.5,yend=ylim/2,color=effect_line),size=2)+
             scale_color_manual(values = effect_line)+
             labs(color=" ")+
             theme(legend.position = "bottom")+
             annotate("text",x=-Inf,y=Inf,hjust="left",vjust="top",label=paste0("ICC = ",ro(ICC,input$ems_dec),"%"))
         } else {#fixed effect
           p<-ggplot(data, aes(x = .data[[fact_a]],
                            y = .data[[y]],
                            color = factor(.data[[fact_b]]),
                            linetype = factor(.data[[fact_b]]),
                            shape=factor(.data[[fact_b]]))
           ) +
             scale_color_manual(values=color[-1])+
             facet_grid(vars(.data[[fact_c]]),labeller = "label_both")+
             stat_summary(fun = mean,geom="line",linewidth=1.5)+
             stat_summary(fun = mean,geom="point",size=4)+
             ggtitle(paste0("Three-way Interaction ",fact_a,":",fact_b,":",fact_c))+
             labs(color=fact_b)+
             theme(axis.text.x = element_text(angle = 45,hjust=1),
                   axis.title = element_text(size=rel(1.5)),
                   axis.text = element_text(size=rel(1.5)),
                   plot.title = element_text(size=rel(1.5)),
                   strip.text=element_text(size=rel(1.5)),
                   legend.text=element_text(size=rel(1.5)),
                   aspect.ratio=1
             )+
             guides(shape="none",linetype="none")
         }
         if(isTruthy(target)){
           p<-p+geom_hline(yintercept=as.numeric(input$ems_target),color=color[2],linetype=2)
         }
         p

       }
       
       output$ems_interaction_dl<-downloadHandler(#download all interaction plots as zip
         
         filename="int_plots.zip",
         content=function(file){
           n_graphs<-length(input$ems_int_selected)
           format<-input$ems_interaction_dl_format
           files<-character(n_graphs)
           
           for(i in 1:n_graphs){
               file_path<-paste0("int_plot_",i,".",format)
               files[i]<-file_path
             }
           zip::zip(zipfile = file,files = files)
           
         }
         
       )
       
       output$ems_ph_selection <- renderUI({ #240521
         
         pool<-input$ems_pool
         data<-res_filter$filtered()
         data_col<-as.numeric(input$data_ems)
         factor_col<-as.numeric(input$factors_ems)
         conf<-input$ems_conf
         ph_test<-input$ems_ph_select
         prime<-input$ems_primary_col#need to invalidate output
         unbal<-input$ems_ems#need to invalidate output
         req(data,ph_test)
         if (!is.null(pool)){
           aov_out_l<-ems_pooled()
         } else(
           aov_out_l<-aov_out()
         )
         
         #this needs to agg only over selected effects - also needs to handle higher-order interactions
         effects_list<-head(aov_out_l[5],-1)
         sig_effects<-subset(effects_list,Pvalue<(1-conf))
         if(nrow(sig_effects)==0){
           return(
             pickerInput(inputId = "ems_ph_effects",
                       label = "No significant effects for post-hoc",
                       choices = NULL,
                       selected = NULL
           )
           )
           
           #return("No significant effects to test")
           }
         
         #determine highest level of significant interaction(s)str_count()
         #use only significant effects, and only highest level effects - have user select?
         pickerInput(inputId = "ems_ph_effects",
                     label = "Select effects for post-hoc",
                     choices = row.names(sig_effects),
                     options = list(title="Select Effect(s)"),
                     selected = NULL
         )
         
       })
       
       ####
       emsphplot_height<-reactive(400*4)
       emsphplot_width<-reactive(400*8)
       
       output$emsphplot<-renderPlot({
         req(emsphplot_height(), emsphplot_width())
         ems_ph_plot()
       },width=800,#do this to get reasonable size on screen and download
       height=400,#
       )
       downloadServer('emsphplot',ems_ph_plot,height=emsphplot_height,width=emsphplot_width)
       ####
       
       ems_ph_plot<-reactive({
         emm<-emm_model()
         req(emm)
         factors_col<-input$factors_ems#need to invalidate output
         data_col<-input$data_ems#need to invalidate output
         data<-res_filter$filtered()#need to invalidate output
         pool<-input$ems_pool#need to invalidate output
         prime<-input$ems_primary_col#need to invalidate output
         unbal<-input$ems_ems#need to invalidate output
         
         p<-plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
         if(any(emm=="zerovar")){
           return({
             # Create a blank plot
             plot(1, type = "n", axes = FALSE, xlab = "", ylab = "")
             # Add text to the plot
             text(1, 1, "At least one combination has zero variance.\n An unequal variance post-hoc cannot be used.", cex = 1.5)
           })
         }
         conf<-input$ems_conf
         ph_test<-input$ems_ph_select
         ph_effect<-input$ems_ph_effects
         req(conf,ph_test,ph_effect)

         plot_options<-input$ems_ph_plot_options
         font_size<-as.numeric(input$ph_font_size)
         target<-input$ems_target
         if(isTruthy(plot_options)){
           ifelse(test = "CIs" %in% plot_options,yes = CIs<-TRUE,no = CIs<-FALSE)
           ifelse(test = "PIs" %in% plot_options,yes = PIs<-TRUE,no = PIs<-FALSE)
           ifelse(test = "hor" %in% plot_options,yes = hor<-TRUE,no = hor<-FALSE)
         } else{
           CIs<-FALSE
           PIs<-FALSE
           hor<-FALSE
         }
         test_name <-c("Tukey","Bonferroni Procedure","Holm's Method","Games-Howell","Bonferroni Procedure - unequal variances","Holm's Method - unequal variances")[as.numeric(ph_test)]
         adjust_method<-c("tukey","bonferroni","holm","tukey","bonferroni","holm")[as.numeric(ph_test)]
         ##following was trying to bring the function into ROIstat
         # plot_data<-plot(emm,
         #      type="response",
         #      comparisons=TRUE,
         #      adjust=adjust_method,
         #      alpha=(1-conf),
         #      plotit=FALSE
         #      )
         # byv = attr(emm, "by.vars")
         # if (!is.null(byv) && length(byv) > 0) {
         #   chform = paste(chform, "|", paste(byv, collapse="*"))
         #   lbv = do.call("paste", c(unname(emm[byv]), sep = sep)) # strings for matching by variables
         #   ubv = unique(lbv)
         # }
         # else {
         #   lbv = rep(1, nrow(emm))
         #   ubv = 1
         # }
         # p<-ggplot(data = plot_data,aes_(x=~the.mean,y=~pri.fac))+
         #   geom_point(color = CI.col, alpha = .0)+
         #   geom_segment(ggplot2::aes_(x = ~the.emmean, 
         #                              xend = ~lcmpl, y = ~pri.fac, yend = ~pri.fac), 
         #                arrow = ggplot2::arrow(length = ggplot2::unit(.07, "inches"), 
         #                                       type = "closed"), color = color[2], 
         #                data = emm[!is.na(emm$lcmpl), ]) +
         #   geom_segment(ggplot2::aes_(x = ~the.emmean, 
         #                              xend = ~rcmpl, y = ~pri.fac, yend = ~pri.fac), 
         #                arrow = ggplot2::arrow(length = ggplot2::unit(.07, "inches"), 
         #                                       type = "closed"), color = comp.col,
         #                data = emm[!is.na(emm$rcmpl), ])
         # 
         # if(PIs){
         #   geom_segment(ggplot2::aes_(x = ~lpl, xend = ~upl, 
         #                              y = ~pri.fac, yend = ~pri.fac), 
         #                color = color[3], lwd = 2.5, alpha = .15)
         # }
         # 
         # if(CIs){
         #   geom_segment(ggplot2::aes_(x = ~lcl, xend = ~ucl, 
         #                              y = ~pri.fac, yend = ~pri.fac), 
         #                color = coor[4], lwd = 4, alpha = .25)
         # }
         # 
         # if (length(byv) > 0)
         #   grobj = grobj + facet_grid(as.formula(paste(paste(byv, collapse = "+"), " ~ .")), 
         #                                       labeller = "label_both")
         # 
         # if (length(byv) > 0)
         #   grobj = grobj + ggplot2::facet_grid(as.formula(paste(paste(byv, collapse = "+"), " ~ .")), 
         #                                       labeller = "label_both")
         # 
         # p<-p+geom_point(color = dot.col, size = 2)
         # 
         # if(!horizontal)
         #   p<-p + ggplot2::coord_flip()
         # 
         # p<-p+xlab=paste0( "Estimated Marginal Means: ",names(res_filter$filtered())[as.numeric(input$data_ems)])+
         #   ggtitle(paste0("Contrast Plot using ",test_name," adjustment"))
         
         response<-aov_model()[["terms"]][[2]]
         p<-plot(emm,
              horizontal=hor,
              type="response",
              PIs=PIs,CIs=CIs,
              comparisons=TRUE,
              adjust=adjust_method,
              alpha=(1-conf),
              colors=color,
              xlab=paste0( "Estimated Marginal Means: ",aov_model()[["terms"]][[2]]) )+
           ggtitle(paste0("Contrast Plot using ",test_name," adjustment"," at ",conf*100,"% Confidence Interval"))+
           theme_bw(base_size = font_size)+#11 is default, but may be too small for some exports
           theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
         if(isTruthy(target)){
           p<-p+geom_vline(xintercept=as.numeric(target),color=color[2],linetype=2)
         }
         p
         
       })

       output$ems_ph_out<-renderUI({ #results needs to be an HTML object
         pool<-input$ems_pool
         data<-res_filter$filtered()
         data_col<-as.numeric(input$data_ems)
         factor_col<-as.numeric(input$factors_ems)
         conf<-input$ems_conf
         effects_4_ph <- input$ems_ph_effects
         ph_test<-input$ems_ph_select
         req(data,data_col,factor_col,conf,effects_4_ph,ph_test)
         if (!is.null(pool)){
           aov_out_l<-ems_pooled()
         } else(
           aov_out_l<-aov_out()
         )
         data[,factor_col]<-lapply(data[,factor_col],factor)
         
         disp<-input$ems_disp#logical True is a dispersion test
         
         req(aov_out_l)
         test_name <-c("Tukey","Bonferroni Procedure","Holm's Method","Games-Howell","Bonferroni Procedure - unequal variances","Holm's Method - unequal variances")[as.numeric(ph_test)]

         # construct cell means, s, n for these tests
         for (effect in effects_4_ph){
           # effect_names <- str_split(string = effect,pattern = ":",simplify = TRUE)
           # agg<-data.frame(aggregate(as.formula(paste0(names(data)[data_col],"~",paste0(effect_names,collapse = "+"))),data = data,FUN = function(x) c(mean=mean(x),sd=sd(x),n=length(x))))
           # names(agg)[ncol(agg)]<-"data"
           # #make group labels
           # label<-NULL
           # for(i in 1:nrow(agg)){
           #   label_add<-NULL
           #   for (j in 1:(ncol(agg)-1)){
           #     label_add<-paste0(label_add,names(agg)[j]," = ",agg[i,j]," ")
           #   }
           #   label<-c(label,label_add)
           # }
           #if(ph_test==1 || ph_test==2 || ph_test==3){#multiway tukey
             adjust_method<-c("tukey","bonferroni","holm","tukey","bonferroni","holm")
             if(isTruthy(input$ems_pool)){#the formula in aov_model() is the full factorial, since pooled variables exist we need to build a new formula taking out the pooled effects
                 effects<-setdiff(all_effects(),input$ems_pool)

                 gls_formula<-formula(paste(aov_model()[["terms"]][[2]],
                                    "~",
                                    gsub(pattern = ":",x = paste(effects,collapse = "+"),replacement = "*")
                                    ))
             } else{#full factorial
                 gls_formula<-formula(aov_model())
             }
             #add dispersion data if needed
             if(disp){
               disp_type<-input$ems_disp_type#which test, ADA=1, ADM=2, ADMn-1=3
               formula<-formula(paste(names(data)[data_col],"~",paste(names(data)[factor_col],collapse = "*")))#needed to generate dispersion
               if(disp_type==1){
                 data$ADA<-compute.group.dispersion.ADA(formula(formula),data = data)
                 colnames(data)[colnames(data)=="ADA"]=paste0(names(data)[data_col],"_ADA")
                 data_col<-ncol(data)
               } else if(disp_type==2){
                 data$ADM<-compute.group.dispersion.ADM(formula(formula),data = data)
                 colnames(data)[colnames(data)=="ADM"]=paste0(names(data)[data_col],"_ADM")
                 data_col<-ncol(data)
               } else if(disp_type==3){
                 data$ADMn1<-compute.group.dispersion.ADMn1(formula(formula),data = data)
                 colnames(data)[colnames(data)=="ADMn1"]=paste0(names(data)[data_col],"_ADMn1")
                 data_col<-ncol(data)
               }
             }
             if(ph_test>3){#need a model accounting for different variances
               data$group<-interaction(data[factor_col])
               #test to see if any sd = 0. If so, we can't do an unequal variance post-hoc
               sd_test<-aggregate(x = formula(paste(aov_model()[["terms"]][[2]],"~","group")),data = data,FUN = sd)
               if(min(sd_test[2])==0){
                 return({
                   emm_model("zerovar")
                   HTML("At least one combination has zero variance. An unequal variance post-hoc cannot be used.")
                 })
               } else{
                 model<-do.call(gls,list(gls_formula, data = data, weights = varIdent(form = ~1 | group)))
               }
               
             } else{
               if(isTruthy(input$ems_pool)){
                 model<-lm(gls_formula,data = data,singular.ok = TRUE)
               } else{
                 model<-aov_model()
               }
             }
             
             emm<-emmeans(model,
                          formula(paste("pairwise ~",gsub(pattern = ":",replacement = "*",x = effect))),
                          adjust = adjust_method[as.numeric(ph_test)],
                          type = "response",
                          data=data,
                          level=conf
             )
                              #mode="df.error")
                              #mode="satterthwaite")
             emm_model(emm)
                                    
             results<-as.data.frame(emm$contrasts)
             results$Decision<-ifelse(results$p.value<=(1-conf),yes = "Reject","")
             results<-separate(data = results,col = contrast,into = c("Row","Column"),sep = " - ")
             matrix<-pivot_wider(data = results[c(1,2,8)],names_from = Column,values_from = Decision)
             matrix<-rbind(matrix,NA)
             matrix[nrow(matrix),1]<-names(matrix)[ncol(matrix)]
             matrix<-as.matrix(matrix)
             row.names(matrix)<-matrix[,1]
             matrix<-cbind(NA,matrix)
             matrix<-matrix[,-2]
             colnames(matrix)[1]<-rownames(matrix)[1]
             #matrix[lower.tri(matrix)]<-t(matrix[upper.tri(matrix)])
             for(i in 1:nrow(matrix)){
               for(j in 1:(i-1)){
                 matrix[i,j]<-matrix[j,i]
               }
             }
             results<-as.list(results)
             results$matrix.decision<-matrix
             
             # results <- contrasts.tukey.kgroups.simple(group.label = label#gives incorrect results!
             #                                           ,group.mean = agg$data[,"mean"]
             #                                           ,group.sample.size = agg$data[,"n"]
             #                                           ,conf.level.familywise = conf,
             #                                           mean.squared.error = aov_out_l[nrow(aov_out_l),3],
             #                                           df.mean.squared.error = aov_out_l[nrow(aov_out_l),1],
             #                                           alternative = "two.sided"
             # )
           #}#end tukey
           # else if(ph_test==2){#games-howell
           #   
           #   results <- contrasts.games.howell.kgroups.simple(group.label = label
           #                                             ,group.mean = agg$data[,"mean"]
           #                                             ,group.variance = agg$data[,"sd"]^2,
           #                                             group.sample.size = agg$data[,"n"]
           #                                             ,conf.level.familywise = conf,
           #                                             n.means = length(label),
           #                                             mean.squared.error = aov_out_l[nrow(aov_out_l),3],
           #                                             alternative = "two.sided"
           #   )
           #   
           # }#end games-howell
           # else if(ph_test==3 || ph_test==4){#bonferroni or Holm #now handled with emmeans
           #   factor_combos <- data[which(colnames(data) %in% effect_names)]
           #   factor_columns <- colnames(factor_combos)
           #   combined<-apply(factor_combos[factor_columns], 1, function(row) {
           #     paste(paste(names(row), row, sep = " = "), collapse = ", ")
           #   })
           #   factor_combos$combined<-combined
           #   factor_combos$combined <- factor(factor_combos$combined)
           #   factor_combos$data<-data[[data_col]]
           #   if(ph_test==3){
           #     results<-pairwise.t.test(x = factor_combos$data,g = factor_combos$combined,p.adjust.method = "bonferroni",paired = FALSE)
           #   } else if (ph_test==4){
           #     results<-pairwise.t.test(x = factor_combos$data,g = factor_combos$combined,p.adjust.method = "holm",paired = FALSE)
           #   }
           #   p_values <- results$p.value
           #   p_values<-rbind(NA,p_values)
           #   p_values<-cbind(p_values,NA)
           #   rownames(p_values)[1]<-colnames(p_values)[1]
           #   colnames(p_values)[ncol(p_values)]<-rownames(p_values)[nrow(p_values)]
           #   
           #   full_matrix <- matrix(NA, nrow = nrow(p_values), ncol = ncol(p_values))
           #   rownames(full_matrix) <- rownames(p_values)
           #   colnames(full_matrix) <- colnames(p_values)
           #   
           #   # Fill the lower triangle
           #   full_matrix[lower.tri(full_matrix, diag = TRUE)] <- p_values[lower.tri(p_values, diag = TRUE)]
           #   
           #   # Transpose and fill the upper triangle
           #   full_matrix[upper.tri(full_matrix)] <- t(p_values)[upper.tri(full_matrix)]
           #   
           #   #create a decision matrix
           #   matrix.decision<-full_matrix
           #   matrix.decision[full_matrix<(1-conf)]<-"Reject"
           #   matrix.decision[full_matrix>=(1-conf)]<-""
           #   matrix.decision[is.na(full_matrix)]<-""
           #   
           #   results$matrix.decision<-matrix.decision
           # }
           output<-results[["matrix.decision"]]
           output<-DT::datatable(output,caption=test_name,
                                 options=
                                   list(columnDefs=list(list(className='dt-center',targets='_all')),
                                        dom="t",
                                        paging=FALSE),
                                 class = 'cell-border stripe')
           
         } # end for loop for each effect to be tested
         # highlight rejects
           #output<-datatable(output)%>%formatStyle(names(output),backgroundColor = styleEqual("Reject","yellow"))
         output
         
       })
       
       shiny_busy <- function() {
         # use &nbsp; for some alignment, if needed
         HTML("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", paste0(
           '<span data-display-if="',
           '$(&#39;html&#39;).attr(&#39;class&#39;)==&#39;shiny-busy&#39;',
           '">',
           '<i class="fa fa-spinner fa-spin-pulse fa-fw" style="color: #337ab7;" ></i>',# font-size:100px !important;# size doesn't work on the first time you hit the page
           '</span>'
         ))
       }
       
       output$busy<-renderUI({
         shiny_busy()
       })
       
       output$spc_analysis<-renderUI({
         if(input$spc_runchart){return()} else{
           prettySwitch(
             inputId = "x_spc_show_anova",
             label = "Show Analysis", 
             value = FALSE,
             status = "success",
             fill = TRUE
           )#end material switch
         }
       })

       #' Calculate ANOVA table with EMS 
       #' Modified to return non rounded results
       #' Calculate ANOVA table with EMS for various experimental design - factorial design, nested
       #' design, mixed effect model, etc.
       #' @usage EMSanova(formula,data,type=NULL,nested=NULL,
       #'                  level=NULL,approximate=FALSE)
       #' @param formula model formula         
       #' @param data data frame for ANOVA
       #' @param type the list of fixed/random for each factor. 
       #'        "F" for the fixed effect, "R" for the random effect
       #' @param nested the list of nested effect
       #' @param level list of model level
       #' @param approximate calculate approximated F for "TRUE"
       #' @export
       #' @examples
       #' data(baseball)
       #' anova.result<-EMSanova(velocity~Group+Subject+test,data=baseball,
       #'                  type=c("F","R","F"),
       #'                  nested=c(NA,"Group",NA),
       #'                  level=c(1,1,2))
       #' anova.result                  
       EMSanova_roi<-function(formula,data,type=NULL,nested=NULL,
                          level=NULL,approximate=FALSE){
         
         Call<-match.call()
         indx<-match(c("formula","data"),names(Call),nomatch=0L)
         if(indx[1]==0L) 
           stop("a 'formula' argument is required")
         temp<-Call[c(1L,indx)]
         temp[[1L]]<-quote(stats::model.frame)
         m<-eval.parent(temp)
         Terms<-attr(m,"terms")
         
         formula.t<-as.character(formula)
         Y.name<-formula.t[2]
         data.n<-strsplit(formula.t[3]," \\+ ")[[1]]
         if(data.n[1]=="."){
           var.list<-colnames(data)[colnames(data)!=Y.name]
         } else{
           temp1<-unlist(sapply(data.n,strsplit," "))
           var.list<-unique(temp1[temp1!=" " & temp1 !="*"& temp1!=""])
         } 
         ## adjust the order of X variable for multi-level model
         
         if(!is.null(level)){
           sort.id<-sort.list(level)
           nested<-nested[sort.id]
           level<-level[sort.id]
           var.list<-var.list[sort.id]
           type<-type[sort.id]
           #if(!is.null(n.table)) n.table[1:length(sort.id)]<-n.table[sort.id]
         }  
         if(!is.null(nested) &ifelse(length(nested)!=0,sum(!is.na(nested)),0)!=0){
           nested<-lapply(nested,function(x){ 
             xx<-strsplit(x,split="\\*")[[1]];
             temp<-NULL
             for(i in 1:length(xx))
               temp<-c(temp,which(var.list==xx[i]));
             if(length(temp)==0){
               return(NA)
             } else{
               return(temp)
             }})
         } else{
           nested<-as.list(rep(NA,length(var.list)))
         }   
         EMSflag<-FALSE
         n.table<-NULL
         for(i in 1:length(var.list)){
           temp<-table(data[,var.list[i]])
           if(sum(temp!=mean(temp))!=0)
             EMSflag<-TRUE
           n.table<-c(n.table,length(temp))
         }
         n.table<-c(n.table,mean(table(apply(data[,var.list,drop=FALSE],1,
                                             function(x) paste(x,collapse="")))))
         if(EMSflag){
           stop("EMSanova cannot handle the unbalanced design.")
         }  
         ## Change all X variables to factors
         
         data<-data[,c(var.list,Y.name)]
         for(i in var.list){
           data[,i]<-factor(data[,i])
         }
         
         ## design.M1
         
         n<-length(var.list)
         design.M1 <- NULL
         for(i in 1:n){
           design.M1<-rbind(design.M1,design.M1)
           temp1<-rep(c("",var.list[i]),each=2^(i-1))
           design.M1<-cbind(design.M1,temp1)
         }
         
         design.M1<-design.M1[-1,,drop=FALSE]
         
         ## Full model ANOVA
         
         model.F<-paste(Y.name,"~",paste(apply(design.M1,1,function(x) 
           paste(paste(x[x!=""],collapse="*"))),collapse="+"))
         model.id<-c(apply(design.M1,1,function(x) 
           paste(paste(x[x!=""],collapse=":"))),"Residuals")
         options(warn=-1)
         SS.table<-stats::anova(stats::lm(eval(model.F),
                                          data = data))[model.id,1:2]
         aov_mod<-stats::lm(formula,data = data)
         aov_model(aov_mod)#send it out for other functions
         modelSS<-stats::anova(aov_mod)[,1:2]
         options(warn=0)
         ## treat nested
         
         colnames(design.M1)<-var.list
         nest.id<-which(!is.na(nested))
         if(length(nest.id)>0){
           for(i in 1:length(nest.id)){
             for(j in 1:length(nested[[nest.id[i]]])){
               temp.list<-apply(design.M1[,1:n],1,function(x) 
                 ifelse(sum(x==var.list[nest.id[i]])==0,
                        NA,var.list[nested[[nest.id[i]]][j]]))
               del.list<-which(apply(design.M1[,1:n],1,function(x) 
                 sum(x==var.list[nest.id[i]])*
                   sum(x==var.list[nested[[nest.id[i]]][j]]))==1)
               for(k in 1:length(del.list)){
                 comb.id<-del.list[k]
                 temp.k<-design.M1[comb.id,]
                 temp.k<-temp.k[temp.k!="" & temp.k!=var.list[nested[[nest.id[i]]][j]]]
                 temp.k<-paste(temp.k,collapse="")
                 comb.id<-c(comb.id,which(apply(design.M1,1,
                                                function(x) paste(x,sep="",collapse=""))==temp.k))
                 SS.temp<-apply(SS.table[comb.id,],2,sum)
                 SS.table[comb.id[length(comb.id)],]<-SS.temp
               }
               design.M1<-cbind(design.M1,temp.list)
               colnames(design.M1)<-c(colnames(design.M1)[-ncol(design.M1)],"nested")
               design.M1<-design.M1[-del.list,]
               SS.table<-SS.table[-del.list,]
               
               ## nested-nested-...
               
               flag<-TRUE
               id.t<-nest.id[i]
               while(flag){
                 n.id.t<-nested[[id.t]]
                 temp.c<-unlist(nested[n.id.t])
                 temp.c<-temp.c[!is.na(temp.c)]
                 
                 if(length(temp.c)==0){
                   flag<-FALSE
                 }else{
                   for(l in 1:length(temp.c)){
                     temp.j<-ncol(design.M1)        
                     del.list<-which(apply(design.M1,1,function(x) 
                       sum(x[1:n]==var.list[temp.c[l]])*!is.na(x[temp.j]))==1)
                     design.M1<-design.M1[-del.list,]    
                     SS.temp<-apply(SS.table[del.list,],2,sum)
                     design.M1[which(design.M1[,temp.j] ==
                                       var.list[nested[[nest.id[i]]][j]]),
                               n+temp.c[l]]<-var.list[temp.c[l]]
                     sel.id<-which(design.M1[,temp.j] ==
                                     var.list[nested[[nest.id[[i]]]][j]])
                     SS.table[sel.id,] <-SS.table[sel.id,]+SS.temp
                     SS.table<-SS.table[-del.list,]
                   }  
                 }
                 id.t<-nested[[id.t]]
               }
             }
           } 
         }  
         
         ## EMS.table
         
         design.M1[is.na(design.M1)]<-""
         out<-apply(design.M1,1,function(x) 
           ifelse(paste(x[-(1:n)],collapse="")!="",
                  paste(paste(x[1:n][x[1:n]!=""],collapse=":"),
                        "(",paste(x[-(1:n)][x[-(1:n)]!=""],collapse="*"),
                        ")",sep=""),
                  paste(x[1:n][x[1:n]!=""],collapse=":")))
         rownames(SS.table)[-nrow(SS.table)]<-out
         EMS.table<-matrix(0,ncol=length(var.list)+1,nrow=length(out)+1)
         colnames(EMS.table)<-c(var.list,"Error")
         rownames(EMS.table)<-c(out,"Error")
         n.EMS<-nrow(EMS.table)
         p.EMS<-ncol(EMS.table)
         EMS.table[,p.EMS]<-n.table[p.EMS]
         EMS.table[n.EMS,]<-1
         temp<-design.M1[,1:length(var.list),drop=FALSE]
         temp.nest<-design.M1[,-c(1:length(var.list)),drop=FALSE]
         temp[temp==""]<-NA
         for(i in 1:ncol(temp)){
           if(sum(temp[,i]==var.list[i],na.rm=TRUE)!=0){
             id.t<-which(is.na(temp[,i]))
             EMS.table[id.t,i]<-n.table[i]
             if(type[i]=="R")  EMS.table[-c(id.t,n.EMS),i]<-1
           }else{
             sel.id<-which(!is.na(temp[,i]))
             EMS.table[sel.id,which(var.list==temp[sel.id,i][1])]<-1
           }   
           if(length(nest.id)>0){
             for(k in 1:ncol(temp.nest))
               EMS.table[which(temp.nest[,k]==var.list[i]),i]<-1     
           }
         }    
         
         ## EMS  
         
         temp.t<-design.M1[,1:length(var.list),drop=FALSE]
         EMS<-NULL
         n.E<-nrow(EMS.table)
         id.keep<-NULL 
         hid.flag<-NULL
         for(i in n.E:1){
           if(i!=n.E){
             sel.id<-temp.t[i,,drop=FALSE]
             if(length(nest.id)>0){
               tt<-temp.nest[i,]
               id.keep<-NULL
               for(l in 1:length(tt))
                 id.keep<-c(id.keep,which(names(hid.flag)==tt[l]))
             }          
             hid.flag<-rep(TRUE,ncol(EMS.table))
             names(hid.flag)<-colnames(EMS.table)
             for(j in 1:length(var.list)){
               hid.flag[which(names(hid.flag)==sel.id[j])]<-FALSE
             }
             pick.id<-design.M1[i,]
             pick.id<-pick.id[pick.id!=""]
             temp<-apply(design.M1,1,function(x) {
               keep.t<-TRUE; 
               for(i in 1:length(pick.id)) 
                 keep.t<-keep.t*(sum(x==pick.id[i])!=0)
               return(keep.t)})
             hid.flag[id.keep]<-TRUE
             temp.T<-apply(EMS.table[,hid.flag,drop=FALSE],1,prod)
             temp.T.1<-temp.T[temp.T!=0]
             temp.T.1[length(temp.T.1)]<-""
             name.temp.T<-names(temp.T.1)
             temp<-c(temp,1)[temp.T!=0]
             nn<-length(temp.T.1)    
             temp.T.1<-temp.T.1[nn:1] 
             name.temp.T<-name.temp.T[nn:1] 
             temp<-temp[nn:1] 
             temp.EMS<-paste(temp.T.1[temp==1],name.temp.T[temp==1],
                             sep="",collapse="+")
           }else{
             temp<-c(rep(0,ncol(EMS.table)-1),1)
             temp.EMS<-"Error"
           }
           EMS<-cbind(temp.EMS,EMS)
         }
         
         ## model level
         
         if(!is.null(level)){
           level.list<-sort(unique(level))
           n.L<-length(level.list)
           Model.level<-rep(level.list[n.L],nrow(SS.table)-1)    
           temp.flag<-rep(TRUE,length(Model.level))
           for(i in n.L:1){
             i.id<-which(level==i)
             for(k in i.id){
               Model.level[which((design.M1[,k]!="")*temp.flag==1)]<-i
               temp.flag[design.M1[,k]!=""]<-FALSE
             }    
           }
           Model.level<-c(Model.level,max(Model.level))
         }else{
           Model.level<-NULL
         }   
         n.t<-nrow(SS.table)
         flag.zero.MSE<-FALSE  
         
         if(SS.table[n.t,2]==0){
           SS.table[n.t,1:2]<-SS.table[n.t-1,1:2] 
           temp.name<-rownames(SS.table)[n.t]
           SS.table<-SS.table[-n.t,]
           rownames(SS.table)[n.t-1]<-temp.name
           t.EMS<-lapply(EMS,function(x) strsplit(x,"[+]")[[1]])
           del.list<-t.EMS[[n.t-1]][-1]
           for(i in 1:length(t.EMS)){
             keep.id<-NULL
             for(j in 1:length(del.list))
               keep.id<-c(keep.id,which(t.EMS[[i]]==del.list[j]))
             if(length(keep.id)!=0)
               t.EMS[[i]]<-t.EMS[[i]][-keep.id]
           }
           EMS<-unlist(lapply(t.EMS,function(x) paste(x,sep="",collapse="+")))
           EMS[n.t-1]<-EMS[n.t]
           EMS<-EMS[1:(n.t-1)]
           flag.zero.MSE<-TRUE
           Model.level<-Model.level[1:(n.t-1)]
         }
         ## Calculate MS, F (approx.F), P-value, sig,
         
         SS.table[,3]<-SS.table[,2]/SS.table[,1]
         split.EMS<-lapply(EMS,function(x) strsplit(x,"[+]")[[1]])
         F.value<-NULL
         P.value<-NULL
         Signif<-NULL
         for(i in 1:nrow(SS.table)){
           n.SE<-length(split.EMS[[i]])
           SS.temp<-paste(split.EMS[[i]][-n.SE],collapse="+")
           if(sum(EMS==SS.temp)!=0){
             F.temp<-SS.table[i,3]/SS.table[which(EMS==SS.temp),3]
             pValue.temp<- 1-stats::pf(F.temp,SS.table[i,1],
                                       SS.table[which(EMS==SS.temp),1])
           }else if(i!=nrow(SS.table) & approximate){
             test.EMS<-split.EMS[[i]]
             Appr.result<-ApproxF_roi(SS.table=data.frame(SS.table,EMS=c(EMS)),
                                  approx.name=rownames(SS.table)[i])#error here since the order of the EMS is supposed to have the effect itself last, doesn't work with nested
             F.temp<-Appr.result$Appr.F
             pValue.temp<-Appr.result$Appr.Pvalue
           } else{
             F.temp<-NA
             pValue.temp<-NA
           }
           
           # if(!is.na(pValue.temp)){
           #   if(pValue.temp<=0.001){
           #     Signif.temp <- "***"
           #   }else if(pValue.temp<=0.01){
           #     Signif.temp <- "**"
           #   }else if(pValue.temp<=0.05){
           #     Signif.temp <- "*"
           #   }else if(pValue.temp<=0.1){
           #     Signif.temp <- "."
           #   }else{
           #     Signif.temp <- ""
           #   }
           #   pValue.temp <- pValue.temp#ifelse(round(pValue.temp,4)<0.0001,
           #                  #       "<0.0001",round(pValue.temp,4))
           #   F.temp <- F.temp
           # }else{
           #   Signif.temp <- ""
           #   pValue.temp <- ""
           #   F.temp<-""
           # }
           F.value<-c(F.value,F.temp)
           P.value<-c(P.value,pValue.temp)
           Signif<-c(Signif,"")#,Signif.temp)    
         }
         
         SS.table.t<-cbind(SS.table[,1],SS.table[,2],SS.table[,3])
         colnames(SS.table.t)<-c("Df","SS","MS")
         if(!is.null(Model.level)){
           tot.result<-data.frame(SS.table.t,Fvalue=F.value,Pvalue=P.value,
                                  Sig=Signif,Model.Level=Model.level,EMS=matrix(EMS))   
           
         }else{
           tot.result<-data.frame(SS.table.t,Fvalue=F.value,Pvalue=P.value, #breaks here due to F and P only being 2 long due to error in approx
                                  Sig=Signif,EMS=matrix(EMS))   
         }
         rownames(tot.result)<-rownames(SS.table)  
         return(tot.result)
       }
       
       #' Calculate ANOVA with approximate F value
       #' Modified to fix bug with nested random effects
       #' Calculate ANOVA with approximate F value
       #' @usage ApproxF(SS.table,approx.name)
       #' @param SS.table result from EMSanova  
       #' @param approx.name rowname in SS.table to calculate approximate F value for the test. 
       #' @export
       #' @examples
       #' data(film)
       #' anova.result<-EMSanova(thickness~Gate*Operator*Day,data=film,
       #'                         type=c("F","R","R"))
       #' anova.result                         
       #' ApproxF(SS.table=anova.result,approx.name="Gate") 
       #' EMSanova(thickness~Gate+Operator+Day,data=film,
       #'           type=c("F","R","R"),
       #'           approximate=TRUE)                      
       #'        
       ApproxF_roi<-function(SS.table,approx.name){
         approx.id<-NULL
         for(i in approx.name)
           approx.id<-c(approx.id,which(rownames(SS.table)==i))
         EMS<-as.character(SS.table$EMS)
         split.EMS<- lapply(EMS,function(x) strsplit(x,"[+]")[[1]])
         #split.EMS.last<-lapply(split.EMS,function(x) return(x[length(x)]))  #assumes the last item is the effect
         split.EMS.last<-list()
         rownum<-1
         for(effect in row.names(SS.table)){
           flat<-unlist(split.EMS[rownum])
           if(length(flat)==1){
             if(flat=="Error"){effect_element<-"Error"}
           } else{
             effect_element<-grep(pattern = paste0("[0-9]+\\Q", effect, "\\E(?!\\W)"),x = flat,value = TRUE,perl = TRUE)#Q and E escape regex characters, (?!\\W) makes sure there is nothing after the match
           }
           split.EMS.last<-c(split.EMS.last,effect_element)
           rownum<-rownum+1
         }
         
         split.EMS.last<-as.list(split.EMS.last)
         #split.EMS extra line at start
         
         test.EMS<-split.EMS[[approx.id]]
         n.SE<-length(test.EMS)
         TEMP.EMS<-test.EMS[-grep(pattern = paste0("[0-9]+",approx.name),x = test.EMS)]#old script was test.EMS[-n.SE] #this only works if the last item is the effect, which doesn't happen with nested
         keep.id<-NULL
         keep.var<-NULL
         for(kk in 2:length(TEMP.EMS)){
           keep.id<-c(keep.id,which(split.EMS.last==TEMP.EMS[kk]))
           keep.var<-c(keep.var,TEMP.EMS[kk])  
         }
         #keep.var<-keep.var[keep.id!=1]# error here - this messes up case 6 - not needed?
         TEMP.EMS<-unlist(split.EMS[keep.id])
         TEMP.EMS<-TEMP.EMS[TEMP.EMS!="Error"]
         den.id<-names(table(TEMP.EMS))[table(TEMP.EMS)==1]
         ms.num<-SS.table[approx.id,3]
         ms.den<-0
         df.num<-SS.table[approx.id,3]^2/SS.table[approx.id,1]
         df.den<-0
         
         for(kk in 1:length(keep.var)){
           if(sum(keep.var[kk]==den.id)==1){
             id.i<-which(split.EMS.last==keep.var[kk])
             ms.den<-ms.den+SS.table[id.i,3]
             df.den<-df.den+SS.table[id.i,3]^2/SS.table[id.i,1]
           }else{  
             id.i<-which(split.EMS.last==keep.var[kk])
             ms.num<-ms.num+SS.table[id.i,3]
             df.num<-df.num+SS.table[id.i,3]^2/SS.table[id.i,1]    
           }
         }
         Appr.F<-ms.num/ms.den
         Appr.F.df1<-ms.num^2/df.num
         Appr.F.df2<-ms.den^2/df.den
         Appr.Pvalue<-1-stats::pf(Appr.F,Appr.F.df1,Appr.F.df2)
         return(list(Appr.F=Appr.F,df1=Appr.F.df1,df2=Appr.F.df2,Appr.Pvalue=Appr.Pvalue))
       } 
       
       #' Pooling nonsignificant interactions to Residuals
       #' 
       #' Pooling nonsignificant interactions to Residuals
       #' @usage PooledANOVA(SS.table,del.ID)
       #' @param SS.table result from EMSanova  
       #' @param del.ID id's to combine sum of squares. Use rownames of SS.table
       #' @export
       #' @examples
       #' data(film)
       #' anova.result<-EMSanova(thickness~Gate*Operator*Day,data=film,
       #'                         type=c("F","R","R"))
       #' anova.result 
       #' del.ID<-c("Gate:Day","Residuals")
       #' PooledANOVA(anova.result,del.ID)
       
       PooledANOVA_roi<-function(SS.table,del.ID){
         temp.SS<-SS.table[,c("Df","SS")]
         temp.EMS<-as.character(SS.table$EMS)
         Model.level<-SS.table$Model.Level
         temp.ID<-del.ID[del.ID!="Residuals"]
         temp.ID<-unlist(lapply(temp.ID,function(x) which(rownames(temp.SS)==x)))
         temp.EMS<-as.character(temp.EMS)
         temp.SS[nrow(temp.SS),]<-apply(temp.SS[del.ID,],2,function(x) sum(x,na.rm=TRUE))
         temp.SS<-temp.SS[-temp.ID,]
         Model.level<-Model.level[-temp.ID]
         
         temp.SS[,3]<-temp.SS[,2]/temp.SS[,1]
         temp.split.EMS<-lapply(temp.EMS,function(x) {
           temp1<-strsplit(x,"[+]")[[1]]
           for(i in 1:length(temp.ID)){
             t.id<-grep(del.ID[i],temp1)
             if(length(t.id)!=0)
               temp1<-temp1[-t.id]
           }
           return(temp1)})
         
         temp.split.EMS<-temp.split.EMS[-temp.ID]    
         EMS.t<-lapply(temp.split.EMS,function(x) paste(x,sep="",collapse="+"))
         
         F.value<-NULL
         P.value<-NULL
         Signif<-NULL
         for(i in 1:nrow(temp.SS)){
           n.SE<-length(temp.split.EMS[[i]])
           SS.temp<-paste(temp.split.EMS[[i]][-n.SE],collapse="+")
           test.EMS<-temp.split.EMS[[i]]
           if(sum(temp.EMS==SS.temp)!=0){
             F.temp<-temp.SS[i,3]/temp.SS[which(EMS.t==SS.temp),3]
             pValue.temp<- 1-stats::pf(F.temp,temp.SS[i,1],
                                       temp.SS[which(EMS.t==SS.temp),1])
           } else if(i!=nrow(temp.SS)&& length(test.EMS)!=1){#added &
             Appr.result<-ApproxF(data.frame(temp.SS,EMS=unlist(EMS.t)),rownames(temp.SS)[i])
             F.temp<-Appr.result$Appr.F
             pValue.temp<-Appr.result$Appr.Pvalue
           } else{
             F.temp<-NA
             pValue.temp<-NA
           }
           
           if(!is.na(pValue.temp)){
             if(pValue.temp<=0.001){
               Signif.temp <- "***"
             }else if(pValue.temp<=0.01){
               Signif.temp <- "**"
             }else if(pValue.temp<=0.05){
               Signif.temp <- "*"
             }else if(pValue.temp<=0.1){
               Signif.temp <- "."
             }else{
               Signif.temp <- ""
             }
             #pValue.temp <- ifelse(round(pValue.temp,4)<0.0001,
              #                     "<0.0001",round(pValue.temp,4))
             #F.temp <- round(F.temp,4)
           }else{
             Signif.temp <- ""
             pValue.temp <- ""
             F.temp<-""
           }
           F.value<-c(F.value,F.temp)
           P.value<-c(P.value,pValue.temp)
           Signif<-c(Signif,Signif.temp)    
         }
         
         SS.table.t<-cbind(temp.SS[,1],
                           round(temp.SS[,2],4),
                           round(temp.SS[,3],4))
         colnames(SS.table.t)<-c("Df","SS","MS")
         EMS.t<-as.character(EMS.t)
         if(!is.null(Model.level)){
           tot.result<-data.frame(SS.table.t,Fvalue=F.value,Pvalue=P.value,
                                  Sig=Signif,Model.Level=Model.level,EMS=matrix(EMS.t))    
         }else{
           tot.result<-data.frame(SS.table.t,Fvalue=F.value,Pvalue=P.value,
                                  Sig=Signif,EMS=matrix(EMS.t))   
         }
         rownames(tot.result)<-rownames(temp.SS) 
         
         return(tot.result)
       }
       

}#end server

#Run the application to debug
# profvis::profvis(
#   expr = runApp(shinyApp(ui = ui, server = server))
#   ,prof_output = "C:/Users/smoue/Desktop"
# )

shinyApp(ui = ui, server = server)

